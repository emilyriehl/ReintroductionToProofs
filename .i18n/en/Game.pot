msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-28\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `p`
#. §4: `P`
#. §5: `h1`
#. §6: `P → Q`
#. §7: `h2`
#. §8: `Q → R`
#. §9: `R`
#. §10: `Show more help!`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "Now we are in the setting of three proposition variables §0, §1, and §2 with several hypotheses.\n"
"\n"
"The first assumption provides a proof §3 that the proposition §4 is true.\n"
"\n"
"The second provides a proof §5 that the implication §6 is true.\n"
"\n"
"The final hypothesis provides a proof §7 that §8 is true. Our goal is to conclude that §9 is true.\n"
"\n"
"If you need help, click the button §10 for reminders/hints."
msgstr ""

#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Universal property"
msgstr ""

#. §0: `Empty.elim`
#. §1: `Prod.snd`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "If your answer does not use the functions §0 and §1, you might have fun trying to solve this level again using them in appropriate places."
msgstr ""

#. §0: `B × D → M`
#. §1: `E → Y × N`
#. §2: `A → M → X`
#. §3: `C → N → Z`
#. §4: `A × B × C × D × E`
#. §5: `X × Y × Z`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Given functions of types §0, §1, §2, and §3, there is a function from the product type §4 to the product type §5."
msgstr ""

#. §0: `«{P}» → «{P}»`
#. §1: `intro p`
#. §2: `p : «{P}»`
#. §3: `«{P}»`
#. §4: `intro`
#. §5: `«{P}»`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "When the goal has the form §0, type §1 to introduce an assumption §2 and update the goal to §3.\n"
"\n"
"It is also possible to type simply §4 in which case Lean will automatically generate a name for the proof of §5."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Disjunction Boss Level"
msgstr ""

#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now we're ready for the boss level."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Prod.snd : A × B → B`
#. §3: `p : A × B`
#. §4: `p.2 : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "For any types §0 and §1, §2 is the function that sends §3 to its second coordinate §4."
msgstr ""

#. §0: `a : A`
#. §1: `f : A → B`
#. §2: `f a : B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "Define the *evaluation* function that takes §0 and §1 to §2."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A × B → B × A`
#. §3: `⟨a, b⟩`
#. §4: `⟨b, a⟩`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "For types §0 and §1, the swapping function has type §2 and can be thought of as the function that sends a pair §3 to the pair §4."
msgstr ""

#. §0: `P`
#. §1: `R → S ∧ T`
#. §2: `U → P → R`
#. §3: `(U → Y) → Z`
#. §4: `W ∧ T ∧ V → X ∧ Y`
#. §5: `S → V ∧ W`
#. §6: `Z`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "If §0, §1, §2, §3, §4, and §5 are true, then §6 is true."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#. §3: `¬ ¬ ¬ P → ¬ P`
#. §4: `P`
#. §5: `¬ P`
#. §6: `¬ ¬ ¬ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "This level contains another tautology whose proof you have seen before.\n"
"\n"
"We will show that for any proposition §0, if §1 is not not false, then §2 is false.\n"
"\n"
"That is, we will prove §3.\n"
"\n"
"In fact, for any proposition §4, its negation §5 and its triple negation §6 are logically equivalent.\n"
"\n"
"So we will prove this too."
msgstr ""

#. §0: `f : X → A × B`
#. §1: `fun x ↦ (f x).1 : X → A`
#. §2: `fun x ↦ (f x).2 : X → B`
#. §3: `g : X → A`
#. §4: `h : X → B`
#. §5: `X`
#. §6: `X → A × B`
#. §7: `g`
#. §8: `h`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "We've seen that functions §0 into product types can be decomposed into component functions §1 and §2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions.\n"
"\n"
"To that end consider an arbitrary pair of functions §3 and §4 that have the same domain type §5 but are otherwise unrelated.\n"
"\n"
"These functions can be combined to define a single function of type §6 whose component functions are defined by §7 and §8, respectively."
msgstr ""

#. §0: `¬ Q`
#. §1: `Q → False`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that §0 is an abbreviation for the type §1."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "On Parentheses"
msgstr ""

#. §0: `swap`
#. §1: `unfold swap`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "This is true by definition, but Lean does not necessarily recall how §0 was defined. Type §1 to unfold this definition."
msgstr ""

#. §0: `f : X → A × B`
#. §1: `fun x ↦ (f x).1 : X → A`
#. §2: `fun x ↦ (f x).2 : X → B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that functions §0 into product types can be decomposed into component functions §1 and §2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions."
msgstr ""

#. §0: `A ⊕ B → C`
#. §1: `A → C`
#. §2: `B → C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "A function of type §0 may be split into component functions of types §1 and §2."
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "Absurd"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `a : A`
#. §4: `A ⊕ B`
#. §5: `Sum.inl : A → A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "For types §0 and §1, the coproduct type §2 has two kinds of elements. The first kind can be thought of as copies of elements §3 included into the coproduct §4 *on the left*.\n"
"\n"
"Lean has a built in function called §5."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A × B) × C`
#. §4: `A × (B × C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Product types are associative: for types §0, §1, and §2, there are canonical functions in each direction between the types §3 and §4."
msgstr ""

#. §0: `(P → Q) ∧ (P → R)`
#. §1: `P → Q ∧ R`
#. §2: `P → (Q ∧ R)`
#. §3: `S`
#. §4: `T`
#. §5: `S → (S → T) → T`
#. §6: `s : S`
#. §7: `h : S → T`
#. §8: `T`
#. §9: `h`
#. §10: `S`
#. §11: `s`
#. §12: `h s : T`
#. §13: `h`
#. §14: `s`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "The task in this level is to show another logical equivalence,\n"
"this time between the conjoined implications §0 and the implication §1, which is implicitly parenthesized as §2.\n"
"\n"
"The proof will require an idea that we have not used for a while. We've seen that for propositions §3 and §4,\n"
"§5 can be proven by introducing hypotheses §6 and §7, at which point the goal is to prove §8.\n"
"Then applying the hypothesis §9 reduces the goal to proving §10 which we know is true by §11.\n"
"\n"
"Recall there is special notation\n"
"§12 for the proof constructed by applying the hypothesis §13 to the hypothesis §14.\n"
"\n"
"The intuition behind this notation will be explained in the next world."
msgstr ""

#. §0: `«{P}»`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Now the goal is to prove §0 using *any* of our given hypotheses. Which tactic can be used to supply this proof?"
msgstr ""

#. §0: `∨`
#. §1: `P`
#. §2: `Q`
#. §3: `P ∨ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∨ Q`
#. §7: `P ∨ Q`
#. §8: `P ∨ Q`
#. §9: `P`
#. §10: `Q`
#. §11: `P`
#. §12: `Q`
#. §13: `P ∨ Q`
#. §14: `h : P ∨ Q`
#: Game.Levels.DisjunctionWorld
msgid "The logical connective of *disjunction*, denoted by §0, is the mathematical version of *or*.\n"
"\n"
"For arbitrary propositions §1 and §2, §3 is a new proposition asserting that at least one of §4 *or* §5 *are true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §6.\n"
"* How to use a hypothesis of the form §7 to prove something else.\n"
"\n"
"There are two strategies to prove §8. It suffices to supply a proof of §9 and it also suffices to supply a proof of §10.\n"
"\n"
"Note that the mathematical &ldquo;or&rdquo; is *inclusive*, meaning that if §11 and §12 are both true, then §13 is true.\n"
"\n"
"Using a hypothesis §14 leads to a proof strategy of arguing &ldquo;by cases&rdquo; as we will soon discover."
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What sort of type does §0 belong to? Can we extract other elements from an element of this type?"
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "The goal is a function type. What tactic can be used to define an element?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What is the outermost logical connective?"
msgstr ""

#. §0: `(P ∧ R) ∨ ((P ∧ S) ∨ ((Q ∧ R) ∨ (Q ∧ S)))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "The implicit parentheses in the goal are to the right §0."
msgstr ""

#. §0: `ext a b`
#. §1: `(swap (swap f)) a b = f a b`
#. §2: `a : A`
#. §3: `b : B`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Type §0 to reduce to the problem of proving that §1 for generic elements §2 and §3."
msgstr ""

#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Which function might be useful to apply here?"
msgstr ""

#. §0: `.1`
#. §1: `.2`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Note the §0 and §1 notation can be iterated."
msgstr ""

#. §0: `Boss Level`
#. §1: `have`
#. §2: `have`
#. §3: `p : P`
#. §4: `h : P → Q`
#. §5: `have q : Q := h p`
#. §6: `q : Q`
#. §7: `h p`
#. §8: `</>`
#. §9: `editor mode`
#. §10: `>_`
#. §11: `typewriter mode`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Each world will end with a §0, which is intended to be more challenging than the levels that came before. Have fun with this.\n"
"\n"
"While it is not necessary to solve this level, you may enjoy experimenting with the new §1 tactic that is now added to the tactic library.\n"
"\n"
"The §2 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions §3 and §4, type §5 to add a proof §6 defined by §7.\n"
"\n"
"To delete a proof (or proof attempt) and start over click on the button labelled §8 in the upper right hand corner to enter §9. Then delete all the lines of your first proof (or proof attempt). Clicking on §10 takes you back to §11."
msgstr ""

#. §0: `«{pnq}»`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What can we prove with the hypothesis §0?"
msgstr ""

#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Composition revisited"
msgstr ""

#. §0: `A`
#. §1: `a : A`
#. §2: `a = a`
#. §3: `rfl : a = a`
#. §4: `rfl`
#. §5: `a = a`
#. §6: `a = a`
#. §7: `exact rfl`
#. §8: `rfl`
#. §9: `exact rfl`
#. §10: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Let §0 be a type with an element §1. Then the proposition §2 is always true\n"
"because there is a proof §3 witnessing the *reflexivity* of equality.\n"
"\n"
"In Lean, §4 is a name for an element of the type §5. So to produce a proof of §6, you\n"
"can type §7. As a shorthand, Lean also defines a tactic called §8 that is shorthand for\n"
"§9. So you can solve the goal by typing simply §10."
msgstr ""

#. §0: `intro h1 h2 h3`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Multiple hypothesis can be introduced at once by writing §0 etc. You might consider using names that will help you remember which propositions each hypothesis proves!"
msgstr ""

#. §0: `P`
#. §1: `P → ¬ ¬ P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition §0, §1."
msgstr ""

#. §0: `«{andn}»`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What proofs can you extract from the hypothesis §0?"
msgstr ""

#. §0: `A`
#. §1: `A → Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "In summary, something very strange happens if the types §0 and §1 both have elements."
msgstr ""

#. §0: `«{f}» : A → Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "We have an assumption §0. What can be done with an element of a function type?"
msgstr ""

#. §0: `Active Goal`
#. §1: `objects`
#. §2: `assumptions`
#. §3: `goal`
#. §4: `P`
#. §5: `p : P`
#. §6: `p`
#. §7: `P`
#. §8: `P`
#. §9: `assumption`
#. §10: `p`
#. §11: `exact p`
#. §12: `assumption`
#. §13: `exact`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "An interative theorem prover &mdash; in this case Lean &mdash; helps the user &mdash; this means you &mdash; keep track of the state of a proof.\n"
"\n"
"In the §0 window, Lean keeps track of the §1 and §2 &mdash; which together define the hypotheses of a mathematical statement &mdash; as well as the §3 &mdash; meaning the thing we are trying to prove.\n"
"\n"
"Our first mathematical theorem is about an arbitrary proposition §4 which can be any well-formed mathematical statement.\n"
"\n"
"The hypothesis §5  can be thought of as providing a *proof* §6 that the proposition §7 is true. Our objective is to conclude that §8 is true, given this hypothesis.\n"
"\n"
"This is true by assumption, and you can type §9 to tell Lean this.\n"
"\n"
"But it is a bit more precise to tell Lean this is true by the assumption §10 which can be done by typing §11.\n"
"\n"
"Note both §12 and §13 are *tactics* that are built into Lean. You can now find them in the tactic library on the upper right."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Second Projection"
msgstr ""

#. §0: `swap`
#. §1: `f : A → B → C`
#. §2: `swap f : B → A → C`
#. §3: `b : B`
#. §4: `a : A`
#. §5: `f a b : C`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "The §0 function exchanges the inputs of a function of two variables. For a function with two variables §1, §2 is the function that sends §3 and §4 to §5."
msgstr ""

#. §0: `↔`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the §0 is the outermost logical connective. If you've forgotten what this means, you can look it up in the library."
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Using Functions"
msgstr ""

#. §0: `«{f}».1`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What type does §0 belong to? Is this useful?"
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Currying"
msgstr ""

#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "From a function of two variables, define another function of two variables, where the inputs are swapped."
msgstr ""

#. §0: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Now that you are stuck, it is a good time to try classical reasoning. Try §0 and see how this transforms the goal."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does either proof in this logical equivalence seem familiar? Do they both seem familar?"
msgstr ""

#. §0: `False`
#. §1: `P`
#. §2: `False → P`
#. §3: `False`
#. §4: `Empty`
#. §5: `False`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The proposition §0 has no elements &mdash; there are no proofs of &ldquo;false.&rdquo;.\n"
"\n"
"Consequently, for any other proposition §1, the implication §2 is true.\n"
"\n"
"The task in this level is to prove this.\n"
"\n"
"The proposition §3 is really just another name for the empty type §4, so the same constructions explored in Empty World can be used to prove propositions involving §5."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "For any proposition §0, §1 implies §2 is true."
msgstr ""

#. §0: `(P → Q) → R`
#. §1: `P → (Q → R)`
#. §2: `P → Q → R`
#. §3: `P → (Q → R)`
#. §4: `P ∧ Q → R`
#. §5: `(P ∧ Q) → R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Recall that implication is *NOT* associative: the propositions §0 and §1 are not logically equivalent, and §2 is an abbreviation for the former.\n"
"\n"
"One reason that mathematical statements of the form §3 are more prevalent is that this is implied by §4, which is implicitly parenthesized as §5."
msgstr ""

#. §0: `x : A ⊕ B`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "We'll now study how hypothesis §0 can be used."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `∘ : (B → C) → (A → B) → (A → C)`
#. §4: `C`
#. §5: `∘ : (B → Empty) → (A → B) → (A → Empty)`
#. §6: `(A → B) → (B → Empty) → (A → Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "In this level, we will revisit the composition function in the presence of the empty type.\n"
"\n"
"Recall that for any types §0, §1, and §2, composition defines a function:\n"
"\n"
"§3.\n"
"\n"
"In particular, if §4 is the empty type, composition defines a function:\n"
"\n"
"§5.\n"
"\n"
"Your task in this level is to define the closely related variant of the composition function which has type:\n"
"\n"
"§6\n"
"\n"
"as this construction will be analogous to something we will encounter in the next world."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "If this is not the term you want, how can you use it to define the correct term?"
msgstr ""

#. §0: `A`
#. §1: `a b : A`
#. §2: `a = b`
#. §3: `a`
#. §4: `b`
#. §5: `P`
#. §6: `a = b`
#. §7: `a = b`
#. §8: `p : a = b`
#. §9: `a`
#. §10: `b`
#. §11: `A`
#. §12: `2 + 2 = 4`
#. §13: `2 + 2 4 : ℕ`
#. §14: `0 = 1`
#. §15: `0 1 : ℕ`
#. §16: `0 = 1`
#: Game.Levels.EqualityWorld
msgid "Consider a type §0. For any two elements §1 there is a proposition §2\n"
"that encodes the mathematical assertion that §3 and §4 are *equal*.\n"
"\n"
"Like with generic propositions §5, the proposition §6 is not necessarily *true*. To prove that\n"
"§7 is true, we must construct an element §8 which can be thought of as a *proof* that\n"
"§9 equals §10 as elements of type §11. For example: §12 is true for elements §13. In a few levels, we will construct a proof of this. But the proposition §14 is false, again for\n"
"§15. In a later level, we'll see how to prove its *negation*, in other words that §16 is\n"
"false."
msgstr ""

#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Contrapositive"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `f : A → Empty`
#. §3: `A → B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "For any types §0 and §1, if there is a function §2 then there is also a function §3."
msgstr ""

#. §0: `¬ (P ∨ Q)`
#. §1: `P ∨ Q`
#. §2: `P ∨ Q`
#. §3: `P`
#. §4: `P ∨ Q`
#. §5: `Q`
#. §6: `P ∨ Q`
#. §7: `P ∨ Q`
#. §8: `P`
#. §9: `Q`
#. §10: `¬ (P ∨ Q)`
#. §11: `¬ P ∧ ¬ Q`
#. §12: `↔`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"Recall, if §3 is true, then we can prove §4. Similarly, if §5 is true, we can prove §6.\n"
"\n"
"So if §7 is false, then both §8 and §9 must be false.\n"
"\n"
"In this level, we will show that §10 is logically equivalent to §11.\n"
"\n"
"If you have forgotten the meaning of logical equivalence, denoted §12, you can look it up in the library."
msgstr ""

#. §0: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Now Lean reminds you of the other goal, which is to prove §0. Which tactic applies here?"
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Negating Implication"
msgstr ""

#. §0: `¬ P ∨ ¬ Q`
#. §1: `¬ (P ∧ Q)`
#. §2: `¬ (P ∧ Q)`
#. §3: `¬ P ∨ ¬ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∨ ¬ P`
#. §7: `have := em P`
#. §8: `P ∨ ¬ P`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "We have seen that §0 implies §1.\n"
"\n"
"But we were not able to prove constructively that §2 implies §3, since we cannot tell whether §4 or §5 is the false proposition.\n"
"\n"
"However, we can prove this using classical logic.\n"
"\n"
"Recall that in classical logic, we may assume the *law of excluded middle*, i.e., that §6 is true for any proposition.\n"
"\n"
"In particular, in the middle of your proof, you can type §7 to introduce §8 as a hypothesis.\n"
"\n"
"Can you use this to prove the desired implication?"
msgstr ""

#. §0: `Prod.snd : A × B → B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"In the next level, we'll use the projection functions to prove symmetry of product types."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What is the logical form of the goal?"
msgstr ""

#. §0: `assumption`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "You can solve the goal by explicitly referring to the named hypothesis that Lean supplied or by typing §0 to indicate that the goal matches an assumption."
msgstr ""

#. §0: `∨`
#. §1: `P ∧ R`
#. §2: `(P ∧ S) ∨ ((Q ∧ R) ∨ (Q ∧ S))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Thus the outermost logical connective is the §0 combining §1 and §2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Do you see how this relates to the previous level?"
msgstr ""

#. §0: `P ∧ (Q ∨ R)`
#. §1: `(P ∧ Q) ∨ (P ∧ R)`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Conjunction distributes over disjunction: §0 and §1 are logically equivalent."
msgstr ""

#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "Composing Implication"
msgstr ""

#. §0: `«{i}»`
#. §1: `«{nq}»`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "What can you prove using §0 and §1?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "Currying Implication"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∧ Q`
#. §3: `P ∧ ¬ Q`
#. §4: `¬ P ∧ Q`
#. §5: `¬ P and ¬ Q`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "In classical logic, for any propositions §0 and §1, §2 is true or §3 is true or §4 is true or §5 is true."
msgstr ""

#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Swapping inputs"
msgstr ""

#. §0: `«{p}» : P`
#. §1: `¬ Q`
#. §2: `apply Or.inr`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Because  §0, it is clear that the strategy is to try to prove §1. You can focus on this goal by §2."
msgstr ""

#. §0: `P`
#. §1: `P ∨ ¬ P`
#. §2: `¬ ¬ P → P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The law of excluded middle implies double negation elimination: for any proposition §0, §1 implies §2."
msgstr ""

#. §0: `e : E`
#. §1: `E`
#. §2: `exact e`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If there is an assumption §0 and the goal has type §1, then §2 closes the goal."
msgstr ""

#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Reflexivity"
msgstr ""

#. §0: `(P ∨ Q) ∨ R`
#. §1: `P ∨ (Q ∨ R)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Or is associative: §0 is true if and only if §1 is true."
msgstr ""

#: Game.Levels.FunctionWorld
msgid "Function World"
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `¬ ¬ ¬ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "For any proposition §0, §1 is logically equivalent to §2."
msgstr ""

#. §0: `h : P ∧ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `h.1 : P`
#. §4: `h.2 : Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "A hypothesis §0 provides explicit proofs of both §1 and §2 which are denoted in Lean by §3 and §4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Can we apply our hypothesis now?"
msgstr ""

#. §0: `f : A × B → C`
#. §1: `a : A`
#. §2: `b : B`
#. §3: `C`
#. §4: `f ⟨a,b⟩`
#. §5: `g : A → B → C`
#. §6: `g`
#. §7: `a : A`
#. §8: `b : B`
#. §9: `C`
#. §10: `g a b : C`
#. §11: `A × B → C`
#. §12: `A → B → C`
#. §13: `A`
#. §14: `B`
#. §15: `C`
#. §16: `f : A × B → C`
#. §17: `⟨a, b⟩ : A × B`
#. §18: `C`
#. §19: `g : A → B → C`
#. §20: `a : A`
#. §21: `g a : B → C`
#. §22: `b : B`
#. §23: `C`
#. §24: `A × B → C`
#. §25: `A → B → C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Consider a function §0 mapping out of a product type.\n"
"\n"
"This function takes an ordered pair of elements &mdash; defined from §1 and §2 &mdash; and returns an element of type §3 denoted by §4. Does this sound familiar?\n"
"\n"
"Recall that terms of type §5 aree functions of two variables.\n"
"\n"
"The function §6 takes a list of two elements §7 and §8 and returns an element of type §9 denoted by §10.\n"
"\n"
"In summary, the types §11 and §12 both provide a notion of function of two variables, with inputs from the types §13 and §14 and output in the type §15.\n"
"\n"
"The difference is that §16 is thought of as a function that takes a pair §17 to an element of type §18, while §19 is thought of as a function that takes §20 to a function §21 (which then takes §22 to an element of type §23).\n"
"\n"
"The process of converting a function of type §24 to one of type §25 is called *currying* and is defined by the function below."
msgstr ""

#. §0: `intro`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L08_Evaluation
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "When in doubt, start defining a function by using the tactic §0 followed by your preferred variable name."
msgstr ""

#. §0: `rcases`
#. §1: `h : (P ∨ Q) ∨ R`
#. §2: `rcases h with (p | q) | r`
#. §3: `k : P ∨ Q ∨ R`
#. §4: `rcases k with p | q | r`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "This proves the associativity of disjunction.\n"
"\n"
"Note the §0 tactic allows more general patterns of disjunctions. Given §1 try §2. Similarly, given §3, try §4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Compound Implication"
msgstr ""

#. §0: `«{A}»`
#. §1: `«{C}»`
#. §2: `intro x`
#. §3: `«{A}»`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "To define a function from §0 to §1, type §2 to introduce an\n"
"arbitrary element of type §3."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `comp : (B → C) → (A → B) → (A → C)`
#. §4: `f : A → B`
#. §5: `g : B → C`
#. §6: `comp g f : A → C`
#. §7: `a : A`
#. §8: `g (f a) : C`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "For types §0, §1, and §2, the function §3 takes a function §4 and a function §5 to the composite function §6 defined to take §7 to the element §8."
msgstr ""

#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Move on to Disjunction World to learn about another logical operation."
msgstr ""

#. §0: `«{nnnp}»`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What can you do with hypothesis §0?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "Introducing Or"
msgstr ""

#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Identity Function"
msgstr ""

#. §0: `intro`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
#: Game.Levels.ImplicationWorld.L07_OnParentheses
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "As the goal is to prove an implication, the tactic §0 can be used to introduce a hypothesis and update the goal. Before using this tactic, try to figure out which hypothesis will be assumed and what the goal will be, using the discussion about the implicit parenthesization above."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does this goal seem familiar? If not, it's okay to just follow your nose and let the logical structure guide you."
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "The lesson of this level is to pay attention to the big picture, namely what exactly you are being asked ot prove under what hypotheses."
msgstr ""

#. §0: `«{h}» : «{P}» ∨ «{Q}»`
#. §1: `cases h`
#. §2: `P`
#. §3: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "After introducing the hypothesis §0, type §1 to ask Lean to consider both cases: the first being that §2 is true and the second being that §3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way."
msgstr ""

#. §0: `S`
#. §1: `s : S`
#. §2: `exact s`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "If the goal is to prove §0 and we have a hypothesis §1, the tactic §2 supplies the required proof."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "§0 implies §1."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Triple Negation"
msgstr ""

#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "Constant functions"
msgstr ""

#. §0: `¬ P`
#. §1: `P`
#. §2: `P → False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "§0, read as &ldquo; not §1&rdquo; is an abbreviation for §2."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A ⊕ B) ⊕ C`
#. §4: `A ⊕ (B ⊕ C)`
#. §5: `A ⊕ B ⊕ C`
#. §6: `a : A`
#. §7: `b : B`
#. §8: `c : C`
#. §9: `b : B`
#. §10: `Sum.inl (Sum.inr b) : (A ⊕ B) ⊕ C`
#. §11: `Sum.inr (Sum.inl b) : A ⊕ (B ⊕ C)`
#. §12: `((A ⊕ B) ⊕ C) → (A ⊕ (B ⊕ C))`
#. §13: `(A ⊕ (B ⊕ C)) → ((A ⊕ B) ⊕ C)`
#. §14: `(((A ⊕ B) ⊕ C) → (A ⊕ (B ⊕ C))) × ((A ⊕ (B ⊕ C)) → ((A ⊕ B) ⊕ C))`
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Given three types §0, §1, and §2, the coproduct type construction may be iterated to define types §3 and §4, the latter of which is abbreviated §5.\n"
"\n"
"For both of these types, there are three cases of elements: those coming from §6, those coming from §7, and those coming from §8. The notation for the corresponding elements of the iterated coproduct type depends on the parentheses: the terms §9 include as §10 but include as §11.\n"
"\n"
"The objective in this level is to define a pair of functions between these types in each direction, the first of type §12 and the second of type §13. That is, define a single element of type\n"
"\n"
"§14"
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Using And"
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Move on to Coproduct World to learn about the type theoretic analog of the logical operation of disjunction."
msgstr ""

#. §0: `«{A}»`
#. §1: `«{x}» : «{A}»`
#. §2: `«{x}» : «{A}»`
#. §3: `exact «{x}»`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Now the goal is an element of type §0, which should be thought of as result of applying the function to the element §1. In the case of the identity function, we want to return §2 again which is done by typing §3."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Coproduct With Empty"
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Projected Pairs"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ProductWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Symmetry"
msgstr ""

#. §0: `apply Or.inl`
#. §1: `apply Or.inr`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "You have two choices: to reduce to the case of proving the left proposition or to reduce to the case of proving the right proposition. Type §0 to tell Lean you'd like too prove the left proposition or type §1 to tell Lean you'd like to prove the right proposition."
msgstr ""

#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Negating Conjunction"
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P`
#. §2: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "To prove a conjunction §0 we need to supply a proof of both §1 and §2."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "We've now reached the Boss Level in the disjunction world.\n"
"\n"
"This level illustrates that proofs by cases can be somewhat delicate."
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "The converse implication is more subtle, and will be addressed in the next world."
msgstr ""

#. §0: `ℕ`
#. §1: `ℤ`
#. §2: `ℚ`
#. §3: `ℝ`
#. §4: `ℂ`
#. §5: `A`
#. §6: `B`
#. §7: `P`
#. §8: `Q`
#. §9: `A`
#. §10: `x : A`
#. §11: `y : A`
#. §12: `P`
#. §13: `Q`
#. §14: `p : P`
#. §15: `q : Q`
#. §16: `P`
#. §17: `ℕ`
#. §18: `0 : ℕ`
#. §19: `1 : ℕ`
#. §20: `→`
#. §21: `∧`
#. §22: `A → B`
#. §23: `A`
#. §24: `B`
#. §25: `f : A → B`
#. §26: `A`
#. §27: `B`
#. §28: `A → B`
#. §29: `P → Q`
#. §30: `A → B`
#. §31: `A → B`
#: Game.Levels.FunctionWorld
msgid "The slogan *propositions as types* tells us that we can consider propositions as special cases of *types*.\n"
"\n"
"For example, there are types §0 of\n"
"natural numbers, §1 of integers, §2 of rational numbers, §3 of real numbers, §4 of natural\n"
"numbers, and so on.\n"
"\n"
"We use capital variables like §5 and §6 to denote general types, analogously to the proposition variables §7 and §8.\n"
"\n"
"A type §9 can contain elements §10 and §11. For propositions §12 and §13, we thought of\n"
"elements §14 and §15 as *proofs* that these propositions are true.\n"
"\n"
"In the case of\n"
"propositions, what mattered was whether §16 had any elements or not. The elements themselves don't\n"
"carry any information beyond witnessing the truth of the proposition.\n"
"\n"
"By contrast, the type §17 of\n"
"natural numbers contains infinitely many distinct elements: §18, §19 and so on.\n"
"\n"
"Just as logical connectives like §20 and §21 can be used to build more complicated propositions out of existing propositions, *type forming operations* can be used to build new types from existing types.\n"
"\n"
"The first and arguably most important of these is the type §22 of functions from §23 to §24. An element\n"
"§25 defines a *function* from §26 to §27.\n"
"\n"
"In this level, we will explain how to define and use functions and explore the analogy suggested by the fact that we use the same notation for\n"
"function types §28 as for the implication proposition §29.\n"
"\n"
"To understand how functions work in type theory we must learn:\n"
"\n"
"* How to construct elements of type §30.\n"
"* How to use elements of type §31 to construct elements of other types."
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Now the goal is an element of a product type. How can such elements be defined?"
msgstr ""

#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Let us see what else can be proven with function extensionality."
msgstr ""

#. §0: `x : A × (B ⊕ C)`
#. §1: `x`
#. §2: `x`
#. §3: `⟨y, z⟩`
#. §4: `y : A`
#. §5: `z : B ⊕ C`
#. §6: `z`
#. §7: `Sum.inl b`
#. §8: `b : B`
#. §9: `Sum.inr c`
#. §10: `c : C`
#. §11: `x : A × (B ⊕ C)`
#. §12: `⟨y, Sum.inl b⟩`
#. §13: `⟨y, b⟩ : A × B`
#. §14: `x`
#. §15: `⟨y, Sum.inr c⟩`
#. §16: `⟨y, c⟩ : A × C`
#. §17: `A × (B ⊕ C) → (A × B) ⊕ (A × C)`
#. §18: `(A × B) ⊕ (A × C) → A × (B ⊕ C)`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "How should we think about an element of type §0?.\n"
"\n"
"Since §1 belongs to a product type, it can be split into two components. That is §2 has the form of a pair §3 with §4 and §5. And since §6 belongs to a coproduct type, there are two possible cases: it can have the form §7 for some §8 or it can have the form §9 for some §10. In the first case, the original §11 is a pair of the form §12 coming from §13 which in the second case §14 is a pair of the form §15 coming from §16.\n"
"\n"
"This explains the *distributivity* of products over coproducts, which can be encoded by a pair of functions, one of the form §17 and the other of the form §18."
msgstr ""

#. §0: `S → T`
#. §1: `T`
#. §2: `S`
#. §3: `S`
#. §4: `P`
#. §5: `Q`
#. §6: `P`
#. §7: `Q → P`
#. §8: `Q`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "To prove an implication §0 one needs to give a construction of a proof of §1 from a proof of §2. As we will see in the following example, it is not necessary to actually *use* the assumption that §3 is true after introducing it.\n"
"\n"
"In this level we will consider two propositions §4 and §5 and assume that the proposition §6 is true.\n"
"\n"
"It follows that §7 is true, no matter whether §8 is true or false."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "Now you can start to apply some hypotheses to reduce the goal to one of your assumptions. Which tactic can be used here?"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `Q → P`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "If §0 is true, then for any proposition §1, §2 is always true."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P`
#. §2: `Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "The converse implication is more subtle because if §0 is false we don't know which of §1 or §2 is false. This will be addressed in the next world."
msgstr ""

#. §0: `«{h}» : P → Q ∧ R`
#. §1: `«{p}»: P`
#. §2: `«{h}» «{p}» : Q ∧ R`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "We can apply the proof §0 to the proof §1 to obtain §2. How can these be used to prove the goal?"
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Have another look at the Universal Property Level of Disjunction World. How are these statements related?"
msgstr ""

#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The objective of this Boss Level is to define a function that takes five variables as inputs and has three\n"
"variables as outputs.\n"
"\n"
"This function is defined as a composite &mdash; in a much more complicated sense than we have seen thusfar &mdash; of the given functions.\n"
"\n"
"Can you do it?"
msgstr ""

#. §0: `a : A`
#. §1: `B`
#. §2: `B → A`
#. §3: `a : A`
#. §4: `x : B`
#. §5: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "Given a term §0 and any type §1, there is a function of type §2 which is *constant* at §3.\n"
"\n"
"This means that for any input §4 the output is always the element §5.\n"
"\n"
"Can you figure out how to define this function?"
msgstr ""

#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "By Assumption"
msgstr ""

#: Game
msgid "Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving"
msgstr ""

#. §0: `cases «{hpqr}»`
#. §1: `rcases «{hpqr}» with hpq | hr`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "You can use §0 to split your hypothesis into cases or §1 to name your own variables."
msgstr ""

#. §0: `unfold swap`
#. §1: `unfold Function.swap`
#. §2: `(swap f) b a`
#. §3: `swap`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Type §0 or §1 to ask Lean to reduce §2 using the definition of §3 we provided in Function World."
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `P`
#. §3: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "For any proposition §0, if §1 and §2 are both true, then we obtain a proof of §3."
msgstr ""

#. §0: `Or.inl`
#. §1: `Or.inr`
#. §2: `S ∨ T`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Recall §0 and §1 refer to the left and right propositions in a disjunction §2."
msgstr ""

#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "Move on to Product World to meet a second type forming operation."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#. §3: `x : A`
#. §4: `g (f x)`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions §0 and §1, the *composite function* §2 is defined to send §3 to the element §4."
msgstr ""

#. §0: `exact`
#. §1: `apply`
#. §2: `intro`
#. §3: `intro`
#. §4: `exact`
#. §5: `apply`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "This level can be solved by starting with §0, starting with §1, or starting with §2. If you start with §3, then you can continue with §4 or with §5. If this is your first time solving this level, try to find a different solution."
msgstr ""

#. §0: `g : A → C`
#. §1: `h : B → C`
#. §2: `A ⊕ B → C`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Two functions §0 and §1 combine to define a single function of type §2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Double Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "What tactics can be used to break a goal involving conjunction into subgoals?"
msgstr ""

#. §0: `P`
#. §1: `P ∨ ¬ P → (¬ ¬ P → P)`
#. §2: `¬ ¬ P → P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `P`
#. §6: `exact em P`
#. §7: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "In Negation World, we proved that for any proposition §0: §1\n"
"\n"
"In other words, we showed that the law of excluded middle implies double negation elimination.\n"
"\n"
"We now show that converse: that double negation elimination implies the law of excluded middle. More\n"
"precisely, if we assume that §2 for all propositions §3, then we can show that §4 for\n"
"all proposition §5.\n"
"\n"
"While the proof will feel like an application of classical logic, using the strategy of proof by contradiction, in\n"
"fact the proof can be understood as a proof in constructive mathematics.\n"
"\n"
"This is because we are arguing under the assumption that double negation elimination holds, which means\n"
"we are working in a setting where the strategy of proof by contradiction applies.\n"
"\n"
"You can solve this level immediately with §6 but try starting with §7 instead and see if you can argue without appealing to the law of excluded middle."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P → Q) → R`
#. §4: `P → (Q → R)`
#. §5: `R`
#. §6: `P → Q`
#. §7: `Q → R`
#. §8: `P`
#. §9: `R`
#. §10: `P`
#. §11: `Q`
#. §12: `P → (Q → R)`
#. §13: `P → Q → R`
#. §14: `P → (Q → R)`
#. §15: `P → Q → R → S → T`
#. §16: `P → (Q → (R → (S → T)))`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "For propositions §0, §1, and §2, the propositions §3 and §4 are not the same.\n"
"\n"
"The first asserts that §5 is true assuming §6. The second asserts that §7 is true assuming §8, or equivalently, that §9 is true assuming §10 and also assuming §11.\n"
"\n"
"Mathematical statements of this second form §12 are much more common. Thus the shorthand §13 implicitly refers to §14, not to the other parenthesization.\n"
"\n"
"More generally, §15 refers to §16.\n"
"\n"
"Explicit parentheses must be used to express statements with any other parenthesizations."
msgstr ""

#. §0: `intro`
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a function type, so start with §0."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "For the boss level, your task is to:\n"
"\n"
"* break apart a function from a coproduct type into a product type into four separate component functions and\n"
"\n"
"* then reassemble four component functions to a single function from a coproduct type into a product type.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `Q`
#. §5: `P`
#. §6: `P`
#. §7: `Q`
#. §8: `(P → Q) ∧ (Q → P)`
#. §9: `P ↔ Q`
#. §10: `(P → Q) ∧ (Q → P)`
#. §11: `↔`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Two propositions §0 and §1 are *logically equivalent* if §2 implies §3 and §4 also implies §5.\n"
"\n"
"The assertion that §6 and §7 are logically equivalent can be expressed by the compound proposition §8.\n"
"\n"
"Because this notion will appear frequently in what follows, we introduce §9 as a useful shorthand for §10.\n"
"\n"
"See the library of definitions to the right for a reminder about what the symbol §11 means.\n"
"\n"
"The notion of logical equivalence enables us to upgrade our understanding of associativity of symmetry as follows."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#. §0: `P → Q → R → S → T`
#. §1: `intro p q r s`
#. §2: `p : P`
#. §3: `q : Q`
#. §4: `r : R`
#. §5: `s : S`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "For compound implications &mdash; statements of the form §0 &mdash; you can type §1 to introduce hypothesis §2, §3, §4, and §5 all at once."
msgstr ""

#. §0: `P → ¬ ¬ P`
#. §1: `(P → Q) → (¬ Q → ¬ P)`
#. §2: `¬ P ∨ ¬ Q → ¬ (P ∧ Q)`
#. §3: `(P ∧ ¬ Q) → ¬ (P → Q)`
#. §4: `P ∨ Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P`
#. §8: `P ∨ ¬ P`
#. §9: `P ∨ ¬ P`
#. §10: `P`
#. §11: `P`
#. §12: `P`
#. §13: `¬ ¬ P → P`
#. §14: `P`
#. §15: `¬ ¬ P → P`
#. §16: `P`
#. §17: `¬ P`
#. §18: `¬ P`
#. §19: `¬ ¬ P`
#. §20: `¬ ¬ P → P`
#. §21: `¬ ¬ P`
#. §22: `P`
#: Game.Levels.ClassicalWorld
msgid "In Negation World, we proved various tautologies involving negation such as\n"
"\n"
"* §0\n"
"* §1\n"
"* §2\n"
"* §3\n"
"\n"
"But we were not able to prove the converses of any of these implications. Why not?\n"
"\n"
"The reason is that all of the proofs we have given thusfar involve explicit constructive arguments. For example, whenever we proved that a disjunction §4 held under certain hypotheses, our proof gave the information of *which* of the propositions §5 and §6 is true.\n"
"\n"
"In this world, we study *classical mathematics*, which assumes two additional axioms, each of which permits new proof techniques.\n"
"\n"
"The first axiom, called the *law of excluded middle*, asserts that for any proposition §7, §8 is true.\n"
"\n"
"This permits the strategy of proof by cases. Under the assumption that §9 is true, you can split the argument into two cases, one assuming §10 is true and the other assuming §11 is false.\n"
"\n"
"The other axiom, called *double negation elimination*, asserts that for any proposition §12, §13 is true.\n"
"\n"
"This permits a proof strategy called *proof by contradiction*. If the goal is to prove §14 we can use the assumption §15 to reason as follows:\n"
"\n"
"* First assume that §16 is false, so §17 is true.\n"
"* Then use the assumption §18 to derive a contradiction, thus constructing a proof of §19.\n"
"* Finally, apply the implication §20 to convert the proof of §21 into a proof of §22.\n"
"\n"
"In fact, the law of exluded middle and double negation elimination are equivalent &mdash; even constructively &mdash; as we will show in the Boss Level of this world."
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `f`
#. §3: `a`
#. §4: `f a : B`
#. §5: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Given a function §0 and any element §1. You can apply the function §2 to §3 to obtain an element §4 of type §5."
msgstr ""

#. §0: `fun x ↦ a`
#. §1: `x : B`
#. §2: `a : A`
#. §3: `fun _ ↦ a`
#. §4: `exact fun _ ↦ a`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "The formula for the constant function is §0. In other words, given any input §1, the output is always the specified term §2. Since the formula for the output does not depend on the input term, this can also be written as §3, so try solving this level with §4"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Modus Ponens"
msgstr ""

#. §0: `have pq : P ∨ Q := «{h}».1`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Try §0."
msgstr ""

#. §0: `V`
#. §1: `F`
#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "For the function Boss Level, we consider an arbitrary pair of types, which we call §0 and §1 &mdash; for *vector space* and *field* respectively &mdash; because the function to be defined below has a connection to linear algebra that is not explained here.\n"
"\n"
"Can you define it?"
msgstr ""

#. §0: `«{P}»`
#. §1: `«{p}» : «{P}»`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "Now the goal is to prove §0 assuming §1. Which tactic can be used to supply this proof?"
msgstr ""

#. §0: `Prod.fst : A × B → A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions."
msgstr ""

#. §0: `p : A × B`
#. §1: `p.1 : A`
#. §2: `p.2 : B`
#. §3: `⟨p.1, p.2⟩ : A × B`
#. §4: `p`
#. §5: `⟨p.1, p.2⟩`
#. §6: `A × B`
#. §7: `p = ⟨p.1, p.2⟩`
#. §8: `x = y`
#. §9: `x`
#. §10: `y`
#. §11: `p = ⟨p.1, p.2⟩`
#. §12: `rfl : p = ⟨p.1, p.2⟩`
#. §13: `p.fst`
#. §14: `p.snd`
#. §15: `p.1`
#. §16: `p.2`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Consider an element in a product type §0. Using the projections, we obtain terms\n"
"§1 and §2. These can then be paired back to form an element §3 in the product type.\n"
"\n"
"What is the relationship between §4 and §5?\n"
"\n"
"Firstly, both of these are elements of the same type, namely §6. Thus, there is a mathematically meaningful proposition\n"
"§7 because in general it makes mathematical sense to ask whether §8 whenever §9 and §10 are both terms belonging to the same type.\n"
"\n"
"In this case one of the *computation rules* for product types tells us that the proposition\n"
" §11 is true, essentially by definition of the projection and pairing functions associated to products. Thus the proof is again by reflexivity and we have §12.\n"
"\n"
"Note Lean uses §13 and §14 as synomyms for §15 and §16 respectively."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "We are now ready for the Boss Level of Disjunction World."
msgstr ""

#. §0: `A`
#. §1: `id : A → A`
#. §2: `a : A`
#. §3: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type §0, §1 is the function defined by sending §2 to §3."
msgstr ""

#. §0: `A × B → B × A`
#. §1: `p : A × B`
#. §2: `p.1 : A`
#. §3: `p.2 : B`
#. §4: `B × A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The product type comes with function of type §0 which swaps the elements of an ordered pair.\n"
"\n"
"The swap function can be defined by introducing a variable §1, projecting to its components §2 and §3, then reassembling these to give an element of type §4."
msgstr ""

#. §0: `have p : P := «{pnq}».1`
#. §1: `P`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try §0 to add a proof of §1 to your assumptions."
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `A × B`
#. §3: `⟨a , b⟩ : A × B`
#. §4: `a : A`
#. §5: `b : B`
#. §6: `exact ⟨a,b⟩' using '\\<' and '\\>' to type the angle brackets; note the spacing around the angle brackets and the commas is not important.
#. 
#. Alternatively, you can apply the `
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Given an element §0 and an element §1 there is a corresponding element of the product type §2 that is denoted by §3.\n"
"\n"
"This element should be thought of as an *ordered pair* whose first component is the element §4 and whose second element is the element §5.\n"
"\n"
"This can be input directly by typing §6constructor` tactic which allows you to first input the first component and then input the second component."
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a product type, so §0 can be used to break the goal into pieces."
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P`
#. §2: `P → ¬ ¬ P`
#. §3: `P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The *double negation* of a proposition §0 is the proposition §1.\n"
"\n"
"In this level, we reinterpret the construction of the previous level, as a proof that §2 is always true, no matter whether or not §3 is true."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `And.curry`
#. §4: `P ∧ Q → R`
#. §5: `P → Q → R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "For propositions §0, §1, and §2, §3 is a proof that §4 implies §5."
msgstr ""

#. §0: `cases «{p}»`
#. §1: `rcases «{p}» with x | c`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Now use §0 or §1 or similar to give your own variable names."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `Function.uncurry : (A → B → C) → (A × B → C)`
#. §4: `f : A → B → C`
#. §5: `p : A × B`
#. §6: `f p.1 p.2 : C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "For any types §0, §1, and §2, §3 is the function that sends §4 to the function that sends §5 to §6."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "More Distributivity"
msgstr ""

#. §0: `Function World`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "Next move on to §0 to learn about types and functions."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "If §0 is true, then if §1 is true, then §2 is true."
msgstr ""

#. §0: `((((V → F) → F) → F) → F)`
#. §1: `(V → F) → F`
#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "Given a function of type §0 there is a canonically defined function of type §1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
msgid "Are function types associative? Why or why not?"
msgstr ""

#. §0: `Classical.byContradiction : ¬ ¬ P → P`
#. §1: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Lean has a built-in name §0 for this implication, which is also called *double negation elimination*. In the source files for Classical World, we have told that we want to use classical reasoning, which is why typing §1 suffices to solve this level."
msgstr ""

#. §0: `have`
#. §1: `p : P`
#. §2: `h : P → Q`
#. §3: `have q : Q := h p`
#. §4: `q : Q`
#. §5: `h p`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "The §0 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions §1 and §2, type §3 to add a proof §4 defined by §5."
msgstr ""

#. §0: `constructor`
#. §1: `intro s`
#. §2: `exact t`
#. §3: `fun s ↦ t`
#. §4: `\\mapsto`
#. §5: `↦`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Can you solve this level with only one use of the §0 tactic? In fact, even this can be avoided using syntax we have not yet introduced: a two line proof §1 followed by §2 can be written §3 writing §4 to type §5."
msgstr ""

#. §0: `«{A}» → «{A}»`
#. §1: `x : «{A}»`
#. §2: `«{A}»`
#. §3: `intro x`
#. §4: `«{A}»`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "To define a function, in this case a term of type §0, one must define a rule to convert an arbitrary element §1 to some element of type §2. Start by typing §3 to add an arbitrary element of type §4 to the context."
msgstr ""

#: Game.Levels.ImplicationWorld
msgid "Implication World"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "How do you construct elements of a function type?"
msgstr ""

#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "What can you do with these assumptions?"
msgstr ""

#. §0: `Classical.em P : P ∨ ¬ P`
#. §1: `em _`
#. §2: `_`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "The classical tautology §0 has been added to your library of theorems and can be used by calling §1, with the desired proposition replacing the §2, whenever classical reasoning is open."
msgstr ""

#. §0: `False`
#. §1: `p : P`
#. §2: `P`
#. §3: `False`
#. §4: `P`
#. §5: `P → False`
#. §6: `P`
#. §7: `¬ P`
#. §8: `¬ P`
#. §9: `P`
#. §10: `p : P`
#. §11: `False`
#. §12: `False`
#: Game.Levels.NegationWorld
msgid "In this world, we will study the proposition §0 and the logical operation of *negation*.\n"
"\n"
"Recall that an element §1 of a proposition §2 may be thought of as a proof that the proposition is true. The proposition §3 is not true so it does not contain any elements.\n"
"\n"
"For any proposition §4, we define its *negation* to be the proposition §5, pronounced &ldquo;§6 implies false&rdquo;. This is commonly abbreviated with the shorthand §7, pronounced &ldquo;not P&rdquo;.\n"
"\n"
"A *proof of negation* means a proof of a proposition of the form §8 for some proposition §9.\n"
"\n"
"Using the introduction rule for implications, such a proof starts by assuming §10 and then deriving an element of §11.\n"
"\n"
"Since §12 has no elements, we think of this process as deriving a contradiction."
msgstr ""

#. §0: `intro`
#. §1: `P → Q`
#. §2: `intro p`
#. §3: `p : P`
#. §4: `Q`
#. §5: `P → Q → R`
#. §6: `intro p q`
#. §7: `p : P`
#. §8: `q : Q`
#. §9: `R`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "The §0 tactic, short for *introduction*, is used to introduce one or more hypotheses when the goal is an implication. It can be used itself or followed by names for those hypotheses. For example, when the goal is §1, type §2 to add an assumption §3 and update the goal to §4. When the goal is §5, type §6 to add assumptions §7 and §8 and update the goal to §9."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "There are various ways to solve this level. You might enjoy searching for a shorter proof."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `Function.curry : (A × B → C) → (A → B → C)`
#. §4: `f : A × B → C`
#. §5: `a : A`
#. §6: `b : B`
#. §7: `f ⟨a, b⟩ : C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "For any types §0, §1, and §2, §3 is the function that sends §4 to the function that sends §5 and §6 to §7."
msgstr ""

#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "This logical equivalence captures the *universal property* of disjunction, explaining how the mathematical or is used in a proof."
msgstr ""

#. §0: `f : A → B → C`
#. §1: `A`
#. §2: `B`
#. §3: `swap f : B → A → C`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Note that for a particular multvariable function §0, its type dictates that the variable of type §1 must be supplied before the variable of type §2. But as observed in this level, we can then define a corresponding function §3 which encodes the same information."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `(A → B) → (B → Empty) → (A → Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types §0 and §1, there is a function §2 defined by composition."
msgstr ""

#. §0: `«{p}»`
#. §1: `«{nq}»`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What can you prove with §0 and §1?"
msgstr ""

#. §0: `S ↔ T`
#. §1: `(S → T) ∧ (T → S)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Recall that §0 is an abbreviation for §1. What is the outermost connective here? Which tactic can be used to break this into subgoals?"
msgstr ""

#. §0: `A → B → C`
#. §1: `f : A → B → C`
#. §2: `a : A`
#. §3: `b : B`
#. §4: `f a b : C`
#. §5: `f`
#. §6: `a`
#. §7: `b`
#. §8: `A → B → C`
#. §9: `B → A → C`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Recall that an element of type §0 can be thought of as a function of two variables.\n"
"\n"
"Given §1, §2, and §3, §4 denotes §5 applied first to §6 and then to §7.\n"
"\n"
"From a function of type §8, we can define a function of type §9 by swapping the order of the variables that are input into the function."
msgstr ""

#. §0: `P ∨ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "There are two ways to prove §0 from the given hypotheses. Can you find them both?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Can we apply our hypothesis yet or must we act on the goal first?"
msgstr ""

#. §0: `P ∧ Q → R`
#. §1: `P → Q → R`
#. §2: `(P → Q → R)`
#. §3: `P ∧ Q → R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "In the previous level we proved that §0 implies §1.\n"
"\n"
"We now show that §2 implies §3."
msgstr ""

#. §0: `f : A → B → C`
#. §1: `swap f : B → A → C`
#. §2: `b : B`
#. §3: `a : A`
#. §4: `(swap f) b a : C`
#. §5: `f a b : C`
#. §6: `(swap f) b a = f a b`
#. §7: `swap`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Consider a function §0. We've defined a corresponding function §1 by exchanging the order of the inputs. That is for any §2 and §3 the terms §4 and §5 are equal by definition.\n"
"\n"
"Thus, reflexivity again proves that §6. But for Lean to understand, this we must first tell Lean to unfold our definition of §7."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∨ Q`
#. §3: `Q ∨ P`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "We can improve our understanding of the symmetry of disjunction as follows.\n"
"\n"
"For propositions §0 and §1, §2 is true if and only if §3 is true."
msgstr ""

#. §0: `A`
#. §1: `f : A → Empty`
#. §2: `a : A`
#. §3: `Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "For any type §0, if there is a function §1 and there is an element §2, then there is an element of the §3 type."
msgstr ""

#. §0: `A`
#. §1: `A → Empty`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Again, something very strange happens if the types §0 and §1 both have elements."
msgstr ""

#. §0: `cases «{x}»`
#. §1: `«{x}»`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall you can type §0 to ask Lean to consider which cases are actually possible for the hypothetical element §1."
msgstr ""

#. §0: `A ⊕ B → C × D`
#. §1: `(A → C) × (B → C) × (A → D) × (B → D)`
#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "A function of type §0 can be broken into component functions of type §1 and conversely the component functions assemble into a function from the coproduct type to the product type."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "The empty type is a weird type, so what was the point of this world? The hope is that your experience defining functions involving the empty type will prepare you to think about what it means to prove that a proposition is false in Negation World. Go there next."
msgstr ""

#. §0: `¬ (P ∧ Q)`
#. §1: `P ∧ Q`
#. §2: `P ∧ Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∧ Q`
#. §8: `¬ P ∨ ¬ Q`
#. §9: `¬ (P ∧ Q)`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"On the one hand, it suffices for just §3 to be false.\n"
"\n"
"On the other hand, it suffices for just §4 to be false.\n"
"\n"
"That is, if either §5 or §6 is false, then §7 is false.\n"
"\n"
"In this level, we will prove that §8 implies §9."
msgstr ""

#. §0: `h : P → Q`
#. §1: `p : P`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "We've seen that an implication §0 can be applied in the presense of a proof §1 to provide a proof of the proposition §2. This explains how implications are *used* in proofs of other statements. In the next level, we will see how implications can be *proven*."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `Or.inl`
#. §3: `P → (P ∨ Q)`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "For propositions §0 and §1, §2 is a proof that §3."
msgstr ""

#. §0: `(P → Q → R) → (P ∧ Q → R)`
#. §1: `P ∧ Q → R`
#. §2: `P → Q → R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "This proves that §0. We can now conclude that §1 and §2 are logically equivalent."
msgstr ""

#. §0: `P`
#. §1: `False → P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition §0, the implication §1 is true."
msgstr ""

#. §0: `rfl`
#. §1: `x = y`
#. §2: `x`
#. §3: `y`
#: Game.Levels.EqualityWorld.L02_PairedProjections
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "In summary, §0 can also be used to prove propositions of the form §1 when §2 and §3 are equal *by definition* (rather than by a more complicated chain of reasoning)."
msgstr ""

#: Game.Levels.ProductWorld
msgid "Product World"
msgstr ""

#. §0: `exact fun g f a ↦ ?`
#. §1: `?`
#. §2: `exact fun g f ↦ ?`
#. §3: `?`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Can you solve this level in one line by using §0 with the appropriate thing in place of the §1?\n"
"\n"
"Can you solve this level in one line by using §2 with the appropriate thing in place of the §3?"
msgstr ""

#. §0: `intro`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use the §0 tactic to define a term in a function type."
msgstr ""

#. §0: `cases «{p}»`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Type §0 to ask Lean to consider all possible cases involving an element of the empty type. As there are no cases, this will complete the proof."
msgstr ""

#. §0: `have`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "For the Boss Level of Conjunction World, the task is to prove a complicated implication.\n"
"\n"
"After introducing all of the allowed hypotheses, you may find it helpful to prove that some intermediate propositions are true using the §0 tactic.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `P → Q`
#. §1: `P → Q`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "If §0 is true, then §1 is true."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Define the currying function, convering a function out of a product type into a function of two variables."
msgstr ""

#. §0: `«{Q}» → «{P}»`
#. §1: `intro q`
#. §2: `q : «{Q}»`
#. §3: `«{P}»`
#. §4: `intro`
#. §5: `«{Q}»`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "To prove an implication, which in this case has the form §0, type §1 to introduce an assumption §2 and update the goal to §3.\n"
"\n"
"It is also possible to type simply §4 in which case Lean will automatically generate a name for the proof of §5."
msgstr ""

#. §0: `«{c}».2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "What is the logical structure of the type that §0 belongs to?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B → B ⊕ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For any types §0 and §1, there is a canonical function of type §2."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `P ∧ Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "For any propositions §0 and §1, if §2 is false or §3 is false then §4 is false."
msgstr ""

#. §0: `«{pnq}»`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What else can we prove with the hypothesis §0?"
msgstr ""

#. §0: `P ∧ ¬ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "In the next level, we will see that a contradiction of the form §0 can be used to prove any proposition."
msgstr ""

#. §0: `«{f}»`
#. §1: `«{p}»`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "What sort of inputs does the function §0 require and how can these be extracted from §1?"
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#. §2: `P → Q`
#. §3: `¬ Q → ¬ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "In this level we will study the relationship between an implication §0 and its *contrapositive*, which is the statement §1.\n"
"\n"
"The objective in this level is to prove that §2 implies §3.\n"
"\n"
"In fact, the construction of this proof should feel very familiar!\n"
"\n"
"The other direction of implication is considerably more subtle and will be discussed in the next world."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Distributivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What is the logical structure of this type?"
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "This might be a useful time to apply one of the theorems proven earlier in Negation World."
msgstr ""

#. §0: `constructor`
#. §1: `«{P}»`
#. §2: `«{Q}»`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Use the tactic §0 to ask Lean to break up the goal into steps, of first proving §1 and then proving §2."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A ⊕ B) ⊕ C`
#. §4: `A ⊕ (B ⊕ C)`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "For types §0, §1, and §2, there are canonical functions between the types §3 and §4."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A × B) × C`
#. §4: `A × (B × C)`
#. §5: `A × B × C`
#. §6: `p : (A × B) × C`
#. §7: `p.1 : A × B`
#. §8: `p.2 : C`
#. §9: `p.1 : A × B`
#. §10: `p.1.1 : A`
#. §11: `p.1.2 : B`
#. §12: `((A × B) × C) → (A × (B × C))`
#. §13: `(A × (B × C)) → ((A × B) × C)`
#. §14: `(((A × B) × C) → (A × (B × C))) × ((A × (B × C)) → ((A × B) × C))`
#. §15: `A × B × C`
#. §16: `(A × B) × C`
#. §17: `a : A`
#. §18: `b : B`
#. §19: `c : C`
#. §20: `⟨a,b,c⟩ : A × B × C`
#. §21: `⟨a, ⟨b,c⟩⟩ : A × (B × C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Given three types §0, §1, and §2, the product type construction may be iterated to define types §3 and §4, the latter of which is abbreviated §5.\n"
"\n"
"A term §6 has projections §7 and §8. Then §9 has further projections §10 and §11.\n"
"\n"
"Use this to define a *pair* of functions, the first of type §12 and the second of type §13. That is, define a single element of type\n"
"\n"
"§14\n"
"\n"
"Note some shorthands are available for §15 but not for §16.\n"
"\n"
"Given §17, §18, and §19, we may write §20 to abbreviate §21."
msgstr ""

#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "More Compound Implication"
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The goal is an implication. What tactic can be used to start a proof?"
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Combined with what we know already, we have established a logical equivalence between the implications §0 and §1 in classical logic."
msgstr ""

#. §0: `B`
#. §1: `Empty.elim : Empty → B`
#. §2: `Empty`
#. §3: `B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Recall that for any type §0, there is a function §1. Using this and your element of §2 can you define an element of type §3?"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What is the logical structure of the goal?"
msgstr ""

#: Game.Levels.ImplicationWorld.L09_BossLevel
#: Game.Levels.ConjunctionWorld.L10_BossLevel
#: Game.Levels.FunctionWorld.L09_BossLevel
#: Game.Levels.ProductWorld.L10_BossLevel
#: Game.Levels.EmptyWorld.L07_BossLevel
#: Game.Levels.NegationWorld.L11_BossLevel
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "Boss Level"
msgstr ""

#. §0: `x`
#. §1: `cases x`
#. §2: `x`
#. §3: `cases`
#. §4: `h : P ∨ Q`
#. §5: `cases h`
#. §6: `P`
#. §7: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Assuming §0 is a variable in the local context with an inductive type, §1 splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on §2, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well. §3 detects unreachable cases and closes them automatically.\n"
"\n"
"For example, given an assumption §4, §5 splits the main goal into two goals, one assuming §6 holds and the other assuming §7 holds."
msgstr ""

#. §0: `constructor`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "The §0 tactic can be used when the goal is a conjunction (among other settings) to split the goal into cases."
msgstr ""

#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Unfolding definitions"
msgstr ""

#. §0: `h`
#. §1: `P`
#. §2: `Q`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Since §0 is a compound implication, we have multiple hypothesis to satisfy. We must prove that §1 is true and also prove that §2 is true. Fortunately, our assumptions cover both cases."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `¬ (P → Q)`
#. §3: `P ∧ ¬ Q`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In classical logic, for any propositions §0 and §1, §2 implies §3."
msgstr ""

#. §0: `P`
#. §1: `¬ (P ∧ ¬ P)`
#. §2: `P`
#. §3: `¬ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition §0, the following is true:\n"
"\n"
"§1\n"
"\n"
"This is sometimes called the *law of noncontradiction*.\n"
"\n"
"It asserts that it is not the case that both §2 and §3 are true.\n"
"\n"
"Do you see how this relates to the previous levels?"
msgstr ""

#. §0: `«{nor}»`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What can you do with the hypothesis §0?"
msgstr ""

#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "Right Inclusion"
msgstr ""

#. §0: `False.elim : Empty → P`
#. §1: `exact False.elim`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Lean has a built-in name §0 for the theorem you have just proven. Thus §1 will also solve this level. This theorem has been added to the library."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P → Q`
#. §3: `¬ Q → ¬ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "For any propositions §0 and §1, if §2 holds then §3 also holds."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P ∧ Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If §0 is true then §1 is true."
msgstr ""

#. §0: `A`
#. §1: `id : A → A`
#. §2: `a : A`
#. §3: `f : A → B`
#. §4: `x : A`
#. §5: `B`
#. §6: `intro x`
#. §7: `x : A`
#. §8: `B`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The simplest example of a function is the identity function, which may be defined for any type §0. The identity function\n"
"§1 is defined to carry any element §2 to itself.\n"
"\n"
"To define a function §3 one must define a rule that converts an arbitrary element §4 to some element of type §5. Start by typing §6 to add an arbitrary element §7 to the context and update the goal to a term of type §8."
msgstr ""

#. §0: `A × B → A`
#. §1: `A × B → B`
#. §2: `p : A × B`
#. §3: `A`
#. §4: `B`
#. §5: `p : A × B`
#. §6: `p.1 : A`
#. §7: `p.2 : B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "The product type comes with *projection functions* of type §0 and §1 which take an element §2 and return the corresponding components from §3 and §4 respectively.\n"
"\n"
"In Lean, the elements defined by projecting from §5 are denoted §6 and §7."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Introducing And"
msgstr ""

#. §0: `cases`
#. §1: `cases «{hpq}»`
#. §2: `rcases «{hpq}» with hp | hq`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "The hypothesis generated by the §0 tactic isn't directly useable yet. Try §1 again, or §2 to name your own variables."
msgstr ""

#. §0: `A → Empty`
#. §1: `A`
#. §2: `B`
#. §3: `f : A → Empty`
#. §4: `A → B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "In this level, we will explore another weird consequence of the hypothesis that we have a function of type §0.\n"
"\n"
"Let §1 and §2 be any types and assume there is a function §3.\n"
"\n"
"Then it is always possible to define a function §4.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. §0: `f : A × B → C`
#. §1: `A`
#. §2: `B`
#. §3: `C`
#. §4: `f ⟨a,b⟩`
#. §5: `g : A → B → C`
#. §6: `g`
#. §7: `a : A`
#. §8: `b : B`
#. §9: `C`
#. §10: `g a b : C`
#. §11: `A × B → C`
#. §12: `A → B → C`
#. §13: `A`
#. §14: `B`
#. §15: `C`
#. §16: `f : A × B → C`
#. §17: `⟨a, b⟩ : A × B`
#. §18: `C`
#. §19: `g : A → B → C`
#. §20: `a : A`
#. §21: `g a : B → C`
#. §22: `b : B`
#. §23: `C`
#. §24: `A → B → C`
#. §25: `A × B → C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Consider a function §0 mapping out of a product type. This function takes an ordered pair of elements, one from §1 and one from §2 and returns an element of type §3 denoted by §4. Does this sound familiar?\n"
"\n"
"Recall that terms of type §5 were functions of two variables. The function §6 takes §7 and §8 and returns an element of type §9 denoted by §10, which is basically\n"
"\n"
"In summary, the types §11 and §12 both provide a notion of function of two variables, with inputs from the types §13 and §14 and output in the type §15. The difference is that §16 is thought of as a function that takes a pair §17 to an element of type §18, while §19 is thought of as a function that takes §20 to a function §21 (which then takes §22 to an element of type §23).\n"
"\n"
"The process of converting a function of type  §24 to one of type §25 is called *uncurrying* and is defined by the function below."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Composition"
msgstr ""

#. §0: `a : A`
#. §1: `Sum.inl a : A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For any §0, there is an element §1."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#. §2: `P ∧ Q`
#. §3: `Q ∧ P`
#. §4: `P ∧ Q → Q ∧ P`
#. §5: `(P ∧ Q) → (Q ∧ P)`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "If §0 is true, then §1 is too.\n"
"\n"
"In other words, §2 implies §3, as is expressed by the proposition §4 which is implicitly parenthesized as §5."
msgstr ""

#. §0: `absurd`
#. §1: `exact absurd`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "Lean has a built in name §0 for the theorem you have just proven, so this level may be solved with §1. This has been added to the theorem library."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → B`
#. §3: `f : A → B`
#. §4: `A`
#. §5: `B`
#. §6: `A × B`
#. §7: `⟨a, b⟩ : A × B`
#. §8: `a : A`
#. §9: `b : B`
#. §10: `A`
#. §11: `B`
#. §12: `A ⊕ B`
#. §13: `a : A`
#. §14: `Sum.inl a : A ⊕ B`
#. §15: `b : B`
#. §16: `Sum.inr b : A ⊕ B`
#: Game.Levels.CoproductWorld
msgid "Given any types §0 and §1 we have studied\n"
"\n"
"* function types §2 whose elements §3 are *functions* from §4 to §5 and\n"
"\n"
"* product types §6 whose elements §7 are *pairs* of elements §8 and §9.\n"
"\n"
"In this world, we'll study another binary type forming operation. Given two types §10 and §11, there is a type §12 called the *coproduct type* which has two types of elements:\n"
"\n"
"* elements §13 define elements §14\n"
"* elements §15 define elements §16.\n"
"\n"
"Like the analogy between function types and implication, and product types and conjunction, there is a close analogy between coproduct types and the logical operation of disjunction."
msgstr ""

#: Game.Levels.NegationWorld.L11_BossLevel
msgid "Move on to Classical World to better understand the statements involving negation that we have not been able to prove thus far."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P ∧ Q) ∧ R`
#. §4: `P ∧ (Q ∧ R)`
#. §5: `P ∧ Q ∧ R`
#. §6: `P ∧ (Q ∧ R)`
#. §7: `h : (P ∧ Q) ∧ R`
#. §8: `h.1 : P ∧ Q`
#. §9: `h.2 : R`
#. §10: `h.1.1 : P`
#. §11: `h.1.2 : Q`
#. §12: `p : P`
#. §13: `q : Q`
#. §14: `r : R`
#. §15: `⟨⟨p, q⟩, r⟩ : (P ∧ Q) ∧ R`
#. §16: `⟨p, ⟨q, r⟩⟩ : P ∧ (Q ∧ R)`
#. §17: `⟨p, q, r⟩ : P ∧ Q ∧ R`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "For propositions §0, §1, and §2, §3 is true if and only if §4 is true.\n"
"\n"
"Lean likes to drop parentheses whenever possible so uses §5 as an abbreviation for §6. While it's difficult to remember this convention, at least the two possible statements are logically equivalent!\n"
"\n"
"Given a proof §7, we obtain proofs §8 and §9. From the first of these,\n"
"we obtain further proofs §10 and §11.\n"
"\n"
"Similarly, given proofs §12, §13, §14, then §15 while §16. Lean allows the shorthand §17 for the latter proof."
msgstr ""

#: Game.Levels.EqualityWorld
msgid "Equality World"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `A`
#. §4: `A ⊕ Empty`
#. §5: `A ⊕ Empty`
#. §6: `Sum.inl a`
#. §7: `a : A`
#. §8: `Sum.inr x`
#. §9: `x : Empty`
#. §10: `A ⊕ Empty`
#. §11: `A`
#. §12: `A → A ⊕ Empty`
#. §13: `A ⊕ Empty → A`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall that for any types §0 and §1, there is a *coproduct type* denoted §2.\n"
"\n"
"In particular, for any type §3, we may form the product §4 with the empty type.\n"
"\n"
"In general, coproduct types like §5 have two types of elements: those of the form §6 for some §7 and those of the form §8 for §9.\n"
"\n"
"But the empty type does not have any elements. So this second case does not exist.\n"
"\n"
"It follows that the type §10 is *equivalent* to the type §11 in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions §12 and §13."
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Where have you seen this construction before? Can you solve this level in a different way?"
msgstr ""

#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Define the composition of two functions as a multivariable function between function types."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `p`
#. §3: `P`
#. §4: `h`
#. §5: `P → Q`
#. §6: `Q`
#. §7: `h`
#. §8: `p`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now we are in the setting of two proposition variables §0 and §1 with two hypotheses. The first assumption provides a proof §2 that the proposition §3 is true. The second provides a proof §4 that the implication §5 is true.\n"
"\n"
"It follows from both of these facts that §6 is also true and we can construct a proof by applying the hypothesis §7 to the proof §8."
msgstr ""

#. §0: `«{lem}»`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Now might be a good time to case split on the hypothesis §0."
msgstr ""

#. §0: `P ∧ Q → R`
#. §1: `P → Q → R`
#. §2: `P → (Q → R)`
#. §3: `(P → Q) → R`
#. §4: `Currying`
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "We now establish a logical equivalence between §0 and §1.\n"
"\n"
"This is why implications of the form §2 are so much more common than implications of the form §3.\n"
"\n"
"The name §4 will be explained in a future level.\n"
"\n"
"Note the two implications have been added to the theorem library, should you wish to use them."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "What is the outermost logical connective? What tactic is used to prove statements of this form?"
msgstr ""

#. §0: `«{h}».1 : «{P}»`
#. §1: `«{h}».2 : «{Q}» ∨ «{R}»`
#. §2: `have p := «{h}».1`
#. §3: `have qr := «{h}».2`
#. §4: `p`
#. §5: `qr`
#. §6: `cases «{h}».2`
#. §7: `rcases`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Recall that §0 and §1. We can introduce these as named variables in the context by typing §2 and §3 where §4 and §5 are variable names you get to pick. This allows you to case split on an explicitly named variable. Alternatively, type §6, or use §7 to name your own variables."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `→`
#. §4: `P`
#. §5: `Q`
#. §6: `P → Q`
#. §7: `P`
#. §8: `Q`
#. §9: `P → Q`
#. §10: `P → Q`
#: Game.Levels.ImplicationWorld
msgid "We begin our study of proofs with *propositional logic*.\n"
"\n"
"Many mathematical propositions are built out of simpler propositions using logical connectives. The structure of a compound proposition &mdash; that is, which connectives appear where &mdash; often suggests proof techniques, as we will discover.\n"
"\n"
"To study these connectives, we require *proposition variables* &mdash; denoted with letters like §0, §1, §2 &mdash; which stand for generic propositions, which may be true or false.\n"
"\n"
"In this level we study the logical connective *implication* denoted by §3.\n"
"\n"
"For arbitrary *propositions* §4 and §5, §6 is a new proposition asserting that *if* §7 *is true then* §8 *is true*.\n"
"\n"
"To understand how implications work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §9.\n"
"* How to use a hypothesis of the form §10 to prove something else.\n"
"\n"
"We'll learn the rules for proving implications and using implications in the levels that follow."
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "We'll now study the second type of element of in a coproduct type."
msgstr ""

#. §0: `constructor`
#. §1: `«{A}» → «{C}»`
#. §2: `«{B}» → «{C}»`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Now the goal is a product type. The §0 tactic will split into two subgoals, defining the functions §1 and §2 respectively."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P ∨ Q) ∨ R`
#. §4: `P ∨ (Q ∨ R)`
#. §5: `P ∨ Q ∨ R`
#. §6: `P ∨ (Q ∨ R)`
#. §7: `h₁ : (P ∨ Q) ∨ R`
#. §8: `cases h₁`
#. §9: `P ∨ Q`
#. §10: `R`
#. §11: `h₂ : P ∨ Q ∨ R`
#. §12: `cases h₂`
#. §13: `P`
#. §14: `Q ∨ R`
#. §15: `rcases`
#. §16: `h₁ : (P ∨ Q) ∨ R`
#. §17: `rcases h₁ with (p | q) | r`
#. §18: `h₂ : P ∨ Q ∨ R`
#. §19: `rcases h₂ with p | q | r`
#. §20: `\\7`
#. §21: `₇`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Similarly, for propositions §0, §1, and §2, §3 holds if and only if §4 holds.\n"
"\n"
"Lean uses §5 as an abbreviation for §6.\n"
"\n"
"Given a hypothesis §7, §8 will split the hypothesis into two cases: one assuming that §9 is true and the other assuming §10 is true.\n"
"\n"
"Similarly given a hypothesis §11, §12 the hypothesis into two cases: one assuming that §13 is true and the other assuming §14 is true.\n"
"\n"
"Note the §15 tactic allows more general patterns of disjunctions. Given §16 try §17. Similarly, given §18, try §19.\n"
"\n"
"Aside: typing §20 using any single digit number produces a subscript with that number, like §21."
msgstr ""

#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Next we will study the relationship between products and coproducts."
msgstr ""

#. §0: `«{f}» : A → Empty`
#. §1: `«{a}» : A`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "We have assumptions §0 and §1? What can you construct using this?"
msgstr ""

#. §0: `A × B`
#. §1: `B × A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Product types are symmetric: an element of type §0 has a corresponding element of type §1 with components swapped."
msgstr ""

#. §0: `P ↔ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `(P → Q) ∧ (Q → P)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "§0, read as &ldquo;§1 if and only if §2&rdquo; is an abbreviation for §3."
msgstr ""

#. §0: `A`
#. §1: `id : A → A`
#. §2: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type §0, the identity function §1 is the function defined by sending and arbitrary element §2 to itself."
msgstr ""

#. §0: `P → Q`
#. §1: `</>`
#. §2: `editor mode`
#. §3: `>_`
#. §4: `typewriter mode`
#. §5: `typewriter mode`
#. §6: `retry`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "There are two ways to prove that §0 under the assumption given below. Can you find them both?\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled §1 in the upper right hand corner to enter §2. Then delete all the lines of your first proof (or proof attempt). Clicking on §3 takes you back to §4.\n"
"\n"
"You can also delete a proof attempt in line by line in §5 using the §6 button to the right of that line."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Think carefully about what §0 proves and what proofs can be extracted from this."
msgstr ""

#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Function Extensionality"
msgstr ""

#. §0: `retry`
#. §1: `assumption`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "You can click on §0 to attempt a different proof. Try typing §1 instead."
msgstr ""

#. §0: `P`
#. §1: `Classical.em P : P ∨ ¬ P `
#. §2: `P`
#. §3: `¬ P`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "For any proposition §0, §1 proves that §2 or §3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "This proves the that conjunction distributes over disjunction. A more involved form of distributivity appears in the next level."
msgstr ""

#. §0: `And.symm`
#. §1: `P ∧ Q`
#. §2: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "The proof you have just constructed is now recorded as a theorem called §0 in the library to the right.\n"
"\n"
"In fact §1 is true if and only if §2 is true, as we will now demonstrate."
msgstr ""

#. §0: `f : A ⊕ B → C`
#. §1: `A → C`
#. §2: `B → C`
#. §3: `g : A → C`
#. §4: `h : B → C`
#. §5: `A ⊕ B → C`
#. §6: `x : A ⊕ B`
#. §7: `x`
#. §8: `Sum.inl a`
#. §9: `a : A`
#. §10: `x`
#. §11: `Sum.inr b`
#. §12: `b : B`
#. §13: `g`
#. §14: `g a : C`
#. §15: `h`
#. §16: `h b : C`
#. §17: `x`
#. §18: `x : A ⊕ B`
#. §19: `cases x`
#. §20: `rcases x with a | b`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "A function §0 mapping out of a coproduct type may be *broken apart* into component functions of types §1 and §2.\n"
"\n"
"Conversely, given an arbitrary pair of functions §3 and §4, one can build a function of type §5.\n"
"\n"
"This function is defined by introducing a variable term §6 and then splitting into two cases: the case where §7 is of the form §8 for some §9 and the case where §10 is of the form §11 for some §12.\n"
"\n"
"In the first case, the function §13 can be used to define an element §14, while in the second case the function §15 can be used to define an element §16.\n"
"\n"
"This construction should be reminiscent of a proof by cases involving a hypothesis §17 that a disjunction is true and in fact the same tactics apply.\n"
"\n"
"Given a hypothesis §18, either §19 or §20 can be used to split into the two cases mentioned above."
msgstr ""

#. §0: `intro p`
#. §1: `p : A × B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The goal is a term of a function type so type §0 to give yourself a term §1."
msgstr ""

#. §0: `apply`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Here §0 is another tactic, which can be found in the library above right."
msgstr ""

#. §0: `rcases`
#. §1: `cases`
#. §2: `h : P ∨ Q`
#. §3: `rcases h with p | q`
#. §4: `cases h`
#. §5: `p : P`
#. §6: `q : Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "§0 is a tactic that will perform §1 recursively, according to a pattern. One use is to provide explicit names for variables in each subgoal. For example, given a hypothesis §2, §3 can be used in place of §4 to give hypotheses §5 in the first case and §6."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "What can you conclude from the hypothesis §0?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "And Implies Or"
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What proof strategy is available with an element of a coproduct type?"
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "The goal is a product of function types, so to define an element you need to define two different functions. Each will take some work, so start with the §0 tactic to split one goal into two goals."
msgstr ""

#. §0: `Empty ⊕ (Empty → Empty)`
#. §1: `(Empty → Empty) × (Empty → Empty)`
#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "There are functions in both directions between the types §0 and §1."
msgstr ""

#. §0: `apply`
#. §1: `Q`
#. §2: `h : P → Q`
#. §3: `apply h`
#. §4: `P`
#. §5: `T`
#. §6: `e : R → S → T`
#. §7: `apply e`
#. §8: `R`
#. §9: `S`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The §0 tactic can be used when the goal matches the conclusion of an implication.\n"
"For example if the goal is §1 and there is a hypothesis §2, then §3 updates the goal to §4. If the goal is §5 and there is a hypothesis §6, then §7 produces two subgoals, one each for §8 and §9."
msgstr ""

#. §0: `f : A × B → C`
#. §1: `curry f : A → B → C`
#. §2: `f : X → A × B`
#. §3: `X`
#. §4: `A × B`
#. §5: `X → A`
#. §6: `X → B`
#. §7: `x : X`
#. §8: `(f x).1 : A`
#. §9: `(f x).2 : B`
#. §10: `f x : A × B`
#. §11: `f : X → A × B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that a function §0 out of a product can be regarded as a function of two variables §1.\n"
"\n"
"How should we think about a function into a product?\n"
"\n"
"Given a function §2 from a type §3 into a product type §4 one can define a pair of functions with types §5 and §6 that for §7 record the values §8 and §9 defined by projecting the pair §10 to its components.\n"
"\n"
"These might be called the *component functions* associated to §11.\n"
"\n"
"Define a function that extracts the component functions associated to a function into a product."
msgstr ""

#. §0: `A → B → C`
#. §1: `A → (B → C)`
#. §2: `f : A → B → C`
#. §3: `a : A`
#. §4: `f a : B → C`
#. §5: `B`
#. §6: `C`
#. §7: `b : B`
#. §8: `f a`
#. §9: `f a b : C`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "An element of type §0, which abbreviates the type §1, can be thought of as a function of two variables.\n"
"\n"
"Given §2 and §3, then §4 is a function from §5 to §6.\n"
"\n"
"Then given §7 we can apply the function §8 to get an element §9."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Try applying the hypothesis §0."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "§0 is true if and only if §1 is true."
msgstr ""

#. §0: `cases «{p}»`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Type §0 to ask Lean to consider all possible cases involving a proof of false. As there are no cases, this will complete the proof."
msgstr ""

#. §0: `A`
#. §1: `Empty.elim : Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type §0, there is a function §1 expressing the elimination rule of the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "Now we are ready for the boss level."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Define the uncurrying function, convering a function of two variables into a function out of a product type."
msgstr ""

#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "To Empty"
msgstr ""

#: Game.Levels.NegationWorld
msgid "Negation World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Associativity"
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `⟨a ,b⟩ : A × B`
#. §3: `⟨a, b⟩.fst : A`
#. §4: `⟨a , b⟩.snd : B`
#. §5: `a`
#. §6: `b`
#. §7: `⟨a, b⟩.fst = a`
#. §8: `⟨a, b⟩.snd = b`
#. §9: `rfl`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Now consider elements §0 and §1. There is a corresponding pair §2 that we can project back to define terms\n"
"§3 and §4. How do these relate to the original terms §5 and §6?\n"
"\n"
"Another *computation rule* for product types tells us §7 and §8 by definition, meaning that §9 can provide proofs."
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P → P`
#. §2: `P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `P`
#. §6: `P`
#. §7: `P`
#. §8: `P`
#. §9: `P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The Boss Level of Negation World previews the next world by studying the relationship between two *classical* tautologies that we have not been able to prove involving a proposition §0.\n"
"\n"
"One statement we have not been able to prove is called *double negation elimination*: §1. Double negation elimination asserts that if §2 is not false, then §3 must be true.\n"
"\n"
"Another statement we have not been able to prove is called *law of excluded middle*: §4. The law of excluded middle asserts that either §5 is true or §6 is false.\n"
"\n"
"In the next world, we'll explore why these statements fall outside the realm of *constructive logic*.\n"
"\n"
"But what we *can* prove constructively is that for any proposition §7, the law of excluded middle for §8 implies double negation elimination for §9.\n"
"\n"
"Have fun!"
msgstr ""

#. §0: `f : A → B → C`
#. §1: `swap f : B → A → C`
#. §2: `swap (swap f) : A → B → C`
#. §3: `f`
#. §4: `f g : X → Y`
#. §5: `f x = g x`
#. §6: `x : X`
#. §7: `f = g`
#. §8: `f`
#. §9: `g`
#. §10: `X → Y`
#. §11: `ext x`
#. §12: `f x = g x`
#. §13: `x : X`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Consider a function §0. We've defined a corresponding function §1 by exchanging the order of the inputs. Applying this construction twice, we obtain §2. How does this compare with the original function §3?\n"
"\n"
"In general, two functions §4 are *equal* just when §5 for all inputs §6. This rule is called *function extensionality*.\n"
"\n"
"When faced with a goal of the form §7 where §8 and §9 are functions belonging to the type §10, the tactic §11 will reduce to the problem of proving §12 for a generic variable §13."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "Pairing"
msgstr ""

#. §0: `P ∨ Q → R`
#. §1: `P ∨ Q → R`
#. §2: `P → R`
#. §3: `P`
#. §4: `P ∨ Q`
#. §5: `R`
#. §6: `P ∨ Q → R`
#. §7: `Q → R`
#. §8: `P → R`
#. §9: `Q → R`
#. §10: `P ∨ Q → R`
#. §11: `P → R`
#. §12: `Q → R`
#. §13: `P ∨ Q → R`
#. §14: `P ∨ Q → R`
#. §15: `(P → R) ∧ (Q → R)`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What must be true in order to have §0?\n"
"\n"
"On the one hand, if §1 is true, then §2 is true, because §3 implies §4, which implies §5.\n"
"\n"
"Similar reasoning shows that if §6 is true, then §7 is true.\n"
"\n"
"Conversely, if *either* §8 or §9 are true, this does not necessarily imply that §10 is true. Can you see why?\n"
"\n"
"However, if *both* §11 and §12 are true, then §13 is true.\n"
"\n"
"The aim of this level is to establish a logical equivalence between §14 and §15."
msgstr ""

#. §0: `«{P}» → «{Q}»`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "Which tactics can be used to prove §0 with our given assumptions?"
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What implications can you extract from §0?"
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Are function types symmetric? Why or why not?"
msgstr ""

#. §0: `A → (B → C)`
#. §1: `A → B → C`
#. §2: `(A → B) → C`
#. §3: `f : A → B`
#. §4: `C`
#. §5: `a : A`
#. §6: `(A → B) → B`
#. §7: `a : A`
#. §8: `f : A → B`
#. §9: `f a : B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "While an element of type §0, more commonly written as §1, is a function of two variables, an element of type §2 is instead a function that takes a function §3 as input and returns an element of type §4.\n"
"\n"
"For example, if we are given §5, then it is possible to define a function of type §6 which is called *evaluation* at §7. Given §8, we return §9."
msgstr ""

#. §0: `«{C}»`
#. §1: `exact`
#. §2: `apply`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Now that the goal is an element of type §0 there are several ways to proceed. You can use §1 or §2."
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "First Projection"
msgstr ""

#. §0: `Function.uncurry : (A → B → C) → (A × B → C)`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"The operations of *currying* and *uncurrying* are inverses in a sense we will be able to make precise later."
msgstr ""

#. §0: `exact b`
#. §1: `assumption`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Both §0 and §1 can be used here."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "If this is your first time solving this level, go back and solve it another way."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → (A → B) → B`
#. §3: `a : A`
#. §4: `ev a`
#. §5: `(A → B) → B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "For types §0 and §1, the evaluation function has type §2, meaning that for §3, §4 has type §5."
msgstr ""

#: Game
msgid "FYS270"
msgstr ""

#. §0: `P ∧ (Q ∨ R)`
#. §1: `P`
#. §2: `Q ∨ R`
#. §3: `P ∧ Q`
#. §4: `P ∧ R`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "What does it mean if §0 holds?\n"
"\n"
"Then certainly §1 is true and also §2 is true.\n"
"\n"
"So we can conclude that §3 is true or §4 is true, demonstrating the following logical equivalence."
msgstr ""

#. §0: `intro g f`
#. §1: `intro g f a`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "To define a function with multiple variables you can apply the intro tactic twice, for instance by typing §0 or even §1."
msgstr ""

#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Noncontradiction"
msgstr ""

#. §0: `have lemP : P ∨ ¬ P := em P`
#. §1: `P ∨ ¬ P`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "To use the law of excluded middle in your proof, type §0 to add an assumption that §1 is true."
msgstr ""

#. §0: `Q`
#. §1: `exact «{h}».2`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now Lean reminds you of the other goal, which is to prove §0. Type §1 to supply this proof."
msgstr ""

#. §0: `Sum.inl`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "If your answer does not use the function §0, you might have fun trying to solve this level again using it in an appropriate place."
msgstr ""

#. §0: `have := «{f}» «{a}»`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Use §0 to add an element of the empty type to the list of assumptions."
msgstr ""

#. §0: `«{P}»`
#. §1: `Show more help!`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now your goal is a proof of §0. Can you figure out how to finish the proof? If you need a reminder, click the button §1"
msgstr ""

#. §0: `«{Q}» ∨ «{P}»`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that Lean provides two goals, both of which are to prove that §0 is true, under two different hypothesies. Your first task is to prove the theorem in the first case."
msgstr ""

#. §0: `unfold`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "The tactic §0 can be used to unfold user-defined names using their original definitions."
msgstr ""

#. §0: `«{h}» «{p}» : «{Q}»`
#. §1: `exact «{h}» «{p}»`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Since §0 It is possible to solve this level with §1."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#. §3: `\\circ`
#. §4: `∘`
#. §5: `x : A`
#. §6: `(g ∘ f) x`
#. §7: `g (f x)`
#. §8: `g`
#. §9: `f`
#. §10: `g ∘ f`
#. §11: `exact g ∘ f`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Lean has built in notation for the composite of §0 and §1 namely §2, using §3 to type §4.\n"
"\n"
"Given §5, §6 is defined to be the element §7, which is why the function §8 appears on the left of §9 in the notation §10.\n"
"\n"
"Try solving this level with §11."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Universal Property"
msgstr ""

#. §0: `cases`
#. §1: `rcases`
#. §2: `«{p}»`
#. §3: `B ⊕ C`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You can use §0 or §1 either on §2 to split it up into components or directly on its component in §3.Be careful to use the syntax that is appropriate for terms of product or coproduct types, respectively."
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `⟨a, b⟩ : A × B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "By pairing any element §0 with any element §1, there is an element §2."
msgstr ""

#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Paired Projections"
msgstr ""

#. §0: `P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P ∨ Q`
#. §6: `p : P`
#. §7: `q : Q`
#. §8: `exact p`
#. §9: `exact q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "To prove a disjunction §0 it suffices to supply a proof of either §1 or of §2.\n"
"\n"
"Thus under the hypothesis that §3 and §4 are both true, there are two ways to prove §5: one using §6 and one using §7.\n"
"\n"
"Note §8 or §9 won't work as these are proofs of different propositions."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Prod.fst : A × B → A`
#. §3: `p : A × B`
#. §4: `p.1 : A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "For any types §0 and §1, §2 is the function that sends §3 to its first coordinate §4."
msgstr ""

#. §0: `P → Q`
#. §1: `Q → R`
#. §2: `P → R`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "If §0, then if §1, then §2."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q → R`
#. §3: `R`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "If §0 is true, §1 is true, and §2 is true, then §3 is true."
msgstr ""

#. §0: `P`
#. §1: `P`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If the proposition §0 is true, then §1 is true."
msgstr ""

#. §0: `«{P}» ∨ («{Q}» ∨ «{R}»)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Here the goal is parenthesized as §0. Using your hypothesis, are you trying to prove the left-hand proposition or the right-hand one?"
msgstr ""

#. §0: `False`
#. §1: `have := «{np}» «{p}»`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If you like, you can add a proof of §0 to your assumption list by §1."
msgstr ""

#. §0: `«{h}»`
#. §1: `«{P}»`
#. §2: `«{Q}»`
#. §3: `«{Q}»`
#. §4: `«{P}»`
#. §5: `apply «{h}»`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The hypothesis §0 can be used to convert a proof of §1 into a proof of §2. This can be thought of as a step that reduces the problem of proving §3 to the problem of proving §4. To apply this hypothesis type §5."
msgstr ""

#. §0: `a : A`
#. §1: `f : A → B → C`
#. §2: `B → C`
#. §3: `f`
#. §4: `a`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Given an element §0 and a function of two variables §1, define a function from §2 by evaluating the first variable of §3 at the element §4."
msgstr ""

#. §0: `¬ Q → ¬ P`
#. §1: `P → Q`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "In classical logic, §0 implies §1."
msgstr ""

#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "By Contradiction"
msgstr ""

#. §0: `«{hyp}»`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What proof technique is available when you have a hypothesis like §0?"
msgstr ""

#. §0: `∧`
#. §1: `P`
#. §2: `Q`
#. §3: `P ∧ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∧ Q`
#. §7: `P ∧ Q`
#. §8: `P ∧ Q`
#. §9: `p : P`
#. §10: `q : Q`
#. §11: `⟨p,q⟩ : P ∧ Q`
#. §12: `h : P ∧ Q`
#. §13: `P`
#. §14: `Q`
#. §15: `h.1 : P`
#. §16: `h.2 : Q`
#: Game.Levels.ConjunctionWorld
msgid "The logical connective of *conjunction*, denoted by §0, is the mathematical version of *and*.\n"
"\n"
"For arbitrary propositions §1 and §2, §3 is a new proposition asserting that §4 *and* §5 *are both true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §6.\n"
"* How to use a hypothesis of the form §7 to prove something else.\n"
"\n"
"To prove §8, one must supply proofs §9 and §10, which can be done using the syntax §11. Use '\\\\<' and '\\\\>' to type the angle brackets.\n"
"\n"
"If we have a proof §12 then we can extract proofs that §13 and §14 are true using the syntax §15 and §16."
msgstr ""

#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Multivariable functions"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `A`
#. §3: `C`
#. §4: `x : A`
#. §5: `f x : B`
#. §6: `g (f x) : C`
#. §7: `exact fun x ↦ ?`
#. §8: `?`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions §0 and §1 there is a *composite function* from §2 to\n"
"§3.\n"
"\n"
"It is defined to be the function that sends §4 first to the element §5 and then\n"
"to the element §6.\n"
"\n"
"Can you solve this level in one line by using §7 with the appropriate thing in place of the §8?\n"
"\n"
"Alternatively, you can use other tactics to define the required function step by step."
msgstr ""

#. §0: `Sum.inl : A → A ⊕ B`
#. §1: `A ⊕ B`
#. §2: `A`
#. §3: `apply Sum.inl`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "To use the built in function §0 to change the goal from §1 to §2 type §3."
msgstr ""

#. §0: `a : A`
#. §1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "In summary, a basic axiom of equality is *reflexivity*:\n"
"for any §0, §1 is always true."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "A function into a product type has a pair of component functions."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If this is your first time solving this level, delete your proof, and try to find another solution."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "If §0 is true and §1 is true, then §2 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that you've completed the proof in the first case, Lean expects you to provide a proof in the second case."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Product With Empty"
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Congratulations!"
msgstr ""

#: Game.Levels.ClassicalWorld
msgid "Classical World"
msgstr ""

#. §0: `Empty`
#. §1: `Empty`
#. §2: `A`
#. §3: `A`
#. §4: `Empty.elim : Empty → A`
#. §5: `Empty → A`
#. §6: `X`
#. §7: `A`
#. §8: `x : X`
#. §9: `A`
#. §10: `Empty`
#. §11: `A`
#. §12: `Empty`
#: Game.Levels.EmptyWorld
msgid "In this world, we will introduce the *empty type*, which is commonly denoted by §0 in Lean.\n"
"\n"
"In general, types can be characterized by:\n"
"* Introduction rules: which explain how to construct elements of the given type.\n"
"* Elimination rules: which explain how to use elements of the given type to construct elements of other types.\n"
"\n"
"In the case of the empty type, there are no introduction rules. This corresponds colloquially to the idea that the empty type has &ldquo;no elements.&rdquo;\n"
"\n"
"The elimination rule for the empty type defines a function from the §1 type to any other type §2, with no obligations on the type §3. This provides a canonical element §4 of the function type.\n"
"\n"
"There is another way to understand why the type §5 should always have an element.\n"
"\n"
"In order to define a function from a type §6 to a type §7 one must fulfill the following obligation: for each §8 one must specify an element of type §9.\n"
"\n"
"In the case of a function from the type §10 to a type §11, there are no obligations because the empty type has no elements.\n"
"\n"
"In this world, we will explore constructions involving the §12 type."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "The overall objective here is to prove a conjunction. Which tactic can help break this up into simpler statements?"
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ProvingImplication
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Let us now explore other implications that are provable with this strategy."
msgstr ""

#. §0: `exact`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "The goal is an implication you've already proven. You can use §0 together with the name of that result, to solve this goal in one line. Alternatively, you can just prove it again."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Using Or"
msgstr ""

#. §0: `apply f`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "There is another way to solve this level. Start with §0 and see what happens. Have you seen a construction like this before?"
msgstr ""

#. §0: `exact «{p}»`
#. §1: `«{p}»`
#. §2: `«{P}»`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Type §0 to tell Lean that §1 is a proof of §2."
msgstr ""

#. §0: `exact fun x ↦ x`
#. §1: `\\mapsto`
#. §2: `↦`
#. §3: `x`
#. §4: `x`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "You can solve this level in one level by just giving the entire formula for the function as\n"
"§0, using §1 to type §2. This tells Lean that the answer is the function defined on an input element §3 to have an output value §4."
msgstr ""

#. §0: `Or`
#. §1: `P`
#. §2: `P ∨ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Look at the theorems about §0 if you have forgotten how to tell Lean about the relationship between §1 and §2."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Does this construction feel intuitive or does it feel strange?"
msgstr ""

#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Through Empty"
msgstr ""

#. §0: `a : A`
#. §1: `B`
#. §2: `const a : B → A`
#. §3: `x : B`
#. §4: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "For a term §0 and a type §1, §2 is the function defined by sending §3 to §4."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `¬ P`
#. §3: `P → False`
#. §4: `¬ P`
#. §5: `P`
#. §6: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "Given a proposition §0, the *negation* of §1 &mdash; abbreviated §2 &mdash; is defined to be the proposition §3.\n"
"\n"
"If we have a proof of §4 and also a proof of §5 then we get something very strange: a proof of §6!\n"
"\n"
"This can be expressed in various different ways, as we shall see over the next few levels.\n"
"\n"
"In this level, we encode this statement in the way that allows for the simplest proof.\n"
"\n"
"In subsequent levels, we shall express this tautology in several logically equivalent forms."
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.ProductWorld.L06_Currying
msgid "What sort of inputs does the function §0 require?"
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "Left Inclusion"
msgstr ""

#. §0: `«{np}»`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "How can we apply the hypothesis §0?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → B`
#. §3: `f : A → B`
#. §4: `A`
#. §5: `B`
#. §6: `A`
#. §7: `B`
#. §8: `A × B`
#. §9: `p : A × B`
#. §10: `A`
#. §11: `B`
#. §12: `A × B`
#. §13: `A × B`
#: Game.Levels.ProductWorld
msgid "In Function World, we learned that for any types §0 and §1 there is a new type §2 whose elements §3 are *functions* from §4 to §5.\n"
"\n"
"In this world, we'll meet another binary type forming operation.\n"
"\n"
"Given two types §6 and §7, there is a type §8 called the *product type* whose elements §9 should be thought of as encoding ordered pairs of elements, one from §10 and one from §11.\n"
"\n"
"Like the analogy between function types and implication, there is a close analogy between product types and the logical operation of conjunction.\n"
"\n"
"To understand how products work in type theory we must learn:\n"
"\n"
"* How to construct elements of type §12.\n"
"* How to use elements of type §13 to construct elements of other types."
msgstr ""

#. §0: `¬ (P → Q)`
#. §1: `P → Q`
#. §2: `P → Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∧ ¬ Q`
#. §8: `¬ (P → Q)`
#. §9: `P`
#. §10: `Q`
#. §11: `P → Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"The implication asserts that if §3 is true then §4 must be true as well.\n"
"\n"
"So if we show that §5 is true but §6 is false, this would disprove the implication.\n"
"\n"
"In this level, we will prove that §7 implies §8. That is, if §9 is true and §10 is false, then §11 is not true."
msgstr ""

#. §0: `Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving`
#: Game
msgid "This was created using the GameSkeleton Github Repo from the Lean Games Server hosted by ADAM: Anticipating the Digital Age of Mathematics at Heinrich Heine University Düsseldorf. It is designed for a first year seminar course taught at Johns Hopkins University in Fall 2025 with the title §0."
msgstr ""

#. §0: `P`
#. §1: `False.elim : False → P`
#. §2: `False`
#. §3: `P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition §0, §1 proves that §2 implies §3."
msgstr ""

#. §0: `P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `«{rs}» : «{R}» ∨ «{S}»`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "This completes the proof in the case where §0 holds because §1 holds. Now we've started the case where §2 holds, which requires another case split over the proof §3."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Define the canonical function projecting from a product type to its second argument."
msgstr ""

#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "Evaluation"
msgstr ""

#: Game.Levels.DisjunctionWorld
msgid "Disjunction World"
msgstr ""

#. §0: `P ∨ Q`
#. §1: `R ∨ S`
#. §2: `P ∧ R`
#. §3: `P ∧ S`
#. §4: `Q ∧ R`
#. §5: `Q ∧ S`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "A more involved form of distributivity is also true.\n"
"\n"
"If §0 holds and §1 holds then at least one of the following four propositions holds: §2 or §3 or §4 or §5.\n"
"\n"
"Demonstrate the following logical equivalence."
msgstr ""

#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Composing functions"
msgstr ""

#. §0: `«{np}»`
#: Game.Levels.NegationWorld.L05_Absurd
#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What is the logical structure of the type of §0?"
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "The goal is a product type. You can use §0 to split into two goals, defining each component function separately."
msgstr ""

#. §0: `Empty`
#. §1: `Empty`
#. §2: `A`
#. §3: `Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The type §0 has no elements &mdash; or, more precisely, the type §1 has no introduction rules.\n"
"\n"
"Consequently, for any other type §2, there is always a function §3.\n"
"\n"
"The task in this level is to define it."
msgstr ""

#. §0: `¬(P ∨ ¬ P)`
#. §1: `¬ P ∧ ¬ ¬ P`
#. §2: `«{nlem}»`
#. §3: `¬P`
#. §4: `«{nlem}»`
#. §5: `¬ ¬ P`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "Recall that §0 is logically equivalent to §1. Can you use §2 to prove §3? And then can you used §4 to prove §5?"
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `¬ P`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "In classical logic, for any proposition §0, §1 is true or §2 is true."
msgstr ""

#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "Excluded Middle"
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "For the Boss Level of Empty World, we construct something that is just weird.\n"
"\n"
"Have fun!"
msgstr ""

#. §0: `cases «{x}»`
#. §1: `rcases «{x}» with a | b`
#. §2: `«{x}» : A ⊕ B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use either §0 or §1 to consider the possible cases for the variable §2."
msgstr ""

#. §0: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Type §0 to tell Lean that we are appealing to the proof by contradiction strategy."
msgstr ""

#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Modus Ponens Again"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Note the goal window in the interactive theorem prover keeps track of exactly what proposition you are trying to prove."
msgstr ""

#. §0: `A ⊕ B → B ⊕ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The coproduct type, like the product type, is *symmetric*, and in particular has a canonical map of type §0. Your task in this level is to define it."
msgstr ""

#. §0: `P → Q`
#. §1: `Q`
#. §2: `P`
#. §3: `P → Q`
#. §4: `p : P`
#. §5: `P`
#. §6: `Q`
#. §7: `P → Q`
#. §8: `intro p`
#. §9: `p : P`
#. §10: `Q`
#. §11: `Q`
#. §12: `P`
#. §13: `P`
#. §14: `P → P`
#. §15: `P`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "To prove an implication §0 one needs to give a construction of a proof of §1 from a hypothesized proof of §2.\n"
"\n"
"In particular, to prove that §3 it suffices to assume that we have a proof §4 &mdash; even if §5 is false and such a proof does not exist &mdash; in which case the new goal is to find a proof of §6.\n"
"\n"
"When the goal has the form §7, type §8 to introduce an assumption §9 and update the goal to proving §10 &mdash; asking for a proof that §11 is true under the assumption that §12 is true.\n"
"\n"
"In this level, we will see that for any proposition §13, §14 is true. Indeed, this is the case even if §15 itself is false!"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `P → Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "For any propositions §0 and §1, if §2 is true and §3 is false, then §4 is not true."
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "Proving Implication"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A × B`
#. §3: `A`
#. §4: `A × Empty`
#. §5: `A × Empty`
#. §6: `A × Empty`
#. §7: `Empty → A × Empty`
#. §8: `A × Empty → Empty`
#. §9: `A × Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Recall that for any types §0 and §1, there is a *product type* denoted §2.\n"
"\n"
"In particular, for any type §3, we may form the product §4 with the empty type.\n"
"\n"
"Elements of product types are pairs of elements, one from the first type and one from the second type.\n"
"\n"
"But the empty type does not have any elements! So this means the product §5 cannot have any elements either.\n"
"\n"
"More precisely, the type §6 is *equivalent* to the empty type in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions §7 and §8, which as discussed in a previous level, indicates that §9 cannot have any elements either."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Ex Falso"
msgstr ""

#. §0: `«{A}»`
#: Game.Levels.ProductWorld.L01_Pairing
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Now Lean asks you to supply an element of type §0. Which tactic applies here?"
msgstr ""

#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "Proving Excluded Middle"
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Uncurrying"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Now how do we prove a conjunction?"
msgstr ""

#. §0: `cases`
#. §1: `rcases`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "This proves the symmetry of disjunction. Practice using both the §0 and §1 tactics to get used to them."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `¬ (P ∨ Q)`
#. §3: `¬ P ∧ ¬ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "For any propositions §0 and §1, the propositions §2 and §3 are logically equivalent."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "This can be solved in two ways. Can you find them both?"
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "Proving Assumed Implication"
msgstr ""

#. §0: `exact`
#. §1: `«{f}»`
#. §2: `apply`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "You can use the tactic §0 by supplying §1 with two arguments, in the correct order, with spaces in between (but no parentheses). Alternatively you can use the tactic §2."
msgstr ""

#. §0: `assumption`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "The §0 tactic tries to solve the main goal using a hypothesis of compatible type, or else fails."
msgstr ""

#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In the next world, we will finally introduce the slippery topic of equality."
msgstr ""

#: Game.Levels.CoproductWorld
msgid "Coproduct World"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Sum.inl : A → A ⊕ B`
#. §3: `A`
#. §4: `A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types §0 and §1, the function §2 can be used to include elements of type §3 as elements of the coproduct type §4."
msgstr ""

#. §0: `p : P`
#. §1: `h : P → Q`
#. §2: `Q`
#. §3: `h p : Q`
#. §4: `Q`
#. §5: `h : P → Q`
#. §6: `p : P`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Modus ponens tells us that under hypotheses §0 and §1 then §2 is true.\n"
"\n"
"In fact there is another syntax that may be used to write this proof. In Lean, we may write §3 for the proof of §4 obtained by applying the hypothesis §5 to the proof §6.\n"
"\n"
"Can you see why the following theorem is another form of modus ponens?"
msgstr ""

#. §0: `h : P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `P`
#. §4: `Q`
#. §5: `R`
#. §6: `P`
#. §7: `R`
#. §8: `Q`
#. §9: `Q`
#. §10: `R`
#. §11: `P`
#. §12: `h : P ∨ Q`
#. §13: `cases h`
#. §14: `P`
#. §15: `Q`
#. §16: `cases`
#. §17: `h : P ∨ Q`
#. §18: `rcases h with p | q`
#. §19: `cases h`
#. §20: `p : P`
#. §21: `q : Q`
#. §22: `p`
#. §23: `q`
#. §24: `P ∨ Q`
#. §25: `Q ∨ P`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Given a hypothesis §0 we know that *either* §1 or §2 is true (or possibly both are true).\n"
"\n"
"But we don't know *which* of §3 or §4 is true.\n"
"\n"
"If we want to use a hypothesis like this to prove some other proposition §5 is true we need proofs that cover either of the two cases: that is, we need to show that §6 implies §7 (whether or not §8 is true) and also that §9 implies §10 (whether or not §11 is true).\n"
"\n"
"If we have an assumption of the form §12, then type §13 to ask Lean to consider both cases: the first being that §14 is true and the second being that §15 is true.\n"
"\n"
"There is another tactic, similar to §16, which allows you to give explicit names for the hypotheses assumed in each case.\n"
"\n"
"If given a hypothesis §17, then §18 can be used in place of §19 to give hypotheses §20 in the first case and §21 in the second. (Here you can choose any variable names for §22 and §23.)\n"
"\n"
"For example, arguing by cases, we can prove that or is symmetric, that is that §24 implies §25."
msgstr ""

#. §0: `exact «{p}».1`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Now type §0 to return the first projection."
msgstr ""

#. §0: `intro`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a still function type, so continue with §0."
msgstr ""

#. §0: `g : A → C`
#. §1: `h : B → C`
#. §2: `A ⊕ B → C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "We've seen that functions out of a coproduct can be split into component functions. Similarly, component functions §0 and §1 can be assembled into a function of type §2, as we will explore in the next level."
msgstr ""

#. §0: `g : X → A`
#. §1: `h : X → A`
#. §2: `X`
#. §3: `A × B`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "Combine a pair of functions §0 and §1 into a single function from §2 to the product type §3."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `Classical.em P  : P ∨ ¬ P`
#. §6: `P`
#. §7: `em P : P ∨ ¬ P`
#. §8: `byContradiction : ¬ ¬ P → P`
#. §9: `P`
#. §10: `em`
#. §11: `em`
#. §12: `P`
#. §13: `P`
#. §14: `Q`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "The *law of excluded middle* asserts that for any proposition §0, either §1 is true or §2 is false.\n"
"\n"
"In other words, for any proposition §3, §4 is always true.\n"
"\n"
"Lean has a built-in name §5 for *the law of excluded middle* at the proposition §6. In Classical World, classical reasoning techniques are open, so you can refer to this proof by typing §7.\n"
"\n"
"Note that in contrast to §8, the proposition §9 is an *explicit argument* of the function §10. So if you type just §11, Lean will ask which proposition you have in mind.\n"
"\n"
"This is because when you are applying proof by contradiction, it is usually clear from context which proposition §12 is involved, whereas when you are appealing to the law of excluded middle, this is often not so clear.\n"
"\n"
"See if you can use the law of excluded middle to prove that for any propositions §13 and §14 one\n"
"of the following four conjunctions holds."
msgstr ""

#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Next move on to Conjunction World to meet our second logical connective."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P ∨ Q`
#. §2: `P ∧ Q → P ∨ Q`
#. §3: `P ∨ Q → P ∧ Q`
#. §4: `P ∧ Q → P ∨ Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∨ Q`
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "The proposition §0 is *stronger* than the proposition §1 because §2 is true in general, but the implication §3 does not necessarily hold.\n"
"\n"
"Note the implication §4 holds because the mathematical *or* is &ldquo;inclusive&rdquo;, meaning that if §5 and §6 are both true, then §7 is true, and in fact can be proven in two different ways."
msgstr ""

#. §0: `«{p}»`
#. §1: `exact «{p}»`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "To use the hypothesis §0 to reach this conclusion type §1."
msgstr ""

#. §0: `(P ∧ Q) ∧ R`
#. §1: `P ∧ (Q ∧ R)`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Conjunction is associative: §0 is true if and only if §1 is true."
msgstr ""

#. §0: `∧`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the §0 is the outermost logical connective. How do you prove conjunctions?"
msgstr ""

#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Now we are ready for the boss level!"
msgstr ""

#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Think about where the contradiction will ultimately arise from."
msgstr ""

#. §0: `«{i}»`
#. §1: `«{p}»`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What can we prove with the hypotheses §0 and §1?"
msgstr ""

#. §0: `«{f}» «{x}»`
#. §1: `exact «{f}» «{x}»`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "What is the type of the term §0? If you're not sure, you can type §1 and read the error message to find out."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `A`
#. §3: `C`
#. §4: `g ∘ f : A → C`
#. §5: `\\circ`
#. §6: `∘`
#. §7: `g ∘ f`
#. §8: `a : A`
#. §9: `f a : B`
#. §10: `g (f a) : C`
#. §11: `comp : (B → C) → (A → B) → (A → C)`
#. §12: `g : B → C`
#. §13: `f : A → B`
#. §14: `comp g f : A → C`
#. §15: `g`
#. §16: `f`
#. §17: `a : A`
#. §18: `g (f a) : C`
#. §19: `comp`
#. §20: `∘`
#. §21: `comp g f`
#. §22: `g ∘ f`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Recall that given functions §0 and §1 there is a *composite function* from §2 to\n"
"§3 denoted §4, using §5 to type §6.\n"
"\n"
"The function §7 is defined to be the function that sends §8 first to the element §9 and then\n"
"to the element §10.\n"
"\n"
"Define composition as a multivariable function between function types §11.\n"
"\n"
"We think of composition as the function that takes §12 and §13 to the composite function §14.\n"
"\n"
"It can also be thought of a function that takes §15, §16, and §17 to the element §18.\n"
"\n"
"Aside: Lean treats the functions §19 and §20 slightly differently because the former uses the usual notation for multivariable functions (where the arguments are provided afterwards as §21) while the latter uses infix notation (where the function name appears inbetween the two arguments as §22)."
msgstr ""

#. §0: `P`
#. §1: `exact «{p}»`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now the goal is just to prove §0. Type §1 to supply this proof."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `a : A`
#. §3: `const a : B → A`
#. §4: `x : B`
#. §5: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "For any types §0 and §1 and element §2, there is a constant function §3 that sends any §4 to the element §5."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Alternatively, you can type `exact ⟨p,q⟩' using '\\<' and '\\>' to type the angle brackets."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∧ ¬ Q → ¬ (P → Q)`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In Negation World, we proved that for any propositions §0 and §1:\n"
"\n"
"§2.\n"
"\n"
"The objective of the Boss Level is to prove the converse implication.\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "In the next level we'll meet the universal property of conjunctions."
msgstr ""

#. §0: `T ∨ U → V ∧ Y`
#. §1: `Q → P → T`
#. §2: `Y → Q → W`
#. §3: `(V ∧ W) ∨ (X ∧ Y) → Z`
#. §4: `(R → S → U) ∧ (V → R → X)`
#. §5: `P ∧ (Q ∨ R) ∧ S`
#. §6: `Z`
#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "If §0 and §1 and §2 and\n"
"§3 and §4 then  §5 implies §6."
msgstr ""

#. §0: `A`
#. §1: `a : A`
#. §2: `a = a`
#. §3: `rfl : a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For a type §0 and element §1, the proposition §2 is true because there is a proof\n"
"§3 witnessing the reflexivity of equality."
msgstr ""

#. §0: `And.symm`
#. §1: `exact And.symm`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? In fact, we gave a name §0 to the proof given in the previous level, as you can see in the list of theorems to the right. Try typing §1 at an appropriate place in your proof."
msgstr ""

#. §0: `g : B → C`
#. §1: `f : A → B`
#. §2: `g ∘ f : A → C`
#. §3: `x : A`
#. §4: `g (f x)`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions §0 and §1, define the composite function §2 that sends §3 to §4."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now the goal is a function type. What tactic is used to define functions?"
msgstr ""

#. §0: `Function.curry : (A × B → C) → (A → B → C)`
#. §1: `A → B → C`
#. §2: `A × B → C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"We'll now study the reverse process, which converts a function of type §1 to a function of type §2."
msgstr ""

#. §0: `«{f}»`
#. §1: `apply «{f}»`
#. §2: `«{A}»`
#. §3: `«{B}»`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Since §0 is a function with two variables, after §1 we now have two goals, where we need to supply first an element of type §2 and then an element of type §3."
msgstr ""

#. §0: `h : S → T`
#. §1: `apply h`
#. §2: `T`
#. §3: `S`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "In the presence of a hypothesis §0, the tactic §1 reduces the problem of proving §2 to the problem of proving §3. Can this be used here?"
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Define the canonical function projecting from a product type to its first argument."
msgstr ""

#. §0: `S → X`
#. §1: `T → W`
#. §2: `R → Y`
#. §3: `W → Q`
#. §4: `U → S`
#. §5: `Y → T`
#. §6: `X → V`
#. §7: `Q → U`
#. §8: `V → Z`
#. §9: `P → R`
#. §10: `P`
#. §11: `Z`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "If §0, §1, §2, §3, §4, §5, §6, §7, §8 and §9 are true then §10 implies §11."
msgstr ""

#. §0: `B ⊕ A → A ⊕ B`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The same construction defines a function of type §0, demonstrating the symmetry of the coproduct."
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Look carefully at the order of the arguments of §0."
msgstr ""

#: Game.Levels.ConjunctionWorld
msgid "Conjunction World"
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "From Empty"
msgstr ""

#. §0: `¬ (P ∧ ¬ P)`
#. §1: `Q`
#. §2: `P`
#. §3: `¬ P`
#. §4: `P → ¬ P → Q`
#. §5: `¬ P → P → Q`
#. §6: `P`
#. §7: `P → Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "In the last level we provided the *law of noncontradiction*: §0\n"
"\n"
"In this level, we will see that it is possible to prove any proposition §1 from the hypothesis that both §2 and §3 are true.\n"
"\n"
"In other words, §4 is always true.\n"
"\n"
"If we swapped order of the hypotheses, a similar proof would also show that §5 is true. In other words, if §6 is false, then §7 is always true.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#. §2: `¬ Q → ¬ P`
#. §3: `P → Q`
#. §4: `¬ Q → ¬ P`
#. §5: `P → Q`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "We have seen that the implication §0 implies the implication §1.\n"
"\n"
"The implication §2 is called the *contrapositive* of §3.\n"
"\n"
"In classical logic, these two statements are logically equivalent.\n"
"\n"
"That means, arguing classically, we can prove that §4 implies §5.\n"
"\n"
"Can you figure out how to prove this?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `b : A`
#. §4: `A ⊕ B`
#. §5: `Sum.inr : B → A ⊕ B`
#. §6: `Sum.inl, Sum.inr : A → A ⊕ A`
#. §7: `A`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types §0 and §1, the coproduct type §2 has two kinds of elements. The second kind can be thought of as copies of elements §3 included into the coproduct §4 *on the right*.\n"
"\n"
"Lean has a built in function called §5.\n"
"\n"
"Note that §6 are *different functions* (as long as the type §7 has at least one element) in a way we will be able to make more precise later."
msgstr ""

#. §0: `A`
#. §1: `Empty.elim : Empty → A`
#. §2: `f : A → Empty`
#. §3: `A`
#. §4: `Empty`
#. §5: `A`
#. §6: `A`
#. §7: `f : A → Empty`
#. §8: `a : A`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have seen that any type §0 has a function from the empty type §1.\n"
"\n"
"By contrast, if there is a function §2 from §3 to the empty type §4 then §5 must be very special: this is only possible if §6 is *equivalent* to the empty type.\n"
"\n"
"We do not have all the tools needed to define equivalence of types just yet, so in this level we observe something else.\n"
"\n"
"We will see that if there is a function §7 and if there is an element §8, then we get an element of the empty type, which is very strange indeed!"
msgstr ""

#. §0: `(P ∧ Q → R) → (P → Q → R)`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "This proves that §0. We will now investigate the converse implication."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `absurd`
#. §3: `P → ¬ P → Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "For any propositions §0 and §1, §2 proves that §3."
msgstr ""

#. §0: `«{c}».1`
#. §1: `«{c}».2`
#. §2: `«{c}» : P ∧ ¬ P`
#. §3: `have := «{c}».1`
#. §4: `have := «{c}».2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that §0 and §1 are the notations used for components of a conjunction, like §2. You can use these names directly or introduce them as assumptions with §3 and §4."
msgstr ""

#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "We are now ready for the Boss Level of Classical World."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Component Functions"
msgstr ""

#. §0: `A`
#. §1: `Empty`
#. §2: `A × Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "For any type §0, there are functions in both directions between the types §1 and §2."
msgstr ""

#. §0: `A`
#. §1: `Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type §0, there is a function §1 encoding the elimination rule of the empty type."
msgstr ""

#. §0: `have nq : ¬ Q := «{pnq}».2`
#. §1: `¬ Q`
#. §2: `\\neg`
#. §3: `¬`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try §0 to add a proof of §1 to your\n"
"assumptions, where §2 is used to type §3."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Proving Implied Assumption"
msgstr ""

#. §0: `f : A ⊕ B → C`
#. §1: `Sum.inl : A → A ⊕ B`
#. §2: `g : A → C`
#. §3: `f`
#. §4: `f : A ⊕ B → C`
#. §5: `Sum.inr : B → A ⊕ B`
#. §6: `h : B → C`
#. §7: `A ⊕ B → C`
#. §8: `A → C`
#. §9: `B → C`
#. §10: `A ⊕ B → C`
#. §11: `(A → C) × (B → C)`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Consider a function §0 mapping out of a coproduct type.\n"
"\n"
"By composing with the function §1 we obtain a function §2 which can be thought of as one of the two *component functions* associated to §3.\n"
"\n"
"The other component function is defined by composing §4 with the function §5 to obtain a function §6.\n"
"\n"
"Since a *single* function of type §7 decomposes into a pair of functions of types §8 and §9, we will define a function from the function type §10 into the product of the function types §11."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Negating Disjunction"
msgstr ""

#. §0: `«{f}» : «{A}» → «{B}»`
#. §1: `«{a}» : «{A}»`
#. §2: `«{f}» «{a}»`
#. §3: `exact «{f}» «{a}»`
#. §4: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The syntax for the application of the function §0 on the element §1 is just §2. So type §3 to obtain an element of type §4."
msgstr ""

#. §0: `ev : A → (A → B) → B`
#. §1: `fun a f ↦ f a`
#. §2: `(A → B) → A → B`
#. §3: `fun f a ↦ f a`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "The evaluation function has type §0 and is defined by the formula §1. By swapping variables, we can also think of evaluation as defining a function §2 where this latter function is defined by §3."
msgstr ""

#. §0: `¬ (P ∧ Q)`
#. §1: `¬ P ∧ ¬ Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Combined with what we know already, we have established a logical equivalence between  §0 and §1 in classical logic."
msgstr ""

#. §0: `h : P ∧ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `And.symm h`
#. §4: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Given a hypothesis §0 for some propositions §1 and §2, §3 is a proof of §4."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Boss level"
msgstr ""

#. §0: `(P ∨ Q) ∧ (R ∨ S)`
#. §1: `(P ∧ R) ∨ (P ∧ S) ∨ (Q ∧ R) ∨ (Q ∧ S)`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "§0 holds if and only if §1 holds."
msgstr ""

#. §0: `Empty.elim : Empty → A`
#. §1: `exact Empty.elim`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Lean has a built-in name §0 for the function you have just defined. Thus §1 will also solve this level. This function has been added to the library."
msgstr ""

#. §0: `A ⊕ B → C`
#. §1: `(A → C) × (B → C)`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "We will see later that functions of type §0 are uniquely determined by their component functions §1."
msgstr ""

#. §0: `X → A × B`
#. §1: `(X → A) × (X → B)`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The *universal property* of the product is the correspondence between functions §0 into a product and pairs of functions §1.\n"
"\n"
"We are now ready for the boss level of Product World."
msgstr ""

#. §0: `Q`
#. §1: `P`
#. §2: `¬ P`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "It is possible to prove any proposition §0 from the hypothesis that both §1 and §2 are true."
msgstr ""

#. §0: `P`
#. §1: `Classical.byContradiction : ¬ ¬ P → P`
#. §2: `P`
#. §3: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "For any proposition §0, §1 proves that if §2 is not false, then §3 is true."
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "In a compound proposition, the outermost logical connective (the one applied last in forming the proposition) often determines the overall proof strategy."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Have a look at the library of definitions for a function whose domain is the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Logical Equivalence"
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P`
#. §2: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "In classical logic, for any proposition §0, §1 implies §2."
msgstr ""

#. §0: `«{p}»`
#. §1: `«{np}»`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "How can you use §0 and §1 to get a contradiction?"
msgstr ""

#: Game.Levels.EmptyWorld
msgid "Empty World"
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `P`
#. §3: `False`
#. §4: `p : P`
#. §5: `P`
#. §6: `False`
#. §7: `P`
#. §8: `np : ¬ P`
#. §9: `P`
#. §10: `False`
#. §11: `np : ¬ P`
#. §12: `False`
#. §13: `¬ ¬ P`
#. §14: `¬ ¬ P → P`
#. §15: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Let §0 be a proposition.\n"
"\n"
"We have learned that there is a default strategy to prove §1, i.e., that §2 implies §3.\n"
"\n"
"The strategy is to start by assuming we have a proof §4, in other words, assuming that §5 is true.\n"
"\n"
"Then the goal is to derive an element of §6, also known as a *contradiction*.\n"
"\n"
"This proof strategy is fully compatible with constructive mathematics.\n"
"\n"
"There is a related, by distinct, strategy that can be used to prove a proposition §7 assuming classical logic called &ldquo;proof by contradiction&rdquo;. Here one assumes we have a proof §8, in other words, assuming that §9 is false.\n"
"\n"
"Then the goal is again to derive an element of §10, also known as a contradiction.\n"
"\n"
"Such a proof &mdash; assuming §11 and then deriving an element of §12 &mdash; constructs an element of §13.\n"
"\n"
"In classical logic, there is an implication §14, which is why &ldquo;proof by contradiction&rdquo; can be used to ultimately prove that §15 is true."
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `f a : B`
#. §3: `f`
#. §4: `a`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Given a function §0 and an element §1, there is an element §2 obtained by evaluating the function §3 at §4."
msgstr ""

#: Game
msgid "First Year Seminar 270"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Modus Tollens"
msgstr ""

#: Game
msgid "Mathematicians from all over &mdash; most of whom have never met one another &mdash; nevertheless agree to an incredible extent about the nature of the mathematical universe. How did this degree of consensus come about?\n"
"\n"
"Firstly mathematicians have developed a precise formal language which allows them to define new abstract concepts and state their properties in an unambiguous way. A mathematical *proposition* is a well-formed mathematical statement that is either true or false, for instance:\n"
"\n"
"* &ldquo;There are infinitely many prime numbers.&rdquo;\n"
"* &ldquo;Every prime number is even.&rdquo;\n"
"* &ldquo;There are infinitely many prime numbers that are two less than another prime.&rdquo;\n"
"\n"
"Mathematicians distinguish between the true propositions, the false ones, and the ones whose truth value is not yet known through *proofs* made precise in the formal language of mathematical logic.\n"
"\n"
"While the idea of a mathematical proof is over 2000 years old, the practice of proof writing continues to evolve. Today mathematicians may elect to use a tool called a computer proof assistant that can provide real-time feedback to a theorem prover about the status of a logical argument that is currently under development.\n"
"\n"
"The aim of this game will be to introduce proof writing in a computer proof assistant while developing skils that can be used to develop proofs in other contexts: on paper, in conversation with a friend, or in your head.\n"
"\n"
"There is one caveat, that we will address explicitly. The formal vocabulary we will introduce to discuss mathematical proof is somewhat different from the one that most mathematicians learn. The mathematics we will be developing is essentially unchanged but the formal language introduced here will make it easier to be fully precise about every step in a proof, as is required to convince a computer that a logical argument in sound."
msgstr ""
