msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-28\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `p`
#. ยง4: `P`
#. ยง5: `h1`
#. ยง6: `P โ Q`
#. ยง7: `h2`
#. ยง8: `Q โ R`
#. ยง9: `R`
#. ยง10: `Show more help!`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "Now we are in the setting of three proposition variables ยง0, ยง1, and ยง2 with several hypotheses.\n"
"\n"
"The first assumption provides a proof ยง3 that the proposition ยง4 is true.\n"
"\n"
"The second provides a proof ยง5 that the implication ยง6 is true.\n"
"\n"
"The final hypothesis provides a proof ยง7 that ยง8 is true. Our goal is to conclude that ยง9 is true.\n"
"\n"
"If you need help, click the button ยง10 for reminders/hints."
msgstr ""

#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Universal property"
msgstr ""

#. ยง0: `Empty.elim`
#. ยง1: `Prod.snd`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "If your answer does not use the functions ยง0 and ยง1, you might have fun trying to solve this level again using them in appropriate places."
msgstr ""

#. ยง0: `B ร D โ M`
#. ยง1: `E โ Y ร N`
#. ยง2: `A โ M โ X`
#. ยง3: `C โ N โ Z`
#. ยง4: `A ร B ร C ร D ร E`
#. ยง5: `X ร Y ร Z`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Given functions of types ยง0, ยง1, ยง2, and ยง3, there is a function from the product type ยง4 to the product type ยง5."
msgstr ""

#. ยง0: `ยซ{P}ยป โ ยซ{P}ยป`
#. ยง1: `intro p`
#. ยง2: `p : ยซ{P}ยป`
#. ยง3: `ยซ{P}ยป`
#. ยง4: `intro`
#. ยง5: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "When the goal has the form ยง0, type ยง1 to introduce an assumption ยง2 and update the goal to ยง3.\n"
"\n"
"It is also possible to type simply ยง4 in which case Lean will automatically generate a name for the proof of ยง5."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Disjunction Boss Level"
msgstr ""

#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now we're ready for the boss level."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Prod.snd : A ร B โ B`
#. ยง3: `p : A ร B`
#. ยง4: `p.2 : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "For any types ยง0 and ยง1, ยง2 is the function that sends ยง3 to its second coordinate ยง4."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `f : A โ B`
#. ยง2: `f a : B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "Define the *evaluation* function that takes ยง0 and ยง1 to ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A ร B โ B ร A`
#. ยง3: `โจa, bโฉ`
#. ยง4: `โจb, aโฉ`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "For types ยง0 and ยง1, the swapping function has type ยง2 and can be thought of as the function that sends a pair ยง3 to the pair ยง4."
msgstr ""

#. ยง0: `P`
#. ยง1: `R โ S โง T`
#. ยง2: `U โ P โ R`
#. ยง3: `(U โ Y) โ Z`
#. ยง4: `W โง T โง V โ X โง Y`
#. ยง5: `S โ V โง W`
#. ยง6: `Z`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "If ยง0, ยง1, ยง2, ยง3, ยง4, and ยง5 are true, then ยง6 is true."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `ยฌ ยฌ ยฌ P โ ยฌ P`
#. ยง4: `P`
#. ยง5: `ยฌ P`
#. ยง6: `ยฌ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "This level contains another tautology whose proof you have seen before.\n"
"\n"
"We will show that for any proposition ยง0, if ยง1 is not not false, then ยง2 is false.\n"
"\n"
"That is, we will prove ยง3.\n"
"\n"
"In fact, for any proposition ยง4, its negation ยง5 and its triple negation ยง6 are logically equivalent.\n"
"\n"
"So we will prove this too."
msgstr ""

#. ยง0: `f : X โ A ร B`
#. ยง1: `fun x โฆ (f x).1 : X โ A`
#. ยง2: `fun x โฆ (f x).2 : X โ B`
#. ยง3: `g : X โ A`
#. ยง4: `h : X โ B`
#. ยง5: `X`
#. ยง6: `X โ A ร B`
#. ยง7: `g`
#. ยง8: `h`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "We've seen that functions ยง0 into product types can be decomposed into component functions ยง1 and ยง2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions.\n"
"\n"
"To that end consider an arbitrary pair of functions ยง3 and ยง4 that have the same domain type ยง5 but are otherwise unrelated.\n"
"\n"
"These functions can be combined to define a single function of type ยง6 whose component functions are defined by ยง7 and ยง8, respectively."
msgstr ""

#. ยง0: `ยฌ Q`
#. ยง1: `Q โ False`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that ยง0 is an abbreviation for the type ยง1."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "On Parentheses"
msgstr ""

#. ยง0: `swap`
#. ยง1: `unfold swap`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "This is true by definition, but Lean does not necessarily recall how ยง0 was defined. Type ยง1 to unfold this definition."
msgstr ""

#. ยง0: `f : X โ A ร B`
#. ยง1: `fun x โฆ (f x).1 : X โ A`
#. ยง2: `fun x โฆ (f x).2 : X โ B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that functions ยง0 into product types can be decomposed into component functions ยง1 and ยง2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `A โ C`
#. ยง2: `B โ C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "A function of type ยง0 may be split into component functions of types ยง1 and ยง2."
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "Absurd"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `a : A`
#. ยง4: `A โ B`
#. ยง5: `Sum.inl : A โ A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "For types ยง0 and ยง1, the coproduct type ยง2 has two kinds of elements. The first kind can be thought of as copies of elements ยง3 included into the coproduct ยง4 *on the left*.\n"
"\n"
"Lean has a built in function called ยง5."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A ร B) ร C`
#. ยง4: `A ร (B ร C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Product types are associative: for types ยง0, ยง1, and ยง2, there are canonical functions in each direction between the types ยง3 and ยง4."
msgstr ""

#. ยง0: `(P โ Q) โง (P โ R)`
#. ยง1: `P โ Q โง R`
#. ยง2: `P โ (Q โง R)`
#. ยง3: `S`
#. ยง4: `T`
#. ยง5: `S โ (S โ T) โ T`
#. ยง6: `s : S`
#. ยง7: `h : S โ T`
#. ยง8: `T`
#. ยง9: `h`
#. ยง10: `S`
#. ยง11: `s`
#. ยง12: `h s : T`
#. ยง13: `h`
#. ยง14: `s`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "The task in this level is to show another logical equivalence,\n"
"this time between the conjoined implications ยง0 and the implication ยง1, which is implicitly parenthesized as ยง2.\n"
"\n"
"The proof will require an idea that we have not used for a while. We've seen that for propositions ยง3 and ยง4,\n"
"ยง5 can be proven by introducing hypotheses ยง6 and ยง7, at which point the goal is to prove ยง8.\n"
"Then applying the hypothesis ยง9 reduces the goal to proving ยง10 which we know is true by ยง11.\n"
"\n"
"Recall there is special notation\n"
"ยง12 for the proof constructed by applying the hypothesis ยง13 to the hypothesis ยง14.\n"
"\n"
"The intuition behind this notation will be explained in the next world."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Now the goal is to prove ยง0 using *any* of our given hypotheses. Which tactic can be used to supply this proof?"
msgstr ""

#. ยง0: `โจ`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โจ Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โจ Q`
#. ยง7: `P โจ Q`
#. ยง8: `P โจ Q`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `P`
#. ยง12: `Q`
#. ยง13: `P โจ Q`
#. ยง14: `h : P โจ Q`
#: Game.Levels.DisjunctionWorld
msgid "The logical connective of *disjunction*, denoted by ยง0, is the mathematical version of *or*.\n"
"\n"
"For arbitrary propositions ยง1 and ยง2, ยง3 is a new proposition asserting that at least one of ยง4 *or* ยง5 *are true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง6.\n"
"* How to use a hypothesis of the form ยง7 to prove something else.\n"
"\n"
"There are two strategies to prove ยง8. It suffices to supply a proof of ยง9 and it also suffices to supply a proof of ยง10.\n"
"\n"
"Note that the mathematical &ldquo;or&rdquo; is *inclusive*, meaning that if ยง11 and ยง12 are both true, then ยง13 is true.\n"
"\n"
"Using a hypothesis ยง14 leads to a proof strategy of arguing &ldquo;by cases&rdquo; as we will soon discover."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What sort of type does ยง0 belong to? Can we extract other elements from an element of this type?"
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "The goal is a function type. What tactic can be used to define an element?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What is the outermost logical connective?"
msgstr ""

#. ยง0: `(P โง R) โจ ((P โง S) โจ ((Q โง R) โจ (Q โง S)))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "The implicit parentheses in the goal are to the right ยง0."
msgstr ""

#. ยง0: `ext a b`
#. ยง1: `(swap (swap f)) a b = f a b`
#. ยง2: `a : A`
#. ยง3: `b : B`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Type ยง0 to reduce to the problem of proving that ยง1 for generic elements ยง2 and ยง3."
msgstr ""

#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Which function might be useful to apply here?"
msgstr ""

#. ยง0: `.1`
#. ยง1: `.2`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Note the ยง0 and ยง1 notation can be iterated."
msgstr ""

#. ยง0: `Boss Level`
#. ยง1: `have`
#. ยง2: `have`
#. ยง3: `p : P`
#. ยง4: `h : P โ Q`
#. ยง5: `have q : Q := h p`
#. ยง6: `q : Q`
#. ยง7: `h p`
#. ยง8: `</>`
#. ยง9: `editor mode`
#. ยง10: `>_`
#. ยง11: `typewriter mode`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Each world will end with a ยง0, which is intended to be more challenging than the levels that came before. Have fun with this.\n"
"\n"
"While it is not necessary to solve this level, you may enjoy experimenting with the new ยง1 tactic that is now added to the tactic library.\n"
"\n"
"The ยง2 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions ยง3 and ยง4, type ยง5 to add a proof ยง6 defined by ยง7.\n"
"\n"
"To delete a proof (or proof attempt) and start over click on the button labelled ยง8 in the upper right hand corner to enter ยง9. Then delete all the lines of your first proof (or proof attempt). Clicking on ยง10 takes you back to ยง11."
msgstr ""

#. ยง0: `ยซ{pnq}ยป`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What can we prove with the hypothesis ยง0?"
msgstr ""

#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Composition revisited"
msgstr ""

#. ยง0: `A`
#. ยง1: `a : A`
#. ยง2: `a = a`
#. ยง3: `rfl : a = a`
#. ยง4: `rfl`
#. ยง5: `a = a`
#. ยง6: `a = a`
#. ยง7: `exact rfl`
#. ยง8: `rfl`
#. ยง9: `exact rfl`
#. ยง10: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Let ยง0 be a type with an element ยง1. Then the proposition ยง2 is always true\n"
"because there is a proof ยง3 witnessing the *reflexivity* of equality.\n"
"\n"
"In Lean, ยง4 is a name for an element of the type ยง5. So to produce a proof of ยง6, you\n"
"can type ยง7. As a shorthand, Lean also defines a tactic called ยง8 that is shorthand for\n"
"ยง9. So you can solve the goal by typing simply ยง10."
msgstr ""

#. ยง0: `intro h1 h2 h3`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Multiple hypothesis can be introduced at once by writing ยง0 etc. You might consider using names that will help you remember which propositions each hypothesis proves!"
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition ยง0, ยง1."
msgstr ""

#. ยง0: `ยซ{andn}ยป`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What proofs can you extract from the hypothesis ยง0?"
msgstr ""

#. ยง0: `A`
#. ยง1: `A โ Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "In summary, something very strange happens if the types ยง0 and ยง1 both have elements."
msgstr ""

#. ยง0: `ยซ{f}ยป : A โ Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "We have an assumption ยง0. What can be done with an element of a function type?"
msgstr ""

#. ยง0: `Active Goal`
#. ยง1: `objects`
#. ยง2: `assumptions`
#. ยง3: `goal`
#. ยง4: `P`
#. ยง5: `p : P`
#. ยง6: `p`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `assumption`
#. ยง10: `p`
#. ยง11: `exact p`
#. ยง12: `assumption`
#. ยง13: `exact`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "An interative theorem prover &mdash; in this case Lean &mdash; helps the user &mdash; this means you &mdash; keep track of the state of a proof.\n"
"\n"
"In the ยง0 window, Lean keeps track of the ยง1 and ยง2 &mdash; which together define the hypotheses of a mathematical statement &mdash; as well as the ยง3 &mdash; meaning the thing we are trying to prove.\n"
"\n"
"Our first mathematical theorem is about an arbitrary proposition ยง4 which can be any well-formed mathematical statement.\n"
"\n"
"The hypothesis ยง5  can be thought of as providing a *proof* ยง6 that the proposition ยง7 is true. Our objective is to conclude that ยง8 is true, given this hypothesis.\n"
"\n"
"This is true by assumption, and you can type ยง9 to tell Lean this.\n"
"\n"
"But it is a bit more precise to tell Lean this is true by the assumption ยง10 which can be done by typing ยง11.\n"
"\n"
"Note both ยง12 and ยง13 are *tactics* that are built into Lean. You can now find them in the tactic library on the upper right."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Second Projection"
msgstr ""

#. ยง0: `swap`
#. ยง1: `f : A โ B โ C`
#. ยง2: `swap f : B โ A โ C`
#. ยง3: `b : B`
#. ยง4: `a : A`
#. ยง5: `f a b : C`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "The ยง0 function exchanges the inputs of a function of two variables. For a function with two variables ยง1, ยง2 is the function that sends ยง3 and ยง4 to ยง5."
msgstr ""

#. ยง0: `โ`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the ยง0 is the outermost logical connective. If you've forgotten what this means, you can look it up in the library."
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Using Functions"
msgstr ""

#. ยง0: `ยซ{f}ยป.1`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What type does ยง0 belong to? Is this useful?"
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Currying"
msgstr ""

#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "From a function of two variables, define another function of two variables, where the inputs are swapped."
msgstr ""

#. ยง0: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Now that you are stuck, it is a good time to try classical reasoning. Try ยง0 and see how this transforms the goal."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does either proof in this logical equivalence seem familiar? Do they both seem familar?"
msgstr ""

#. ยง0: `False`
#. ยง1: `P`
#. ยง2: `False โ P`
#. ยง3: `False`
#. ยง4: `Empty`
#. ยง5: `False`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The proposition ยง0 has no elements &mdash; there are no proofs of &ldquo;false.&rdquo;.\n"
"\n"
"Consequently, for any other proposition ยง1, the implication ยง2 is true.\n"
"\n"
"The task in this level is to prove this.\n"
"\n"
"The proposition ยง3 is really just another name for the empty type ยง4, so the same constructions explored in Empty World can be used to prove propositions involving ยง5."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "For any proposition ยง0, ยง1 implies ยง2 is true."
msgstr ""

#. ยง0: `(P โ Q) โ R`
#. ยง1: `P โ (Q โ R)`
#. ยง2: `P โ Q โ R`
#. ยง3: `P โ (Q โ R)`
#. ยง4: `P โง Q โ R`
#. ยง5: `(P โง Q) โ R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Recall that implication is *NOT* associative: the propositions ยง0 and ยง1 are not logically equivalent, and ยง2 is an abbreviation for the former.\n"
"\n"
"One reason that mathematical statements of the form ยง3 are more prevalent is that this is implied by ยง4, which is implicitly parenthesized as ยง5."
msgstr ""

#. ยง0: `x : A โ B`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "We'll now study how hypothesis ยง0 can be used."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `โ : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง4: `C`
#. ยง5: `โ : (B โ Empty) โ (A โ B) โ (A โ Empty)`
#. ยง6: `(A โ B) โ (B โ Empty) โ (A โ Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "In this level, we will revisit the composition function in the presence of the empty type.\n"
"\n"
"Recall that for any types ยง0, ยง1, and ยง2, composition defines a function:\n"
"\n"
"ยง3.\n"
"\n"
"In particular, if ยง4 is the empty type, composition defines a function:\n"
"\n"
"ยง5.\n"
"\n"
"Your task in this level is to define the closely related variant of the composition function which has type:\n"
"\n"
"ยง6\n"
"\n"
"as this construction will be analogous to something we will encounter in the next world."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "If this is not the term you want, how can you use it to define the correct term?"
msgstr ""

#. ยง0: `A`
#. ยง1: `a b : A`
#. ยง2: `a = b`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `P`
#. ยง6: `a = b`
#. ยง7: `a = b`
#. ยง8: `p : a = b`
#. ยง9: `a`
#. ยง10: `b`
#. ยง11: `A`
#. ยง12: `2 + 2 = 4`
#. ยง13: `2 + 2 4 : โ`
#. ยง14: `0 = 1`
#. ยง15: `0 1 : โ`
#. ยง16: `0 = 1`
#: Game.Levels.EqualityWorld
msgid "Consider a type ยง0. For any two elements ยง1 there is a proposition ยง2\n"
"that encodes the mathematical assertion that ยง3 and ยง4 are *equal*.\n"
"\n"
"Like with generic propositions ยง5, the proposition ยง6 is not necessarily *true*. To prove that\n"
"ยง7 is true, we must construct an element ยง8 which can be thought of as a *proof* that\n"
"ยง9 equals ยง10 as elements of type ยง11. For example: ยง12 is true for elements ยง13. In a few levels, we will construct a proof of this. But the proposition ยง14 is false, again for\n"
"ยง15. In a later level, we'll see how to prove its *negation*, in other words that ยง16 is\n"
"false."
msgstr ""

#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Contrapositive"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `f : A โ Empty`
#. ยง3: `A โ B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "For any types ยง0 and ยง1, if there is a function ยง2 then there is also a function ยง3."
msgstr ""

#. ยง0: `ยฌ (P โจ Q)`
#. ยง1: `P โจ Q`
#. ยง2: `P โจ Q`
#. ยง3: `P`
#. ยง4: `P โจ Q`
#. ยง5: `Q`
#. ยง6: `P โจ Q`
#. ยง7: `P โจ Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `ยฌ (P โจ Q)`
#. ยง11: `ยฌ P โง ยฌ Q`
#. ยง12: `โ`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"Recall, if ยง3 is true, then we can prove ยง4. Similarly, if ยง5 is true, we can prove ยง6.\n"
"\n"
"So if ยง7 is false, then both ยง8 and ยง9 must be false.\n"
"\n"
"In this level, we will show that ยง10 is logically equivalent to ยง11.\n"
"\n"
"If you have forgotten the meaning of logical equivalence, denoted ยง12, you can look it up in the library."
msgstr ""

#. ยง0: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Now Lean reminds you of the other goal, which is to prove ยง0. Which tactic applies here?"
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Negating Implication"
msgstr ""

#. ยง0: `ยฌ P โจ ยฌ Q`
#. ยง1: `ยฌ (P โง Q)`
#. ยง2: `ยฌ (P โง Q)`
#. ยง3: `ยฌ P โจ ยฌ Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โจ ยฌ P`
#. ยง7: `have := em P`
#. ยง8: `P โจ ยฌ P`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "We have seen that ยง0 implies ยง1.\n"
"\n"
"But we were not able to prove constructively that ยง2 implies ยง3, since we cannot tell whether ยง4 or ยง5 is the false proposition.\n"
"\n"
"However, we can prove this using classical logic.\n"
"\n"
"Recall that in classical logic, we may assume the *law of excluded middle*, i.e., that ยง6 is true for any proposition.\n"
"\n"
"In particular, in the middle of your proof, you can type ยง7 to introduce ยง8 as a hypothesis.\n"
"\n"
"Can you use this to prove the desired implication?"
msgstr ""

#. ยง0: `Prod.snd : A ร B โ B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"In the next level, we'll use the projection functions to prove symmetry of product types."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What is the logical form of the goal?"
msgstr ""

#. ยง0: `assumption`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "You can solve the goal by explicitly referring to the named hypothesis that Lean supplied or by typing ยง0 to indicate that the goal matches an assumption."
msgstr ""

#. ยง0: `โจ`
#. ยง1: `P โง R`
#. ยง2: `(P โง S) โจ ((Q โง R) โจ (Q โง S))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Thus the outermost logical connective is the ยง0 combining ยง1 and ยง2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Do you see how this relates to the previous level?"
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `(P โง Q) โจ (P โง R)`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Conjunction distributes over disjunction: ยง0 and ยง1 are logically equivalent."
msgstr ""

#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "Composing Implication"
msgstr ""

#. ยง0: `ยซ{i}ยป`
#. ยง1: `ยซ{nq}ยป`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "What can you prove using ยง0 and ยง1?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "Currying Implication"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โง Q`
#. ยง3: `P โง ยฌ Q`
#. ยง4: `ยฌ P โง Q`
#. ยง5: `ยฌ P and ยฌ Q`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "In classical logic, for any propositions ยง0 and ยง1, ยง2 is true or ยง3 is true or ยง4 is true or ยง5 is true."
msgstr ""

#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Swapping inputs"
msgstr ""

#. ยง0: `ยซ{p}ยป : P`
#. ยง1: `ยฌ Q`
#. ยง2: `apply Or.inr`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Because  ยง0, it is clear that the strategy is to try to prove ยง1. You can focus on this goal by ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โจ ยฌ P`
#. ยง2: `ยฌ ยฌ P โ P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The law of excluded middle implies double negation elimination: for any proposition ยง0, ยง1 implies ยง2."
msgstr ""

#. ยง0: `e : E`
#. ยง1: `E`
#. ยง2: `exact e`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If there is an assumption ยง0 and the goal has type ยง1, then ยง2 closes the goal."
msgstr ""

#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Reflexivity"
msgstr ""

#. ยง0: `(P โจ Q) โจ R`
#. ยง1: `P โจ (Q โจ R)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Or is associative: ยง0 is true if and only if ยง1 is true."
msgstr ""

#: Game.Levels.FunctionWorld
msgid "Function World"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `ยฌ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "For any proposition ยง0, ยง1 is logically equivalent to ยง2."
msgstr ""

#. ยง0: `h : P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `h.1 : P`
#. ยง4: `h.2 : Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "A hypothesis ยง0 provides explicit proofs of both ยง1 and ยง2 which are denoted in Lean by ยง3 and ยง4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Can we apply our hypothesis now?"
msgstr ""

#. ยง0: `f : A ร B โ C`
#. ยง1: `a : A`
#. ยง2: `b : B`
#. ยง3: `C`
#. ยง4: `f โจa,bโฉ`
#. ยง5: `g : A โ B โ C`
#. ยง6: `g`
#. ยง7: `a : A`
#. ยง8: `b : B`
#. ยง9: `C`
#. ยง10: `g a b : C`
#. ยง11: `A ร B โ C`
#. ยง12: `A โ B โ C`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `C`
#. ยง16: `f : A ร B โ C`
#. ยง17: `โจa, bโฉ : A ร B`
#. ยง18: `C`
#. ยง19: `g : A โ B โ C`
#. ยง20: `a : A`
#. ยง21: `g a : B โ C`
#. ยง22: `b : B`
#. ยง23: `C`
#. ยง24: `A ร B โ C`
#. ยง25: `A โ B โ C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Consider a function ยง0 mapping out of a product type.\n"
"\n"
"This function takes an ordered pair of elements &mdash; defined from ยง1 and ยง2 &mdash; and returns an element of type ยง3 denoted by ยง4. Does this sound familiar?\n"
"\n"
"Recall that terms of type ยง5 aree functions of two variables.\n"
"\n"
"The function ยง6 takes a list of two elements ยง7 and ยง8 and returns an element of type ยง9 denoted by ยง10.\n"
"\n"
"In summary, the types ยง11 and ยง12 both provide a notion of function of two variables, with inputs from the types ยง13 and ยง14 and output in the type ยง15.\n"
"\n"
"The difference is that ยง16 is thought of as a function that takes a pair ยง17 to an element of type ยง18, while ยง19 is thought of as a function that takes ยง20 to a function ยง21 (which then takes ยง22 to an element of type ยง23).\n"
"\n"
"The process of converting a function of type ยง24 to one of type ยง25 is called *currying* and is defined by the function below."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L06_SwappingInputs
#: Game.Levels.FunctionWorld.L08_Evaluation
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "When in doubt, start defining a function by using the tactic ยง0 followed by your preferred variable name."
msgstr ""

#. ยง0: `rcases`
#. ยง1: `h : (P โจ Q) โจ R`
#. ยง2: `rcases h with (p | q) | r`
#. ยง3: `k : P โจ Q โจ R`
#. ยง4: `rcases k with p | q | r`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "This proves the associativity of disjunction.\n"
"\n"
"Note the ยง0 tactic allows more general patterns of disjunctions. Given ยง1 try ยง2. Similarly, given ยง3, try ยง4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Compound Implication"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{C}ยป`
#. ยง2: `intro x`
#. ยง3: `ยซ{A}ยป`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "To define a function from ยง0 to ยง1, type ยง2 to introduce an\n"
"arbitrary element of type ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `comp : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง4: `f : A โ B`
#. ยง5: `g : B โ C`
#. ยง6: `comp g f : A โ C`
#. ยง7: `a : A`
#. ยง8: `g (f a) : C`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "For types ยง0, ยง1, and ยง2, the function ยง3 takes a function ยง4 and a function ยง5 to the composite function ยง6 defined to take ยง7 to the element ยง8."
msgstr ""

#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Move on to Disjunction World to learn about another logical operation."
msgstr ""

#. ยง0: `ยซ{nnnp}ยป`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What can you do with hypothesis ยง0?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "Introducing Or"
msgstr ""

#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Identity Function"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
#: Game.Levels.ImplicationWorld.L07_OnParentheses
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "As the goal is to prove an implication, the tactic ยง0 can be used to introduce a hypothesis and update the goal. Before using this tactic, try to figure out which hypothesis will be assumed and what the goal will be, using the discussion about the implicit parenthesization above."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does this goal seem familiar? If not, it's okay to just follow your nose and let the logical structure guide you."
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "The lesson of this level is to pay attention to the big picture, namely what exactly you are being asked ot prove under what hypotheses."
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{P}ยป โจ ยซ{Q}ยป`
#. ยง1: `cases h`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "After introducing the hypothesis ยง0, type ยง1 to ask Lean to consider both cases: the first being that ยง2 is true and the second being that ยง3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way."
msgstr ""

#. ยง0: `S`
#. ยง1: `s : S`
#. ยง2: `exact s`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "If the goal is to prove ยง0 and we have a hypothesis ยง1, the tactic ยง2 supplies the required proof."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "ยง0 implies ยง1."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Triple Negation"
msgstr ""

#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "Constant functions"
msgstr ""

#. ยง0: `ยฌ P`
#. ยง1: `P`
#. ยง2: `P โ False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "ยง0, read as &ldquo; not ยง1&rdquo; is an abbreviation for ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A โ B) โ C`
#. ยง4: `A โ (B โ C)`
#. ยง5: `A โ B โ C`
#. ยง6: `a : A`
#. ยง7: `b : B`
#. ยง8: `c : C`
#. ยง9: `b : B`
#. ยง10: `Sum.inl (Sum.inr b) : (A โ B) โ C`
#. ยง11: `Sum.inr (Sum.inl b) : A โ (B โ C)`
#. ยง12: `((A โ B) โ C) โ (A โ (B โ C))`
#. ยง13: `(A โ (B โ C)) โ ((A โ B) โ C)`
#. ยง14: `(((A โ B) โ C) โ (A โ (B โ C))) ร ((A โ (B โ C)) โ ((A โ B) โ C))`
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Given three types ยง0, ยง1, and ยง2, the coproduct type construction may be iterated to define types ยง3 and ยง4, the latter of which is abbreviated ยง5.\n"
"\n"
"For both of these types, there are three cases of elements: those coming from ยง6, those coming from ยง7, and those coming from ยง8. The notation for the corresponding elements of the iterated coproduct type depends on the parentheses: the terms ยง9 include as ยง10 but include as ยง11.\n"
"\n"
"The objective in this level is to define a pair of functions between these types in each direction, the first of type ยง12 and the second of type ยง13. That is, define a single element of type\n"
"\n"
"ยง14"
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Using And"
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Move on to Coproduct World to learn about the type theoretic analog of the logical operation of disjunction."
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{x}ยป : ยซ{A}ยป`
#. ยง2: `ยซ{x}ยป : ยซ{A}ยป`
#. ยง3: `exact ยซ{x}ยป`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Now the goal is an element of type ยง0, which should be thought of as result of applying the function to the element ยง1. In the case of the identity function, we want to return ยง2 again which is done by typing ยง3."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Coproduct With Empty"
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Projected Pairs"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ProductWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Symmetry"
msgstr ""

#. ยง0: `apply Or.inl`
#. ยง1: `apply Or.inr`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "You have two choices: to reduce to the case of proving the left proposition or to reduce to the case of proving the right proposition. Type ยง0 to tell Lean you'd like too prove the left proposition or type ยง1 to tell Lean you'd like to prove the right proposition."
msgstr ""

#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Negating Conjunction"
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "To prove a conjunction ยง0 we need to supply a proof of both ยง1 and ยง2."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "We've now reached the Boss Level in the disjunction world.\n"
"\n"
"This level illustrates that proofs by cases can be somewhat delicate."
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "The converse implication is more subtle, and will be addressed in the next world."
msgstr ""

#. ยง0: `โ`
#. ยง1: `โค`
#. ยง2: `โ`
#. ยง3: `โ`
#. ยง4: `โ`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `P`
#. ยง8: `Q`
#. ยง9: `A`
#. ยง10: `x : A`
#. ยง11: `y : A`
#. ยง12: `P`
#. ยง13: `Q`
#. ยง14: `p : P`
#. ยง15: `q : Q`
#. ยง16: `P`
#. ยง17: `โ`
#. ยง18: `0 : โ`
#. ยง19: `1 : โ`
#. ยง20: `โ`
#. ยง21: `โง`
#. ยง22: `A โ B`
#. ยง23: `A`
#. ยง24: `B`
#. ยง25: `f : A โ B`
#. ยง26: `A`
#. ยง27: `B`
#. ยง28: `A โ B`
#. ยง29: `P โ Q`
#. ยง30: `A โ B`
#. ยง31: `A โ B`
#: Game.Levels.FunctionWorld
msgid "The slogan *propositions as types* tells us that we can consider propositions as special cases of *types*.\n"
"\n"
"For example, there are types ยง0 of\n"
"natural numbers, ยง1 of integers, ยง2 of rational numbers, ยง3 of real numbers, ยง4 of natural\n"
"numbers, and so on.\n"
"\n"
"We use capital variables like ยง5 and ยง6 to denote general types, analogously to the proposition variables ยง7 and ยง8.\n"
"\n"
"A type ยง9 can contain elements ยง10 and ยง11. For propositions ยง12 and ยง13, we thought of\n"
"elements ยง14 and ยง15 as *proofs* that these propositions are true.\n"
"\n"
"In the case of\n"
"propositions, what mattered was whether ยง16 had any elements or not. The elements themselves don't\n"
"carry any information beyond witnessing the truth of the proposition.\n"
"\n"
"By contrast, the type ยง17 of\n"
"natural numbers contains infinitely many distinct elements: ยง18, ยง19 and so on.\n"
"\n"
"Just as logical connectives like ยง20 and ยง21 can be used to build more complicated propositions out of existing propositions, *type forming operations* can be used to build new types from existing types.\n"
"\n"
"The first and arguably most important of these is the type ยง22 of functions from ยง23 to ยง24. An element\n"
"ยง25 defines a *function* from ยง26 to ยง27.\n"
"\n"
"In this level, we will explain how to define and use functions and explore the analogy suggested by the fact that we use the same notation for\n"
"function types ยง28 as for the implication proposition ยง29.\n"
"\n"
"To understand how functions work in type theory we must learn:\n"
"\n"
"* How to construct elements of type ยง30.\n"
"* How to use elements of type ยง31 to construct elements of other types."
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Now the goal is an element of a product type. How can such elements be defined?"
msgstr ""

#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Let us see what else can be proven with function extensionality."
msgstr ""

#. ยง0: `x : A ร (B โ C)`
#. ยง1: `x`
#. ยง2: `x`
#. ยง3: `โจy, zโฉ`
#. ยง4: `y : A`
#. ยง5: `z : B โ C`
#. ยง6: `z`
#. ยง7: `Sum.inl b`
#. ยง8: `b : B`
#. ยง9: `Sum.inr c`
#. ยง10: `c : C`
#. ยง11: `x : A ร (B โ C)`
#. ยง12: `โจy, Sum.inl bโฉ`
#. ยง13: `โจy, bโฉ : A ร B`
#. ยง14: `x`
#. ยง15: `โจy, Sum.inr cโฉ`
#. ยง16: `โจy, cโฉ : A ร C`
#. ยง17: `A ร (B โ C) โ (A ร B) โ (A ร C)`
#. ยง18: `(A ร B) โ (A ร C) โ A ร (B โ C)`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "How should we think about an element of type ยง0?.\n"
"\n"
"Since ยง1 belongs to a product type, it can be split into two components. That is ยง2 has the form of a pair ยง3 with ยง4 and ยง5. And since ยง6 belongs to a coproduct type, there are two possible cases: it can have the form ยง7 for some ยง8 or it can have the form ยง9 for some ยง10. In the first case, the original ยง11 is a pair of the form ยง12 coming from ยง13 which in the second case ยง14 is a pair of the form ยง15 coming from ยง16.\n"
"\n"
"This explains the *distributivity* of products over coproducts, which can be encoded by a pair of functions, one of the form ยง17 and the other of the form ยง18."
msgstr ""

#. ยง0: `S โ T`
#. ยง1: `T`
#. ยง2: `S`
#. ยง3: `S`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P`
#. ยง7: `Q โ P`
#. ยง8: `Q`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "To prove an implication ยง0 one needs to give a construction of a proof of ยง1 from a proof of ยง2. As we will see in the following example, it is not necessary to actually *use* the assumption that ยง3 is true after introducing it.\n"
"\n"
"In this level we will consider two propositions ยง4 and ยง5 and assume that the proposition ยง6 is true.\n"
"\n"
"It follows that ยง7 is true, no matter whether ยง8 is true or false."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "Now you can start to apply some hypotheses to reduce the goal to one of your assumptions. Which tactic can be used here?"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `Q โ P`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "If ยง0 is true, then for any proposition ยง1, ยง2 is always true."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "The converse implication is more subtle because if ยง0 is false we don't know which of ยง1 or ยง2 is false. This will be addressed in the next world."
msgstr ""

#. ยง0: `ยซ{h}ยป : P โ Q โง R`
#. ยง1: `ยซ{p}ยป: P`
#. ยง2: `ยซ{h}ยป ยซ{p}ยป : Q โง R`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "We can apply the proof ยง0 to the proof ยง1 to obtain ยง2. How can these be used to prove the goal?"
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Have another look at the Universal Property Level of Disjunction World. How are these statements related?"
msgstr ""

#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The objective of this Boss Level is to define a function that takes five variables as inputs and has three\n"
"variables as outputs.\n"
"\n"
"This function is defined as a composite &mdash; in a much more complicated sense than we have seen thusfar &mdash; of the given functions.\n"
"\n"
"Can you do it?"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `B`
#. ยง2: `B โ A`
#. ยง3: `a : A`
#. ยง4: `x : B`
#. ยง5: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "Given a term ยง0 and any type ยง1, there is a function of type ยง2 which is *constant* at ยง3.\n"
"\n"
"This means that for any input ยง4 the output is always the element ยง5.\n"
"\n"
"Can you figure out how to define this function?"
msgstr ""

#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "By Assumption"
msgstr ""

#: Game
msgid "Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving"
msgstr ""

#. ยง0: `cases ยซ{hpqr}ยป`
#. ยง1: `rcases ยซ{hpqr}ยป with hpq | hr`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "You can use ยง0 to split your hypothesis into cases or ยง1 to name your own variables."
msgstr ""

#. ยง0: `unfold swap`
#. ยง1: `unfold Function.swap`
#. ยง2: `(swap f) b a`
#. ยง3: `swap`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Type ยง0 or ยง1 to ask Lean to reduce ยง2 using the definition of ยง3 we provided in Function World."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `P`
#. ยง3: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "For any proposition ยง0, if ยง1 and ยง2 are both true, then we obtain a proof of ยง3."
msgstr ""

#. ยง0: `Or.inl`
#. ยง1: `Or.inr`
#. ยง2: `S โจ T`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Recall ยง0 and ยง1 refer to the left and right propositions in a disjunction ยง2."
msgstr ""

#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "Move on to Product World to meet a second type forming operation."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#. ยง3: `x : A`
#. ยง4: `g (f x)`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions ยง0 and ยง1, the *composite function* ยง2 is defined to send ยง3 to the element ยง4."
msgstr ""

#. ยง0: `exact`
#. ยง1: `apply`
#. ยง2: `intro`
#. ยง3: `intro`
#. ยง4: `exact`
#. ยง5: `apply`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "This level can be solved by starting with ยง0, starting with ยง1, or starting with ยง2. If you start with ยง3, then you can continue with ยง4 or with ยง5. If this is your first time solving this level, try to find a different solution."
msgstr ""

#. ยง0: `g : A โ C`
#. ยง1: `h : B โ C`
#. ยง2: `A โ B โ C`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Two functions ยง0 and ยง1 combine to define a single function of type ยง2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Double Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "What tactics can be used to break a goal involving conjunction into subgoals?"
msgstr ""

#. ยง0: `P`
#. ยง1: `P โจ ยฌ P โ (ยฌ ยฌ P โ P)`
#. ยง2: `ยฌ ยฌ P โ P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `P`
#. ยง6: `exact em P`
#. ยง7: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "In Negation World, we proved that for any proposition ยง0: ยง1\n"
"\n"
"In other words, we showed that the law of excluded middle implies double negation elimination.\n"
"\n"
"We now show that converse: that double negation elimination implies the law of excluded middle. More\n"
"precisely, if we assume that ยง2 for all propositions ยง3, then we can show that ยง4 for\n"
"all proposition ยง5.\n"
"\n"
"While the proof will feel like an application of classical logic, using the strategy of proof by contradiction, in\n"
"fact the proof can be understood as a proof in constructive mathematics.\n"
"\n"
"This is because we are arguing under the assumption that double negation elimination holds, which means\n"
"we are working in a setting where the strategy of proof by contradiction applies.\n"
"\n"
"You can solve this level immediately with ยง6 but try starting with ยง7 instead and see if you can argue without appealing to the law of excluded middle."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โ Q) โ R`
#. ยง4: `P โ (Q โ R)`
#. ยง5: `R`
#. ยง6: `P โ Q`
#. ยง7: `Q โ R`
#. ยง8: `P`
#. ยง9: `R`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `P โ (Q โ R)`
#. ยง13: `P โ Q โ R`
#. ยง14: `P โ (Q โ R)`
#. ยง15: `P โ Q โ R โ S โ T`
#. ยง16: `P โ (Q โ (R โ (S โ T)))`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "For propositions ยง0, ยง1, and ยง2, the propositions ยง3 and ยง4 are not the same.\n"
"\n"
"The first asserts that ยง5 is true assuming ยง6. The second asserts that ยง7 is true assuming ยง8, or equivalently, that ยง9 is true assuming ยง10 and also assuming ยง11.\n"
"\n"
"Mathematical statements of this second form ยง12 are much more common. Thus the shorthand ยง13 implicitly refers to ยง14, not to the other parenthesization.\n"
"\n"
"More generally, ยง15 refers to ยง16.\n"
"\n"
"Explicit parentheses must be used to express statements with any other parenthesizations."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a function type, so start with ยง0."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "For the boss level, your task is to:\n"
"\n"
"* break apart a function from a coproduct type into a product type into four separate component functions and\n"
"\n"
"* then reassemble four component functions to a single function from a coproduct type into a product type.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `(P โ Q) โง (Q โ P)`
#. ยง9: `P โ Q`
#. ยง10: `(P โ Q) โง (Q โ P)`
#. ยง11: `โ`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Two propositions ยง0 and ยง1 are *logically equivalent* if ยง2 implies ยง3 and ยง4 also implies ยง5.\n"
"\n"
"The assertion that ยง6 and ยง7 are logically equivalent can be expressed by the compound proposition ยง8.\n"
"\n"
"Because this notion will appear frequently in what follows, we introduce ยง9 as a useful shorthand for ยง10.\n"
"\n"
"See the library of definitions to the right for a reminder about what the symbol ยง11 means.\n"
"\n"
"The notion of logical equivalence enables us to upgrade our understanding of associativity of symmetry as follows."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `P โ Q โ R โ S โ T`
#. ยง1: `intro p q r s`
#. ยง2: `p : P`
#. ยง3: `q : Q`
#. ยง4: `r : R`
#. ยง5: `s : S`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "For compound implications &mdash; statements of the form ยง0 &mdash; you can type ยง1 to introduce hypothesis ยง2, ยง3, ยง4, and ยง5 all at once."
msgstr ""

#. ยง0: `P โ ยฌ ยฌ P`
#. ยง1: `(P โ Q) โ (ยฌ Q โ ยฌ P)`
#. ยง2: `ยฌ P โจ ยฌ Q โ ยฌ (P โง Q)`
#. ยง3: `(P โง ยฌ Q) โ ยฌ (P โ Q)`
#. ยง4: `P โจ Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P`
#. ยง8: `P โจ ยฌ P`
#. ยง9: `P โจ ยฌ P`
#. ยง10: `P`
#. ยง11: `P`
#. ยง12: `P`
#. ยง13: `ยฌ ยฌ P โ P`
#. ยง14: `P`
#. ยง15: `ยฌ ยฌ P โ P`
#. ยง16: `P`
#. ยง17: `ยฌ P`
#. ยง18: `ยฌ P`
#. ยง19: `ยฌ ยฌ P`
#. ยง20: `ยฌ ยฌ P โ P`
#. ยง21: `ยฌ ยฌ P`
#. ยง22: `P`
#: Game.Levels.ClassicalWorld
msgid "In Negation World, we proved various tautologies involving negation such as\n"
"\n"
"* ยง0\n"
"* ยง1\n"
"* ยง2\n"
"* ยง3\n"
"\n"
"But we were not able to prove the converses of any of these implications. Why not?\n"
"\n"
"The reason is that all of the proofs we have given thusfar involve explicit constructive arguments. For example, whenever we proved that a disjunction ยง4 held under certain hypotheses, our proof gave the information of *which* of the propositions ยง5 and ยง6 is true.\n"
"\n"
"In this world, we study *classical mathematics*, which assumes two additional axioms, each of which permits new proof techniques.\n"
"\n"
"The first axiom, called the *law of excluded middle*, asserts that for any proposition ยง7, ยง8 is true.\n"
"\n"
"This permits the strategy of proof by cases. Under the assumption that ยง9 is true, you can split the argument into two cases, one assuming ยง10 is true and the other assuming ยง11 is false.\n"
"\n"
"The other axiom, called *double negation elimination*, asserts that for any proposition ยง12, ยง13 is true.\n"
"\n"
"This permits a proof strategy called *proof by contradiction*. If the goal is to prove ยง14 we can use the assumption ยง15 to reason as follows:\n"
"\n"
"* First assume that ยง16 is false, so ยง17 is true.\n"
"* Then use the assumption ยง18 to derive a contradiction, thus constructing a proof of ยง19.\n"
"* Finally, apply the implication ยง20 to convert the proof of ยง21 into a proof of ยง22.\n"
"\n"
"In fact, the law of exluded middle and double negation elimination are equivalent &mdash; even constructively &mdash; as we will show in the Boss Level of this world."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `f`
#. ยง3: `a`
#. ยง4: `f a : B`
#. ยง5: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Given a function ยง0 and any element ยง1. You can apply the function ยง2 to ยง3 to obtain an element ยง4 of type ยง5."
msgstr ""

#. ยง0: `fun x โฆ a`
#. ยง1: `x : B`
#. ยง2: `a : A`
#. ยง3: `fun _ โฆ a`
#. ยง4: `exact fun _ โฆ a`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "The formula for the constant function is ยง0. In other words, given any input ยง1, the output is always the specified term ยง2. Since the formula for the output does not depend on the input term, this can also be written as ยง3, so try solving this level with ยง4"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Modus Ponens"
msgstr ""

#. ยง0: `have pq : P โจ Q := ยซ{h}ยป.1`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Try ยง0."
msgstr ""

#. ยง0: `V`
#. ยง1: `F`
#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "For the function Boss Level, we consider an arbitrary pair of types, which we call ยง0 and ยง1 &mdash; for *vector space* and *field* respectively &mdash; because the function to be defined below has a connection to linear algebra that is not explained here.\n"
"\n"
"Can you define it?"
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `ยซ{p}ยป : ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "Now the goal is to prove ยง0 assuming ยง1. Which tactic can be used to supply this proof?"
msgstr ""

#. ยง0: `Prod.fst : A ร B โ A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `p.1 : A`
#. ยง2: `p.2 : B`
#. ยง3: `โจp.1, p.2โฉ : A ร B`
#. ยง4: `p`
#. ยง5: `โจp.1, p.2โฉ`
#. ยง6: `A ร B`
#. ยง7: `p = โจp.1, p.2โฉ`
#. ยง8: `x = y`
#. ยง9: `x`
#. ยง10: `y`
#. ยง11: `p = โจp.1, p.2โฉ`
#. ยง12: `rfl : p = โจp.1, p.2โฉ`
#. ยง13: `p.fst`
#. ยง14: `p.snd`
#. ยง15: `p.1`
#. ยง16: `p.2`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Consider an element in a product type ยง0. Using the projections, we obtain terms\n"
"ยง1 and ยง2. These can then be paired back to form an element ยง3 in the product type.\n"
"\n"
"What is the relationship between ยง4 and ยง5?\n"
"\n"
"Firstly, both of these are elements of the same type, namely ยง6. Thus, there is a mathematically meaningful proposition\n"
"ยง7 because in general it makes mathematical sense to ask whether ยง8 whenever ยง9 and ยง10 are both terms belonging to the same type.\n"
"\n"
"In this case one of the *computation rules* for product types tells us that the proposition\n"
" ยง11 is true, essentially by definition of the projection and pairing functions associated to products. Thus the proof is again by reflexivity and we have ยง12.\n"
"\n"
"Note Lean uses ยง13 and ยง14 as synomyms for ยง15 and ยง16 respectively."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "We are now ready for the Boss Level of Disjunction World."
msgstr ""

#. ยง0: `A`
#. ยง1: `id : A โ A`
#. ยง2: `a : A`
#. ยง3: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type ยง0, ยง1 is the function defined by sending ยง2 to ยง3."
msgstr ""

#. ยง0: `A ร B โ B ร A`
#. ยง1: `p : A ร B`
#. ยง2: `p.1 : A`
#. ยง3: `p.2 : B`
#. ยง4: `B ร A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The product type comes with function of type ยง0 which swaps the elements of an ordered pair.\n"
"\n"
"The swap function can be defined by introducing a variable ยง1, projecting to its components ยง2 and ยง3, then reassembling these to give an element of type ยง4."
msgstr ""

#. ยง0: `have p : P := ยซ{pnq}ยป.1`
#. ยง1: `P`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try ยง0 to add a proof of ยง1 to your assumptions."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `A ร B`
#. ยง3: `โจa , bโฉ : A ร B`
#. ยง4: `a : A`
#. ยง5: `b : B`
#. ยง6: `exact โจa,bโฉ' using '\\<' and '\\>' to type the angle brackets; note the spacing around the angle brackets and the commas is not important.
#. 
#. Alternatively, you can apply the `
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Given an element ยง0 and an element ยง1 there is a corresponding element of the product type ยง2 that is denoted by ยง3.\n"
"\n"
"This element should be thought of as an *ordered pair* whose first component is the element ยง4 and whose second element is the element ยง5.\n"
"\n"
"This can be input directly by typing ยง6constructor` tactic which allows you to first input the first component and then input the second component."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a product type, so ยง0 can be used to break the goal into pieces."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P`
#. ยง2: `P โ ยฌ ยฌ P`
#. ยง3: `P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The *double negation* of a proposition ยง0 is the proposition ยง1.\n"
"\n"
"In this level, we reinterpret the construction of the previous level, as a proof that ยง2 is always true, no matter whether or not ยง3 is true."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `And.curry`
#. ยง4: `P โง Q โ R`
#. ยง5: `P โ Q โ R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "For propositions ยง0, ยง1, and ยง2, ยง3 is a proof that ยง4 implies ยง5."
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#. ยง1: `rcases ยซ{p}ยป with x | c`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Now use ยง0 or ยง1 or similar to give your own variable names."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `Function.uncurry : (A โ B โ C) โ (A ร B โ C)`
#. ยง4: `f : A โ B โ C`
#. ยง5: `p : A ร B`
#. ยง6: `f p.1 p.2 : C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "For any types ยง0, ยง1, and ยง2, ยง3 is the function that sends ยง4 to the function that sends ยง5 to ยง6."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "More Distributivity"
msgstr ""

#. ยง0: `Function World`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "Next move on to ยง0 to learn about types and functions."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "If ยง0 is true, then if ยง1 is true, then ยง2 is true."
msgstr ""

#. ยง0: `((((V โ F) โ F) โ F) โ F)`
#. ยง1: `(V โ F) โ F`
#: Game.Levels.FunctionWorld.L09_BossLevel
msgid "Given a function of type ยง0 there is a canonically defined function of type ยง1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
msgid "Are function types associative? Why or why not?"
msgstr ""

#. ยง0: `Classical.byContradiction : ยฌ ยฌ P โ P`
#. ยง1: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Lean has a built-in name ยง0 for this implication, which is also called *double negation elimination*. In the source files for Classical World, we have told that we want to use classical reasoning, which is why typing ยง1 suffices to solve this level."
msgstr ""

#. ยง0: `have`
#. ยง1: `p : P`
#. ยง2: `h : P โ Q`
#. ยง3: `have q : Q := h p`
#. ยง4: `q : Q`
#. ยง5: `h p`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "The ยง0 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions ยง1 and ยง2, type ยง3 to add a proof ยง4 defined by ยง5."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `intro s`
#. ยง2: `exact t`
#. ยง3: `fun s โฆ t`
#. ยง4: `\\mapsto`
#. ยง5: `โฆ`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Can you solve this level with only one use of the ยง0 tactic? In fact, even this can be avoided using syntax we have not yet introduced: a two line proof ยง1 followed by ยง2 can be written ยง3 writing ยง4 to type ยง5."
msgstr ""

#. ยง0: `ยซ{A}ยป โ ยซ{A}ยป`
#. ยง1: `x : ยซ{A}ยป`
#. ยง2: `ยซ{A}ยป`
#. ยง3: `intro x`
#. ยง4: `ยซ{A}ยป`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "To define a function, in this case a term of type ยง0, one must define a rule to convert an arbitrary element ยง1 to some element of type ยง2. Start by typing ยง3 to add an arbitrary element of type ยง4 to the context."
msgstr ""

#: Game.Levels.ImplicationWorld
msgid "Implication World"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "How do you construct elements of a function type?"
msgstr ""

#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "What can you do with these assumptions?"
msgstr ""

#. ยง0: `Classical.em P : P โจ ยฌ P`
#. ยง1: `em _`
#. ยง2: `_`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "The classical tautology ยง0 has been added to your library of theorems and can be used by calling ยง1, with the desired proposition replacing the ยง2, whenever classical reasoning is open."
msgstr ""

#. ยง0: `False`
#. ยง1: `p : P`
#. ยง2: `P`
#. ยง3: `False`
#. ยง4: `P`
#. ยง5: `P โ False`
#. ยง6: `P`
#. ยง7: `ยฌ P`
#. ยง8: `ยฌ P`
#. ยง9: `P`
#. ยง10: `p : P`
#. ยง11: `False`
#. ยง12: `False`
#: Game.Levels.NegationWorld
msgid "In this world, we will study the proposition ยง0 and the logical operation of *negation*.\n"
"\n"
"Recall that an element ยง1 of a proposition ยง2 may be thought of as a proof that the proposition is true. The proposition ยง3 is not true so it does not contain any elements.\n"
"\n"
"For any proposition ยง4, we define its *negation* to be the proposition ยง5, pronounced &ldquo;ยง6 implies false&rdquo;. This is commonly abbreviated with the shorthand ยง7, pronounced &ldquo;not P&rdquo;.\n"
"\n"
"A *proof of negation* means a proof of a proposition of the form ยง8 for some proposition ยง9.\n"
"\n"
"Using the introduction rule for implications, such a proof starts by assuming ยง10 and then deriving an element of ยง11.\n"
"\n"
"Since ยง12 has no elements, we think of this process as deriving a contradiction."
msgstr ""

#. ยง0: `intro`
#. ยง1: `P โ Q`
#. ยง2: `intro p`
#. ยง3: `p : P`
#. ยง4: `Q`
#. ยง5: `P โ Q โ R`
#. ยง6: `intro p q`
#. ยง7: `p : P`
#. ยง8: `q : Q`
#. ยง9: `R`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "The ยง0 tactic, short for *introduction*, is used to introduce one or more hypotheses when the goal is an implication. It can be used itself or followed by names for those hypotheses. For example, when the goal is ยง1, type ยง2 to add an assumption ยง3 and update the goal to ยง4. When the goal is ยง5, type ยง6 to add assumptions ยง7 and ยง8 and update the goal to ยง9."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "There are various ways to solve this level. You might enjoy searching for a shorter proof."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `Function.curry : (A ร B โ C) โ (A โ B โ C)`
#. ยง4: `f : A ร B โ C`
#. ยง5: `a : A`
#. ยง6: `b : B`
#. ยง7: `f โจa, bโฉ : C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "For any types ยง0, ยง1, and ยง2, ยง3 is the function that sends ยง4 to the function that sends ยง5 and ยง6 to ยง7."
msgstr ""

#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "This logical equivalence captures the *universal property* of disjunction, explaining how the mathematical or is used in a proof."
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `swap f : B โ A โ C`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Note that for a particular multvariable function ยง0, its type dictates that the variable of type ยง1 must be supplied before the variable of type ยง2. But as observed in this level, we can then define a corresponding function ยง3 which encodes the same information."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `(A โ B) โ (B โ Empty) โ (A โ Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types ยง0 and ยง1, there is a function ยง2 defined by composition."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `ยซ{nq}ยป`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What can you prove with ยง0 and ยง1?"
msgstr ""

#. ยง0: `S โ T`
#. ยง1: `(S โ T) โง (T โ S)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Recall that ยง0 is an abbreviation for ยง1. What is the outermost connective here? Which tactic can be used to break this into subgoals?"
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `f : A โ B โ C`
#. ยง2: `a : A`
#. ยง3: `b : B`
#. ยง4: `f a b : C`
#. ยง5: `f`
#. ยง6: `a`
#. ยง7: `b`
#. ยง8: `A โ B โ C`
#. ยง9: `B โ A โ C`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Recall that an element of type ยง0 can be thought of as a function of two variables.\n"
"\n"
"Given ยง1, ยง2, and ยง3, ยง4 denotes ยง5 applied first to ยง6 and then to ยง7.\n"
"\n"
"From a function of type ยง8, we can define a function of type ยง9 by swapping the order of the variables that are input into the function."
msgstr ""

#. ยง0: `P โจ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "There are two ways to prove ยง0 from the given hypotheses. Can you find them both?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Can we apply our hypothesis yet or must we act on the goal first?"
msgstr ""

#. ยง0: `P โง Q โ R`
#. ยง1: `P โ Q โ R`
#. ยง2: `(P โ Q โ R)`
#. ยง3: `P โง Q โ R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "In the previous level we proved that ยง0 implies ยง1.\n"
"\n"
"We now show that ยง2 implies ยง3."
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `swap f : B โ A โ C`
#. ยง2: `b : B`
#. ยง3: `a : A`
#. ยง4: `(swap f) b a : C`
#. ยง5: `f a b : C`
#. ยง6: `(swap f) b a = f a b`
#. ยง7: `swap`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Consider a function ยง0. We've defined a corresponding function ยง1 by exchanging the order of the inputs. That is for any ยง2 and ยง3 the terms ยง4 and ยง5 are equal by definition.\n"
"\n"
"Thus, reflexivity again proves that ยง6. But for Lean to understand, this we must first tell Lean to unfold our definition of ยง7."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โจ Q`
#. ยง3: `Q โจ P`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "We can improve our understanding of the symmetry of disjunction as follows.\n"
"\n"
"For propositions ยง0 and ยง1, ยง2 is true if and only if ยง3 is true."
msgstr ""

#. ยง0: `A`
#. ยง1: `f : A โ Empty`
#. ยง2: `a : A`
#. ยง3: `Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "For any type ยง0, if there is a function ยง1 and there is an element ยง2, then there is an element of the ยง3 type."
msgstr ""

#. ยง0: `A`
#. ยง1: `A โ Empty`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Again, something very strange happens if the types ยง0 and ยง1 both have elements."
msgstr ""

#. ยง0: `cases ยซ{x}ยป`
#. ยง1: `ยซ{x}ยป`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall you can type ยง0 to ask Lean to consider which cases are actually possible for the hypothetical element ยง1."
msgstr ""

#. ยง0: `A โ B โ C ร D`
#. ยง1: `(A โ C) ร (B โ C) ร (A โ D) ร (B โ D)`
#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "A function of type ยง0 can be broken into component functions of type ยง1 and conversely the component functions assemble into a function from the coproduct type to the product type."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "The empty type is a weird type, so what was the point of this world? The hope is that your experience defining functions involving the empty type will prepare you to think about what it means to prove that a proposition is false in Negation World. Go there next."
msgstr ""

#. ยง0: `ยฌ (P โง Q)`
#. ยง1: `P โง Q`
#. ยง2: `P โง Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โง Q`
#. ยง8: `ยฌ P โจ ยฌ Q`
#. ยง9: `ยฌ (P โง Q)`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"On the one hand, it suffices for just ยง3 to be false.\n"
"\n"
"On the other hand, it suffices for just ยง4 to be false.\n"
"\n"
"That is, if either ยง5 or ยง6 is false, then ยง7 is false.\n"
"\n"
"In this level, we will prove that ยง8 implies ยง9."
msgstr ""

#. ยง0: `h : P โ Q`
#. ยง1: `p : P`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "We've seen that an implication ยง0 can be applied in the presense of a proof ยง1 to provide a proof of the proposition ยง2. This explains how implications are *used* in proofs of other statements. In the next level, we will see how implications can be *proven*."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `Or.inl`
#. ยง3: `P โ (P โจ Q)`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "For propositions ยง0 and ยง1, ยง2 is a proof that ยง3."
msgstr ""

#. ยง0: `(P โ Q โ R) โ (P โง Q โ R)`
#. ยง1: `P โง Q โ R`
#. ยง2: `P โ Q โ R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "This proves that ยง0. We can now conclude that ยง1 and ยง2 are logically equivalent."
msgstr ""

#. ยง0: `P`
#. ยง1: `False โ P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition ยง0, the implication ยง1 is true."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `x = y`
#. ยง2: `x`
#. ยง3: `y`
#: Game.Levels.EqualityWorld.L02_PairedProjections
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "In summary, ยง0 can also be used to prove propositions of the form ยง1 when ยง2 and ยง3 are equal *by definition* (rather than by a more complicated chain of reasoning)."
msgstr ""

#: Game.Levels.ProductWorld
msgid "Product World"
msgstr ""

#. ยง0: `exact fun g f a โฆ ?`
#. ยง1: `?`
#. ยง2: `exact fun g f โฆ ?`
#. ยง3: `?`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Can you solve this level in one line by using ยง0 with the appropriate thing in place of the ยง1?\n"
"\n"
"Can you solve this level in one line by using ยง2 with the appropriate thing in place of the ยง3?"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use the ยง0 tactic to define a term in a function type."
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Type ยง0 to ask Lean to consider all possible cases involving an element of the empty type. As there are no cases, this will complete the proof."
msgstr ""

#. ยง0: `have`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "For the Boss Level of Conjunction World, the task is to prove a complicated implication.\n"
"\n"
"After introducing all of the allowed hypotheses, you may find it helpful to prove that some intermediate propositions are true using the ยง0 tactic.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P โ Q`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "If ยง0 is true, then ยง1 is true."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Define the currying function, convering a function out of a product type into a function of two variables."
msgstr ""

#. ยง0: `ยซ{Q}ยป โ ยซ{P}ยป`
#. ยง1: `intro q`
#. ยง2: `q : ยซ{Q}ยป`
#. ยง3: `ยซ{P}ยป`
#. ยง4: `intro`
#. ยง5: `ยซ{Q}ยป`
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "To prove an implication, which in this case has the form ยง0, type ยง1 to introduce an assumption ยง2 and update the goal to ยง3.\n"
"\n"
"It is also possible to type simply ยง4 in which case Lean will automatically generate a name for the proof of ยง5."
msgstr ""

#. ยง0: `ยซ{c}ยป.2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "What is the logical structure of the type that ยง0 belongs to?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B โ B โ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For any types ยง0 and ยง1, there is a canonical function of type ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โง Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "For any propositions ยง0 and ยง1, if ยง2 is false or ยง3 is false then ยง4 is false."
msgstr ""

#. ยง0: `ยซ{pnq}ยป`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What else can we prove with the hypothesis ยง0?"
msgstr ""

#. ยง0: `P โง ยฌ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "In the next level, we will see that a contradiction of the form ยง0 can be used to prove any proposition."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `ยซ{p}ยป`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "What sort of inputs does the function ยง0 require and how can these be extracted from ยง1?"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#. ยง2: `P โ Q`
#. ยง3: `ยฌ Q โ ยฌ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "In this level we will study the relationship between an implication ยง0 and its *contrapositive*, which is the statement ยง1.\n"
"\n"
"The objective in this level is to prove that ยง2 implies ยง3.\n"
"\n"
"In fact, the construction of this proof should feel very familiar!\n"
"\n"
"The other direction of implication is considerably more subtle and will be discussed in the next world."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Distributivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What is the logical structure of this type?"
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "This might be a useful time to apply one of the theorems proven earlier in Negation World."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `ยซ{P}ยป`
#. ยง2: `ยซ{Q}ยป`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Use the tactic ยง0 to ask Lean to break up the goal into steps, of first proving ยง1 and then proving ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A โ B) โ C`
#. ยง4: `A โ (B โ C)`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "For types ยง0, ยง1, and ยง2, there are canonical functions between the types ยง3 and ยง4."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A ร B) ร C`
#. ยง4: `A ร (B ร C)`
#. ยง5: `A ร B ร C`
#. ยง6: `p : (A ร B) ร C`
#. ยง7: `p.1 : A ร B`
#. ยง8: `p.2 : C`
#. ยง9: `p.1 : A ร B`
#. ยง10: `p.1.1 : A`
#. ยง11: `p.1.2 : B`
#. ยง12: `((A ร B) ร C) โ (A ร (B ร C))`
#. ยง13: `(A ร (B ร C)) โ ((A ร B) ร C)`
#. ยง14: `(((A ร B) ร C) โ (A ร (B ร C))) ร ((A ร (B ร C)) โ ((A ร B) ร C))`
#. ยง15: `A ร B ร C`
#. ยง16: `(A ร B) ร C`
#. ยง17: `a : A`
#. ยง18: `b : B`
#. ยง19: `c : C`
#. ยง20: `โจa,b,cโฉ : A ร B ร C`
#. ยง21: `โจa, โจb,cโฉโฉ : A ร (B ร C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Given three types ยง0, ยง1, and ยง2, the product type construction may be iterated to define types ยง3 and ยง4, the latter of which is abbreviated ยง5.\n"
"\n"
"A term ยง6 has projections ยง7 and ยง8. Then ยง9 has further projections ยง10 and ยง11.\n"
"\n"
"Use this to define a *pair* of functions, the first of type ยง12 and the second of type ยง13. That is, define a single element of type\n"
"\n"
"ยง14\n"
"\n"
"Note some shorthands are available for ยง15 but not for ยง16.\n"
"\n"
"Given ยง17, ยง18, and ยง19, we may write ยง20 to abbreviate ยง21."
msgstr ""

#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "More Compound Implication"
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The goal is an implication. What tactic can be used to start a proof?"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Combined with what we know already, we have established a logical equivalence between the implications ยง0 and ยง1 in classical logic."
msgstr ""

#. ยง0: `B`
#. ยง1: `Empty.elim : Empty โ B`
#. ยง2: `Empty`
#. ยง3: `B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Recall that for any type ยง0, there is a function ยง1. Using this and your element of ยง2 can you define an element of type ยง3?"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What is the logical structure of the goal?"
msgstr ""

#: Game.Levels.ImplicationWorld.L09_BossLevel
#: Game.Levels.ConjunctionWorld.L10_BossLevel
#: Game.Levels.FunctionWorld.L09_BossLevel
#: Game.Levels.ProductWorld.L10_BossLevel
#: Game.Levels.EmptyWorld.L07_BossLevel
#: Game.Levels.NegationWorld.L11_BossLevel
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "Boss Level"
msgstr ""

#. ยง0: `x`
#. ยง1: `cases x`
#. ยง2: `x`
#. ยง3: `cases`
#. ยง4: `h : P โจ Q`
#. ยง5: `cases h`
#. ยง6: `P`
#. ยง7: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Assuming ยง0 is a variable in the local context with an inductive type, ยง1 splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on ยง2, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well. ยง3 detects unreachable cases and closes them automatically.\n"
"\n"
"For example, given an assumption ยง4, ยง5 splits the main goal into two goals, one assuming ยง6 holds and the other assuming ยง7 holds."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "The ยง0 tactic can be used when the goal is a conjunction (among other settings) to split the goal into cases."
msgstr ""

#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "Unfolding definitions"
msgstr ""

#. ยง0: `h`
#. ยง1: `P`
#. ยง2: `Q`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Since ยง0 is a compound implication, we have multiple hypothesis to satisfy. We must prove that ยง1 is true and also prove that ยง2 is true. Fortunately, our assumptions cover both cases."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `ยฌ (P โ Q)`
#. ยง3: `P โง ยฌ Q`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In classical logic, for any propositions ยง0 and ยง1, ยง2 implies ยง3."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ (P โง ยฌ P)`
#. ยง2: `P`
#. ยง3: `ยฌ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition ยง0, the following is true:\n"
"\n"
"ยง1\n"
"\n"
"This is sometimes called the *law of noncontradiction*.\n"
"\n"
"It asserts that it is not the case that both ยง2 and ยง3 are true.\n"
"\n"
"Do you see how this relates to the previous levels?"
msgstr ""

#. ยง0: `ยซ{nor}ยป`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What can you do with the hypothesis ยง0?"
msgstr ""

#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "Right Inclusion"
msgstr ""

#. ยง0: `False.elim : Empty โ P`
#. ยง1: `exact False.elim`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Lean has a built-in name ยง0 for the theorem you have just proven. Thus ยง1 will also solve this level. This theorem has been added to the library."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โ Q`
#. ยง3: `ยฌ Q โ ยฌ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "For any propositions ยง0 and ยง1, if ยง2 holds then ยง3 also holds."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P โง Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If ยง0 is true then ยง1 is true."
msgstr ""

#. ยง0: `A`
#. ยง1: `id : A โ A`
#. ยง2: `a : A`
#. ยง3: `f : A โ B`
#. ยง4: `x : A`
#. ยง5: `B`
#. ยง6: `intro x`
#. ยง7: `x : A`
#. ยง8: `B`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The simplest example of a function is the identity function, which may be defined for any type ยง0. The identity function\n"
"ยง1 is defined to carry any element ยง2 to itself.\n"
"\n"
"To define a function ยง3 one must define a rule that converts an arbitrary element ยง4 to some element of type ยง5. Start by typing ยง6 to add an arbitrary element ยง7 to the context and update the goal to a term of type ยง8."
msgstr ""

#. ยง0: `A ร B โ A`
#. ยง1: `A ร B โ B`
#. ยง2: `p : A ร B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `p : A ร B`
#. ยง6: `p.1 : A`
#. ยง7: `p.2 : B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "The product type comes with *projection functions* of type ยง0 and ยง1 which take an element ยง2 and return the corresponding components from ยง3 and ยง4 respectively.\n"
"\n"
"In Lean, the elements defined by projecting from ยง5 are denoted ยง6 and ยง7."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Introducing And"
msgstr ""

#. ยง0: `cases`
#. ยง1: `cases ยซ{hpq}ยป`
#. ยง2: `rcases ยซ{hpq}ยป with hp | hq`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "The hypothesis generated by the ยง0 tactic isn't directly useable yet. Try ยง1 again, or ยง2 to name your own variables."
msgstr ""

#. ยง0: `A โ Empty`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `f : A โ Empty`
#. ยง4: `A โ B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "In this level, we will explore another weird consequence of the hypothesis that we have a function of type ยง0.\n"
"\n"
"Let ยง1 and ยง2 be any types and assume there is a function ยง3.\n"
"\n"
"Then it is always possible to define a function ยง4.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. ยง0: `f : A ร B โ C`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `C`
#. ยง4: `f โจa,bโฉ`
#. ยง5: `g : A โ B โ C`
#. ยง6: `g`
#. ยง7: `a : A`
#. ยง8: `b : B`
#. ยง9: `C`
#. ยง10: `g a b : C`
#. ยง11: `A ร B โ C`
#. ยง12: `A โ B โ C`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `C`
#. ยง16: `f : A ร B โ C`
#. ยง17: `โจa, bโฉ : A ร B`
#. ยง18: `C`
#. ยง19: `g : A โ B โ C`
#. ยง20: `a : A`
#. ยง21: `g a : B โ C`
#. ยง22: `b : B`
#. ยง23: `C`
#. ยง24: `A โ B โ C`
#. ยง25: `A ร B โ C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Consider a function ยง0 mapping out of a product type. This function takes an ordered pair of elements, one from ยง1 and one from ยง2 and returns an element of type ยง3 denoted by ยง4. Does this sound familiar?\n"
"\n"
"Recall that terms of type ยง5 were functions of two variables. The function ยง6 takes ยง7 and ยง8 and returns an element of type ยง9 denoted by ยง10, which is basically\n"
"\n"
"In summary, the types ยง11 and ยง12 both provide a notion of function of two variables, with inputs from the types ยง13 and ยง14 and output in the type ยง15. The difference is that ยง16 is thought of as a function that takes a pair ยง17 to an element of type ยง18, while ยง19 is thought of as a function that takes ยง20 to a function ยง21 (which then takes ยง22 to an element of type ยง23).\n"
"\n"
"The process of converting a function of type  ยง24 to one of type ยง25 is called *uncurrying* and is defined by the function below."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Composition"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `Sum.inl a : A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For any ยง0, there is an element ยง1."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#. ยง2: `P โง Q`
#. ยง3: `Q โง P`
#. ยง4: `P โง Q โ Q โง P`
#. ยง5: `(P โง Q) โ (Q โง P)`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "If ยง0 is true, then ยง1 is too.\n"
"\n"
"In other words, ยง2 implies ยง3, as is expressed by the proposition ยง4 which is implicitly parenthesized as ยง5."
msgstr ""

#. ยง0: `absurd`
#. ยง1: `exact absurd`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "Lean has a built in name ยง0 for the theorem you have just proven, so this level may be solved with ยง1. This has been added to the theorem library."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `f : A โ B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A ร B`
#. ยง7: `โจa, bโฉ : A ร B`
#. ยง8: `a : A`
#. ยง9: `b : B`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `A โ B`
#. ยง13: `a : A`
#. ยง14: `Sum.inl a : A โ B`
#. ยง15: `b : B`
#. ยง16: `Sum.inr b : A โ B`
#: Game.Levels.CoproductWorld
msgid "Given any types ยง0 and ยง1 we have studied\n"
"\n"
"* function types ยง2 whose elements ยง3 are *functions* from ยง4 to ยง5 and\n"
"\n"
"* product types ยง6 whose elements ยง7 are *pairs* of elements ยง8 and ยง9.\n"
"\n"
"In this world, we'll study another binary type forming operation. Given two types ยง10 and ยง11, there is a type ยง12 called the *coproduct type* which has two types of elements:\n"
"\n"
"* elements ยง13 define elements ยง14\n"
"* elements ยง15 define elements ยง16.\n"
"\n"
"Like the analogy between function types and implication, and product types and conjunction, there is a close analogy between coproduct types and the logical operation of disjunction."
msgstr ""

#: Game.Levels.NegationWorld.L11_BossLevel
msgid "Move on to Classical World to better understand the statements involving negation that we have not been able to prove thus far."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โง Q) โง R`
#. ยง4: `P โง (Q โง R)`
#. ยง5: `P โง Q โง R`
#. ยง6: `P โง (Q โง R)`
#. ยง7: `h : (P โง Q) โง R`
#. ยง8: `h.1 : P โง Q`
#. ยง9: `h.2 : R`
#. ยง10: `h.1.1 : P`
#. ยง11: `h.1.2 : Q`
#. ยง12: `p : P`
#. ยง13: `q : Q`
#. ยง14: `r : R`
#. ยง15: `โจโจp, qโฉ, rโฉ : (P โง Q) โง R`
#. ยง16: `โจp, โจq, rโฉโฉ : P โง (Q โง R)`
#. ยง17: `โจp, q, rโฉ : P โง Q โง R`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "For propositions ยง0, ยง1, and ยง2, ยง3 is true if and only if ยง4 is true.\n"
"\n"
"Lean likes to drop parentheses whenever possible so uses ยง5 as an abbreviation for ยง6. While it's difficult to remember this convention, at least the two possible statements are logically equivalent!\n"
"\n"
"Given a proof ยง7, we obtain proofs ยง8 and ยง9. From the first of these,\n"
"we obtain further proofs ยง10 and ยง11.\n"
"\n"
"Similarly, given proofs ยง12, ยง13, ยง14, then ยง15 while ยง16. Lean allows the shorthand ยง17 for the latter proof."
msgstr ""

#: Game.Levels.EqualityWorld
msgid "Equality World"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `A`
#. ยง4: `A โ Empty`
#. ยง5: `A โ Empty`
#. ยง6: `Sum.inl a`
#. ยง7: `a : A`
#. ยง8: `Sum.inr x`
#. ยง9: `x : Empty`
#. ยง10: `A โ Empty`
#. ยง11: `A`
#. ยง12: `A โ A โ Empty`
#. ยง13: `A โ Empty โ A`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall that for any types ยง0 and ยง1, there is a *coproduct type* denoted ยง2.\n"
"\n"
"In particular, for any type ยง3, we may form the product ยง4 with the empty type.\n"
"\n"
"In general, coproduct types like ยง5 have two types of elements: those of the form ยง6 for some ยง7 and those of the form ยง8 for ยง9.\n"
"\n"
"But the empty type does not have any elements. So this second case does not exist.\n"
"\n"
"It follows that the type ยง10 is *equivalent* to the type ยง11 in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions ยง12 and ยง13."
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Where have you seen this construction before? Can you solve this level in a different way?"
msgstr ""

#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Define the composition of two functions as a multivariable function between function types."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `p`
#. ยง3: `P`
#. ยง4: `h`
#. ยง5: `P โ Q`
#. ยง6: `Q`
#. ยง7: `h`
#. ยง8: `p`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now we are in the setting of two proposition variables ยง0 and ยง1 with two hypotheses. The first assumption provides a proof ยง2 that the proposition ยง3 is true. The second provides a proof ยง4 that the implication ยง5 is true.\n"
"\n"
"It follows from both of these facts that ยง6 is also true and we can construct a proof by applying the hypothesis ยง7 to the proof ยง8."
msgstr ""

#. ยง0: `ยซ{lem}ยป`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Now might be a good time to case split on the hypothesis ยง0."
msgstr ""

#. ยง0: `P โง Q โ R`
#. ยง1: `P โ Q โ R`
#. ยง2: `P โ (Q โ R)`
#. ยง3: `(P โ Q) โ R`
#. ยง4: `Currying`
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "We now establish a logical equivalence between ยง0 and ยง1.\n"
"\n"
"This is why implications of the form ยง2 are so much more common than implications of the form ยง3.\n"
"\n"
"The name ยง4 will be explained in a future level.\n"
"\n"
"Note the two implications have been added to the theorem library, should you wish to use them."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "What is the outermost logical connective? What tactic is used to prove statements of this form?"
msgstr ""

#. ยง0: `ยซ{h}ยป.1 : ยซ{P}ยป`
#. ยง1: `ยซ{h}ยป.2 : ยซ{Q}ยป โจ ยซ{R}ยป`
#. ยง2: `have p := ยซ{h}ยป.1`
#. ยง3: `have qr := ยซ{h}ยป.2`
#. ยง4: `p`
#. ยง5: `qr`
#. ยง6: `cases ยซ{h}ยป.2`
#. ยง7: `rcases`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Recall that ยง0 and ยง1. We can introduce these as named variables in the context by typing ยง2 and ยง3 where ยง4 and ยง5 are variable names you get to pick. This allows you to case split on an explicitly named variable. Alternatively, type ยง6, or use ยง7 to name your own variables."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `โ`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โ Q`
#. ยง7: `P`
#. ยง8: `Q`
#. ยง9: `P โ Q`
#. ยง10: `P โ Q`
#: Game.Levels.ImplicationWorld
msgid "We begin our study of proofs with *propositional logic*.\n"
"\n"
"Many mathematical propositions are built out of simpler propositions using logical connectives. The structure of a compound proposition &mdash; that is, which connectives appear where &mdash; often suggests proof techniques, as we will discover.\n"
"\n"
"To study these connectives, we require *proposition variables* &mdash; denoted with letters like ยง0, ยง1, ยง2 &mdash; which stand for generic propositions, which may be true or false.\n"
"\n"
"In this level we study the logical connective *implication* denoted by ยง3.\n"
"\n"
"For arbitrary *propositions* ยง4 and ยง5, ยง6 is a new proposition asserting that *if* ยง7 *is true then* ยง8 *is true*.\n"
"\n"
"To understand how implications work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง9.\n"
"* How to use a hypothesis of the form ยง10 to prove something else.\n"
"\n"
"We'll learn the rules for proving implications and using implications in the levels that follow."
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "We'll now study the second type of element of in a coproduct type."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `ยซ{A}ยป โ ยซ{C}ยป`
#. ยง2: `ยซ{B}ยป โ ยซ{C}ยป`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Now the goal is a product type. The ยง0 tactic will split into two subgoals, defining the functions ยง1 and ยง2 respectively."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โจ Q) โจ R`
#. ยง4: `P โจ (Q โจ R)`
#. ยง5: `P โจ Q โจ R`
#. ยง6: `P โจ (Q โจ R)`
#. ยง7: `hโ : (P โจ Q) โจ R`
#. ยง8: `cases hโ`
#. ยง9: `P โจ Q`
#. ยง10: `R`
#. ยง11: `hโ : P โจ Q โจ R`
#. ยง12: `cases hโ`
#. ยง13: `P`
#. ยง14: `Q โจ R`
#. ยง15: `rcases`
#. ยง16: `hโ : (P โจ Q) โจ R`
#. ยง17: `rcases hโ with (p | q) | r`
#. ยง18: `hโ : P โจ Q โจ R`
#. ยง19: `rcases hโ with p | q | r`
#. ยง20: `\\7`
#. ยง21: `โ`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Similarly, for propositions ยง0, ยง1, and ยง2, ยง3 holds if and only if ยง4 holds.\n"
"\n"
"Lean uses ยง5 as an abbreviation for ยง6.\n"
"\n"
"Given a hypothesis ยง7, ยง8 will split the hypothesis into two cases: one assuming that ยง9 is true and the other assuming ยง10 is true.\n"
"\n"
"Similarly given a hypothesis ยง11, ยง12 the hypothesis into two cases: one assuming that ยง13 is true and the other assuming ยง14 is true.\n"
"\n"
"Note the ยง15 tactic allows more general patterns of disjunctions. Given ยง16 try ยง17. Similarly, given ยง18, try ยง19.\n"
"\n"
"Aside: typing ยง20 using any single digit number produces a subscript with that number, like ยง21."
msgstr ""

#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Next we will study the relationship between products and coproducts."
msgstr ""

#. ยง0: `ยซ{f}ยป : A โ Empty`
#. ยง1: `ยซ{a}ยป : A`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "We have assumptions ยง0 and ยง1? What can you construct using this?"
msgstr ""

#. ยง0: `A ร B`
#. ยง1: `B ร A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Product types are symmetric: an element of type ยง0 has a corresponding element of type ยง1 with components swapped."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `(P โ Q) โง (Q โ P)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "ยง0, read as &ldquo;ยง1 if and only if ยง2&rdquo; is an abbreviation for ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `id : A โ A`
#. ยง2: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type ยง0, the identity function ยง1 is the function defined by sending and arbitrary element ยง2 to itself."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `</>`
#. ยง2: `editor mode`
#. ยง3: `>_`
#. ยง4: `typewriter mode`
#. ยง5: `typewriter mode`
#. ยง6: `retry`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "There are two ways to prove that ยง0 under the assumption given below. Can you find them both?\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled ยง1 in the upper right hand corner to enter ยง2. Then delete all the lines of your first proof (or proof attempt). Clicking on ยง3 takes you back to ยง4.\n"
"\n"
"You can also delete a proof attempt in line by line in ยง5 using the ยง6 button to the right of that line."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Think carefully about what ยง0 proves and what proofs can be extracted from this."
msgstr ""

#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Function Extensionality"
msgstr ""

#. ยง0: `retry`
#. ยง1: `assumption`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "You can click on ยง0 to attempt a different proof. Try typing ยง1 instead."
msgstr ""

#. ยง0: `P`
#. ยง1: `Classical.em P : P โจ ยฌ P `
#. ยง2: `P`
#. ยง3: `ยฌ P`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "For any proposition ยง0, ยง1 proves that ยง2 or ยง3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "This proves the that conjunction distributes over disjunction. A more involved form of distributivity appears in the next level."
msgstr ""

#. ยง0: `And.symm`
#. ยง1: `P โง Q`
#. ยง2: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "The proof you have just constructed is now recorded as a theorem called ยง0 in the library to the right.\n"
"\n"
"In fact ยง1 is true if and only if ยง2 is true, as we will now demonstrate."
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `A โ C`
#. ยง2: `B โ C`
#. ยง3: `g : A โ C`
#. ยง4: `h : B โ C`
#. ยง5: `A โ B โ C`
#. ยง6: `x : A โ B`
#. ยง7: `x`
#. ยง8: `Sum.inl a`
#. ยง9: `a : A`
#. ยง10: `x`
#. ยง11: `Sum.inr b`
#. ยง12: `b : B`
#. ยง13: `g`
#. ยง14: `g a : C`
#. ยง15: `h`
#. ยง16: `h b : C`
#. ยง17: `x`
#. ยง18: `x : A โ B`
#. ยง19: `cases x`
#. ยง20: `rcases x with a | b`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "A function ยง0 mapping out of a coproduct type may be *broken apart* into component functions of types ยง1 and ยง2.\n"
"\n"
"Conversely, given an arbitrary pair of functions ยง3 and ยง4, one can build a function of type ยง5.\n"
"\n"
"This function is defined by introducing a variable term ยง6 and then splitting into two cases: the case where ยง7 is of the form ยง8 for some ยง9 and the case where ยง10 is of the form ยง11 for some ยง12.\n"
"\n"
"In the first case, the function ยง13 can be used to define an element ยง14, while in the second case the function ยง15 can be used to define an element ยง16.\n"
"\n"
"This construction should be reminiscent of a proof by cases involving a hypothesis ยง17 that a disjunction is true and in fact the same tactics apply.\n"
"\n"
"Given a hypothesis ยง18, either ยง19 or ยง20 can be used to split into the two cases mentioned above."
msgstr ""

#. ยง0: `intro p`
#. ยง1: `p : A ร B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The goal is a term of a function type so type ยง0 to give yourself a term ยง1."
msgstr ""

#. ยง0: `apply`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Here ยง0 is another tactic, which can be found in the library above right."
msgstr ""

#. ยง0: `rcases`
#. ยง1: `cases`
#. ยง2: `h : P โจ Q`
#. ยง3: `rcases h with p | q`
#. ยง4: `cases h`
#. ยง5: `p : P`
#. ยง6: `q : Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "ยง0 is a tactic that will perform ยง1 recursively, according to a pattern. One use is to provide explicit names for variables in each subgoal. For example, given a hypothesis ยง2, ยง3 can be used in place of ยง4 to give hypotheses ยง5 in the first case and ยง6."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "What can you conclude from the hypothesis ยง0?"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "And Implies Or"
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What proof strategy is available with an element of a coproduct type?"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "The goal is a product of function types, so to define an element you need to define two different functions. Each will take some work, so start with the ยง0 tactic to split one goal into two goals."
msgstr ""

#. ยง0: `Empty โ (Empty โ Empty)`
#. ยง1: `(Empty โ Empty) ร (Empty โ Empty)`
#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "There are functions in both directions between the types ยง0 and ยง1."
msgstr ""

#. ยง0: `apply`
#. ยง1: `Q`
#. ยง2: `h : P โ Q`
#. ยง3: `apply h`
#. ยง4: `P`
#. ยง5: `T`
#. ยง6: `e : R โ S โ T`
#. ยง7: `apply e`
#. ยง8: `R`
#. ยง9: `S`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The ยง0 tactic can be used when the goal matches the conclusion of an implication.\n"
"For example if the goal is ยง1 and there is a hypothesis ยง2, then ยง3 updates the goal to ยง4. If the goal is ยง5 and there is a hypothesis ยง6, then ยง7 produces two subgoals, one each for ยง8 and ยง9."
msgstr ""

#. ยง0: `f : A ร B โ C`
#. ยง1: `curry f : A โ B โ C`
#. ยง2: `f : X โ A ร B`
#. ยง3: `X`
#. ยง4: `A ร B`
#. ยง5: `X โ A`
#. ยง6: `X โ B`
#. ยง7: `x : X`
#. ยง8: `(f x).1 : A`
#. ยง9: `(f x).2 : B`
#. ยง10: `f x : A ร B`
#. ยง11: `f : X โ A ร B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that a function ยง0 out of a product can be regarded as a function of two variables ยง1.\n"
"\n"
"How should we think about a function into a product?\n"
"\n"
"Given a function ยง2 from a type ยง3 into a product type ยง4 one can define a pair of functions with types ยง5 and ยง6 that for ยง7 record the values ยง8 and ยง9 defined by projecting the pair ยง10 to its components.\n"
"\n"
"These might be called the *component functions* associated to ยง11.\n"
"\n"
"Define a function that extracts the component functions associated to a function into a product."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `A โ (B โ C)`
#. ยง2: `f : A โ B โ C`
#. ยง3: `a : A`
#. ยง4: `f a : B โ C`
#. ยง5: `B`
#. ยง6: `C`
#. ยง7: `b : B`
#. ยง8: `f a`
#. ยง9: `f a b : C`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "An element of type ยง0, which abbreviates the type ยง1, can be thought of as a function of two variables.\n"
"\n"
"Given ยง2 and ยง3, then ยง4 is a function from ยง5 to ยง6.\n"
"\n"
"Then given ยง7 we can apply the function ยง8 to get an element ยง9."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Try applying the hypothesis ยง0."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "ยง0 is true if and only if ยง1 is true."
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Type ยง0 to ask Lean to consider all possible cases involving a proof of false. As there are no cases, this will complete the proof."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty.elim : Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type ยง0, there is a function ยง1 expressing the elimination rule of the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "Now we are ready for the boss level."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Define the uncurrying function, convering a function of two variables into a function out of a product type."
msgstr ""

#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "To Empty"
msgstr ""

#: Game.Levels.NegationWorld
msgid "Negation World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Associativity"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `โจa ,bโฉ : A ร B`
#. ยง3: `โจa, bโฉ.fst : A`
#. ยง4: `โจa , bโฉ.snd : B`
#. ยง5: `a`
#. ยง6: `b`
#. ยง7: `โจa, bโฉ.fst = a`
#. ยง8: `โจa, bโฉ.snd = b`
#. ยง9: `rfl`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Now consider elements ยง0 and ยง1. There is a corresponding pair ยง2 that we can project back to define terms\n"
"ยง3 and ยง4. How do these relate to the original terms ยง5 and ยง6?\n"
"\n"
"Another *computation rule* for product types tells us ยง7 and ยง8 by definition, meaning that ยง9 can provide proofs."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P โ P`
#. ยง2: `P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `P`
#. ยง6: `P`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The Boss Level of Negation World previews the next world by studying the relationship between two *classical* tautologies that we have not been able to prove involving a proposition ยง0.\n"
"\n"
"One statement we have not been able to prove is called *double negation elimination*: ยง1. Double negation elimination asserts that if ยง2 is not false, then ยง3 must be true.\n"
"\n"
"Another statement we have not been able to prove is called *law of excluded middle*: ยง4. The law of excluded middle asserts that either ยง5 is true or ยง6 is false.\n"
"\n"
"In the next world, we'll explore why these statements fall outside the realm of *constructive logic*.\n"
"\n"
"But what we *can* prove constructively is that for any proposition ยง7, the law of excluded middle for ยง8 implies double negation elimination for ยง9.\n"
"\n"
"Have fun!"
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `swap f : B โ A โ C`
#. ยง2: `swap (swap f) : A โ B โ C`
#. ยง3: `f`
#. ยง4: `f g : X โ Y`
#. ยง5: `f x = g x`
#. ยง6: `x : X`
#. ยง7: `f = g`
#. ยง8: `f`
#. ยง9: `g`
#. ยง10: `X โ Y`
#. ยง11: `ext x`
#. ยง12: `f x = g x`
#. ยง13: `x : X`
#: Game.Levels.EqualityWorld.L05_FunctionExtensionality
msgid "Consider a function ยง0. We've defined a corresponding function ยง1 by exchanging the order of the inputs. Applying this construction twice, we obtain ยง2. How does this compare with the original function ยง3?\n"
"\n"
"In general, two functions ยง4 are *equal* just when ยง5 for all inputs ยง6. This rule is called *function extensionality*.\n"
"\n"
"When faced with a goal of the form ยง7 where ยง8 and ยง9 are functions belonging to the type ยง10, the tactic ยง11 will reduce to the problem of proving ยง12 for a generic variable ยง13."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "Pairing"
msgstr ""

#. ยง0: `P โจ Q โ R`
#. ยง1: `P โจ Q โ R`
#. ยง2: `P โ R`
#. ยง3: `P`
#. ยง4: `P โจ Q`
#. ยง5: `R`
#. ยง6: `P โจ Q โ R`
#. ยง7: `Q โ R`
#. ยง8: `P โ R`
#. ยง9: `Q โ R`
#. ยง10: `P โจ Q โ R`
#. ยง11: `P โ R`
#. ยง12: `Q โ R`
#. ยง13: `P โจ Q โ R`
#. ยง14: `P โจ Q โ R`
#. ยง15: `(P โ R) โง (Q โ R)`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What must be true in order to have ยง0?\n"
"\n"
"On the one hand, if ยง1 is true, then ยง2 is true, because ยง3 implies ยง4, which implies ยง5.\n"
"\n"
"Similar reasoning shows that if ยง6 is true, then ยง7 is true.\n"
"\n"
"Conversely, if *either* ยง8 or ยง9 are true, this does not necessarily imply that ยง10 is true. Can you see why?\n"
"\n"
"However, if *both* ยง11 and ยง12 are true, then ยง13 is true.\n"
"\n"
"The aim of this level is to establish a logical equivalence between ยง14 and ยง15."
msgstr ""

#. ยง0: `ยซ{P}ยป โ ยซ{Q}ยป`
#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "Which tactics can be used to prove ยง0 with our given assumptions?"
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What implications can you extract from ยง0?"
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Are function types symmetric? Why or why not?"
msgstr ""

#. ยง0: `A โ (B โ C)`
#. ยง1: `A โ B โ C`
#. ยง2: `(A โ B) โ C`
#. ยง3: `f : A โ B`
#. ยง4: `C`
#. ยง5: `a : A`
#. ยง6: `(A โ B) โ B`
#. ยง7: `a : A`
#. ยง8: `f : A โ B`
#. ยง9: `f a : B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "While an element of type ยง0, more commonly written as ยง1, is a function of two variables, an element of type ยง2 is instead a function that takes a function ยง3 as input and returns an element of type ยง4.\n"
"\n"
"For example, if we are given ยง5, then it is possible to define a function of type ยง6 which is called *evaluation* at ยง7. Given ยง8, we return ยง9."
msgstr ""

#. ยง0: `ยซ{C}ยป`
#. ยง1: `exact`
#. ยง2: `apply`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Now that the goal is an element of type ยง0 there are several ways to proceed. You can use ยง1 or ยง2."
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "First Projection"
msgstr ""

#. ยง0: `Function.uncurry : (A โ B โ C) โ (A ร B โ C)`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"The operations of *currying* and *uncurrying* are inverses in a sense we will be able to make precise later."
msgstr ""

#. ยง0: `exact b`
#. ยง1: `assumption`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Both ยง0 and ยง1 can be used here."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "If this is your first time solving this level, go back and solve it another way."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ (A โ B) โ B`
#. ยง3: `a : A`
#. ยง4: `ev a`
#. ยง5: `(A โ B) โ B`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "For types ยง0 and ยง1, the evaluation function has type ยง2, meaning that for ยง3, ยง4 has type ยง5."
msgstr ""

#: Game
msgid "FYS270"
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `P`
#. ยง2: `Q โจ R`
#. ยง3: `P โง Q`
#. ยง4: `P โง R`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "What does it mean if ยง0 holds?\n"
"\n"
"Then certainly ยง1 is true and also ยง2 is true.\n"
"\n"
"So we can conclude that ยง3 is true or ยง4 is true, demonstrating the following logical equivalence."
msgstr ""

#. ยง0: `intro g f`
#. ยง1: `intro g f a`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "To define a function with multiple variables you can apply the intro tactic twice, for instance by typing ยง0 or even ยง1."
msgstr ""

#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Noncontradiction"
msgstr ""

#. ยง0: `have lemP : P โจ ยฌ P := em P`
#. ยง1: `P โจ ยฌ P`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "To use the law of excluded middle in your proof, type ยง0 to add an assumption that ยง1 is true."
msgstr ""

#. ยง0: `Q`
#. ยง1: `exact ยซ{h}ยป.2`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now Lean reminds you of the other goal, which is to prove ยง0. Type ยง1 to supply this proof."
msgstr ""

#. ยง0: `Sum.inl`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "If your answer does not use the function ยง0, you might have fun trying to solve this level again using it in an appropriate place."
msgstr ""

#. ยง0: `have := ยซ{f}ยป ยซ{a}ยป`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Use ยง0 to add an element of the empty type to the list of assumptions."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `Show more help!`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now your goal is a proof of ยง0. Can you figure out how to finish the proof? If you need a reminder, click the button ยง1"
msgstr ""

#. ยง0: `ยซ{Q}ยป โจ ยซ{P}ยป`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that Lean provides two goals, both of which are to prove that ยง0 is true, under two different hypothesies. Your first task is to prove the theorem in the first case."
msgstr ""

#. ยง0: `unfold`
#: Game.Levels.EqualityWorld.L04_UnfoldingDefinitions
msgid "The tactic ยง0 can be used to unfold user-defined names using their original definitions."
msgstr ""

#. ยง0: `ยซ{h}ยป ยซ{p}ยป : ยซ{Q}ยป`
#. ยง1: `exact ยซ{h}ยป ยซ{p}ยป`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Since ยง0 It is possible to solve this level with ยง1."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#. ยง3: `\\circ`
#. ยง4: `โ`
#. ยง5: `x : A`
#. ยง6: `(g โ f) x`
#. ยง7: `g (f x)`
#. ยง8: `g`
#. ยง9: `f`
#. ยง10: `g โ f`
#. ยง11: `exact g โ f`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Lean has built in notation for the composite of ยง0 and ยง1 namely ยง2, using ยง3 to type ยง4.\n"
"\n"
"Given ยง5, ยง6 is defined to be the element ยง7, which is why the function ยง8 appears on the left of ยง9 in the notation ยง10.\n"
"\n"
"Try solving this level with ยง11."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Universal Property"
msgstr ""

#. ยง0: `cases`
#. ยง1: `rcases`
#. ยง2: `ยซ{p}ยป`
#. ยง3: `B โ C`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You can use ยง0 or ยง1 either on ยง2 to split it up into components or directly on its component in ยง3.Be careful to use the syntax that is appropriate for terms of product or coproduct types, respectively."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `โจa, bโฉ : A ร B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "By pairing any element ยง0 with any element ยง1, there is an element ยง2."
msgstr ""

#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Paired Projections"
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P โจ Q`
#. ยง6: `p : P`
#. ยง7: `q : Q`
#. ยง8: `exact p`
#. ยง9: `exact q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "To prove a disjunction ยง0 it suffices to supply a proof of either ยง1 or of ยง2.\n"
"\n"
"Thus under the hypothesis that ยง3 and ยง4 are both true, there are two ways to prove ยง5: one using ยง6 and one using ยง7.\n"
"\n"
"Note ยง8 or ยง9 won't work as these are proofs of different propositions."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Prod.fst : A ร B โ A`
#. ยง3: `p : A ร B`
#. ยง4: `p.1 : A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "For any types ยง0 and ยง1, ยง2 is the function that sends ยง3 to its first coordinate ยง4."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `Q โ R`
#. ยง2: `P โ R`
#: Game.Levels.ImplicationWorld.L07_OnParentheses
msgid "If ยง0, then if ยง1, then ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q โ R`
#. ยง3: `R`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "If ยง0 is true, ยง1 is true, and ยง2 is true, then ยง3 is true."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If the proposition ยง0 is true, then ยง1 is true."
msgstr ""

#. ยง0: `ยซ{P}ยป โจ (ยซ{Q}ยป โจ ยซ{R}ยป)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Here the goal is parenthesized as ยง0. Using your hypothesis, are you trying to prove the left-hand proposition or the right-hand one?"
msgstr ""

#. ยง0: `False`
#. ยง1: `have := ยซ{np}ยป ยซ{p}ยป`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If you like, you can add a proof of ยง0 to your assumption list by ยง1."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `ยซ{P}ยป`
#. ยง2: `ยซ{Q}ยป`
#. ยง3: `ยซ{Q}ยป`
#. ยง4: `ยซ{P}ยป`
#. ยง5: `apply ยซ{h}ยป`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The hypothesis ยง0 can be used to convert a proof of ยง1 into a proof of ยง2. This can be thought of as a step that reduces the problem of proving ยง3 to the problem of proving ยง4. To apply this hypothesis type ยง5."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `f : A โ B โ C`
#. ยง2: `B โ C`
#. ยง3: `f`
#. ยง4: `a`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Given an element ยง0 and a function of two variables ยง1, define a function from ยง2 by evaluating the first variable of ยง3 at the element ยง4."
msgstr ""

#. ยง0: `ยฌ Q โ ยฌ P`
#. ยง1: `P โ Q`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "In classical logic, ยง0 implies ยง1."
msgstr ""

#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "By Contradiction"
msgstr ""

#. ยง0: `ยซ{hyp}ยป`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What proof technique is available when you have a hypothesis like ยง0?"
msgstr ""

#. ยง0: `โง`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โง Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โง Q`
#. ยง7: `P โง Q`
#. ยง8: `P โง Q`
#. ยง9: `p : P`
#. ยง10: `q : Q`
#. ยง11: `โจp,qโฉ : P โง Q`
#. ยง12: `h : P โง Q`
#. ยง13: `P`
#. ยง14: `Q`
#. ยง15: `h.1 : P`
#. ยง16: `h.2 : Q`
#: Game.Levels.ConjunctionWorld
msgid "The logical connective of *conjunction*, denoted by ยง0, is the mathematical version of *and*.\n"
"\n"
"For arbitrary propositions ยง1 and ยง2, ยง3 is a new proposition asserting that ยง4 *and* ยง5 *are both true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง6.\n"
"* How to use a hypothesis of the form ยง7 to prove something else.\n"
"\n"
"To prove ยง8, one must supply proofs ยง9 and ยง10, which can be done using the syntax ยง11. Use '\\\\<' and '\\\\>' to type the angle brackets.\n"
"\n"
"If we have a proof ยง12 then we can extract proofs that ยง13 and ยง14 are true using the syntax ยง15 and ยง16."
msgstr ""

#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Multivariable functions"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `x : A`
#. ยง5: `f x : B`
#. ยง6: `g (f x) : C`
#. ยง7: `exact fun x โฆ ?`
#. ยง8: `?`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions ยง0 and ยง1 there is a *composite function* from ยง2 to\n"
"ยง3.\n"
"\n"
"It is defined to be the function that sends ยง4 first to the element ยง5 and then\n"
"to the element ยง6.\n"
"\n"
"Can you solve this level in one line by using ยง7 with the appropriate thing in place of the ยง8?\n"
"\n"
"Alternatively, you can use other tactics to define the required function step by step."
msgstr ""

#. ยง0: `Sum.inl : A โ A โ B`
#. ยง1: `A โ B`
#. ยง2: `A`
#. ยง3: `apply Sum.inl`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "To use the built in function ยง0 to change the goal from ยง1 to ยง2 type ยง3."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "In summary, a basic axiom of equality is *reflexivity*:\n"
"for any ยง0, ยง1 is always true."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "A function into a product type has a pair of component functions."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If this is your first time solving this level, delete your proof, and try to find another solution."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "If ยง0 is true and ยง1 is true, then ยง2 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that you've completed the proof in the first case, Lean expects you to provide a proof in the second case."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Product With Empty"
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Congratulations!"
msgstr ""

#: Game.Levels.ClassicalWorld
msgid "Classical World"
msgstr ""

#. ยง0: `Empty`
#. ยง1: `Empty`
#. ยง2: `A`
#. ยง3: `A`
#. ยง4: `Empty.elim : Empty โ A`
#. ยง5: `Empty โ A`
#. ยง6: `X`
#. ยง7: `A`
#. ยง8: `x : X`
#. ยง9: `A`
#. ยง10: `Empty`
#. ยง11: `A`
#. ยง12: `Empty`
#: Game.Levels.EmptyWorld
msgid "In this world, we will introduce the *empty type*, which is commonly denoted by ยง0 in Lean.\n"
"\n"
"In general, types can be characterized by:\n"
"* Introduction rules: which explain how to construct elements of the given type.\n"
"* Elimination rules: which explain how to use elements of the given type to construct elements of other types.\n"
"\n"
"In the case of the empty type, there are no introduction rules. This corresponds colloquially to the idea that the empty type has &ldquo;no elements.&rdquo;\n"
"\n"
"The elimination rule for the empty type defines a function from the ยง1 type to any other type ยง2, with no obligations on the type ยง3. This provides a canonical element ยง4 of the function type.\n"
"\n"
"There is another way to understand why the type ยง5 should always have an element.\n"
"\n"
"In order to define a function from a type ยง6 to a type ยง7 one must fulfill the following obligation: for each ยง8 one must specify an element of type ยง9.\n"
"\n"
"In the case of a function from the type ยง10 to a type ยง11, there are no obligations because the empty type has no elements.\n"
"\n"
"In this world, we will explore constructions involving the ยง12 type."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "The overall objective here is to prove a conjunction. Which tactic can help break this up into simpler statements?"
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ProvingImplication
#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Let us now explore other implications that are provable with this strategy."
msgstr ""

#. ยง0: `exact`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "The goal is an implication you've already proven. You can use ยง0 together with the name of that result, to solve this goal in one line. Alternatively, you can just prove it again."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Using Or"
msgstr ""

#. ยง0: `apply f`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "There is another way to solve this level. Start with ยง0 and see what happens. Have you seen a construction like this before?"
msgstr ""

#. ยง0: `exact ยซ{p}ยป`
#. ยง1: `ยซ{p}ยป`
#. ยง2: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Type ยง0 to tell Lean that ยง1 is a proof of ยง2."
msgstr ""

#. ยง0: `exact fun x โฆ x`
#. ยง1: `\\mapsto`
#. ยง2: `โฆ`
#. ยง3: `x`
#. ยง4: `x`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "You can solve this level in one level by just giving the entire formula for the function as\n"
"ยง0, using ยง1 to type ยง2. This tells Lean that the answer is the function defined on an input element ยง3 to have an output value ยง4."
msgstr ""

#. ยง0: `Or`
#. ยง1: `P`
#. ยง2: `P โจ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Look at the theorems about ยง0 if you have forgotten how to tell Lean about the relationship between ยง1 and ยง2."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Does this construction feel intuitive or does it feel strange?"
msgstr ""

#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Through Empty"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `B`
#. ยง2: `const a : B โ A`
#. ยง3: `x : B`
#. ยง4: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "For a term ยง0 and a type ยง1, ยง2 is the function defined by sending ยง3 to ยง4."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#. ยง3: `P โ False`
#. ยง4: `ยฌ P`
#. ยง5: `P`
#. ยง6: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "Given a proposition ยง0, the *negation* of ยง1 &mdash; abbreviated ยง2 &mdash; is defined to be the proposition ยง3.\n"
"\n"
"If we have a proof of ยง4 and also a proof of ยง5 then we get something very strange: a proof of ยง6!\n"
"\n"
"This can be expressed in various different ways, as we shall see over the next few levels.\n"
"\n"
"In this level, we encode this statement in the way that allows for the simplest proof.\n"
"\n"
"In subsequent levels, we shall express this tautology in several logically equivalent forms."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.ProductWorld.L06_Currying
msgid "What sort of inputs does the function ยง0 require?"
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "Left Inclusion"
msgstr ""

#. ยง0: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "How can we apply the hypothesis ยง0?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `f : A โ B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `A ร B`
#. ยง9: `p : A ร B`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `A ร B`
#. ยง13: `A ร B`
#: Game.Levels.ProductWorld
msgid "In Function World, we learned that for any types ยง0 and ยง1 there is a new type ยง2 whose elements ยง3 are *functions* from ยง4 to ยง5.\n"
"\n"
"In this world, we'll meet another binary type forming operation.\n"
"\n"
"Given two types ยง6 and ยง7, there is a type ยง8 called the *product type* whose elements ยง9 should be thought of as encoding ordered pairs of elements, one from ยง10 and one from ยง11.\n"
"\n"
"Like the analogy between function types and implication, there is a close analogy between product types and the logical operation of conjunction.\n"
"\n"
"To understand how products work in type theory we must learn:\n"
"\n"
"* How to construct elements of type ยง12.\n"
"* How to use elements of type ยง13 to construct elements of other types."
msgstr ""

#. ยง0: `ยฌ (P โ Q)`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โง ยฌ Q`
#. ยง8: `ยฌ (P โ Q)`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `P โ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"The implication asserts that if ยง3 is true then ยง4 must be true as well.\n"
"\n"
"So if we show that ยง5 is true but ยง6 is false, this would disprove the implication.\n"
"\n"
"In this level, we will prove that ยง7 implies ยง8. That is, if ยง9 is true and ยง10 is false, then ยง11 is not true."
msgstr ""

#. ยง0: `Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving`
#: Game
msgid "This was created using the GameSkeleton Github Repo from the Lean Games Server hosted by ADAM: Anticipating the Digital Age of Mathematics at Heinrich Heine University Dรผsseldorf. It is designed for a first year seminar course taught at Johns Hopkins University in Fall 2025 with the title ยง0."
msgstr ""

#. ยง0: `P`
#. ยง1: `False.elim : False โ P`
#. ยง2: `False`
#. ยง3: `P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition ยง0, ยง1 proves that ยง2 implies ยง3."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `ยซ{rs}ยป : ยซ{R}ยป โจ ยซ{S}ยป`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "This completes the proof in the case where ยง0 holds because ยง1 holds. Now we've started the case where ยง2 holds, which requires another case split over the proof ยง3."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Define the canonical function projecting from a product type to its second argument."
msgstr ""

#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "Evaluation"
msgstr ""

#: Game.Levels.DisjunctionWorld
msgid "Disjunction World"
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `R โจ S`
#. ยง2: `P โง R`
#. ยง3: `P โง S`
#. ยง4: `Q โง R`
#. ยง5: `Q โง S`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "A more involved form of distributivity is also true.\n"
"\n"
"If ยง0 holds and ยง1 holds then at least one of the following four propositions holds: ยง2 or ยง3 or ยง4 or ยง5.\n"
"\n"
"Demonstrate the following logical equivalence."
msgstr ""

#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Composing functions"
msgstr ""

#. ยง0: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L05_Absurd
#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What is the logical structure of the type of ยง0?"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "The goal is a product type. You can use ยง0 to split into two goals, defining each component function separately."
msgstr ""

#. ยง0: `Empty`
#. ยง1: `Empty`
#. ยง2: `A`
#. ยง3: `Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The type ยง0 has no elements &mdash; or, more precisely, the type ยง1 has no introduction rules.\n"
"\n"
"Consequently, for any other type ยง2, there is always a function ยง3.\n"
"\n"
"The task in this level is to define it."
msgstr ""

#. ยง0: `ยฌ(P โจ ยฌ P)`
#. ยง1: `ยฌ P โง ยฌ ยฌ P`
#. ยง2: `ยซ{nlem}ยป`
#. ยง3: `ยฌP`
#. ยง4: `ยซ{nlem}ยป`
#. ยง5: `ยฌ ยฌ P`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "Recall that ยง0 is logically equivalent to ยง1. Can you use ยง2 to prove ยง3? And then can you used ยง4 to prove ยง5?"
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "In classical logic, for any proposition ยง0, ยง1 is true or ยง2 is true."
msgstr ""

#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "Excluded Middle"
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "For the Boss Level of Empty World, we construct something that is just weird.\n"
"\n"
"Have fun!"
msgstr ""

#. ยง0: `cases ยซ{x}ยป`
#. ยง1: `rcases ยซ{x}ยป with a | b`
#. ยง2: `ยซ{x}ยป : A โ B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use either ยง0 or ยง1 to consider the possible cases for the variable ยง2."
msgstr ""

#. ยง0: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Type ยง0 to tell Lean that we are appealing to the proof by contradiction strategy."
msgstr ""

#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Modus Ponens Again"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Note the goal window in the interactive theorem prover keeps track of exactly what proposition you are trying to prove."
msgstr ""

#. ยง0: `A โ B โ B โ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The coproduct type, like the product type, is *symmetric*, and in particular has a canonical map of type ยง0. Your task in this level is to define it."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `P โ Q`
#. ยง4: `p : P`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โ Q`
#. ยง8: `intro p`
#. ยง9: `p : P`
#. ยง10: `Q`
#. ยง11: `Q`
#. ยง12: `P`
#. ยง13: `P`
#. ยง14: `P โ P`
#. ยง15: `P`
#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "To prove an implication ยง0 one needs to give a construction of a proof of ยง1 from a hypothesized proof of ยง2.\n"
"\n"
"In particular, to prove that ยง3 it suffices to assume that we have a proof ยง4 &mdash; even if ยง5 is false and such a proof does not exist &mdash; in which case the new goal is to find a proof of ยง6.\n"
"\n"
"When the goal has the form ยง7, type ยง8 to introduce an assumption ยง9 and update the goal to proving ยง10 &mdash; asking for a proof that ยง11 is true under the assumption that ยง12 is true.\n"
"\n"
"In this level, we will see that for any proposition ยง13, ยง14 is true. Indeed, this is the case even if ยง15 itself is false!"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "For any propositions ยง0 and ยง1, if ยง2 is true and ยง3 is false, then ยง4 is not true."
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ProvingImplication
msgid "Proving Implication"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A ร B`
#. ยง3: `A`
#. ยง4: `A ร Empty`
#. ยง5: `A ร Empty`
#. ยง6: `A ร Empty`
#. ยง7: `Empty โ A ร Empty`
#. ยง8: `A ร Empty โ Empty`
#. ยง9: `A ร Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Recall that for any types ยง0 and ยง1, there is a *product type* denoted ยง2.\n"
"\n"
"In particular, for any type ยง3, we may form the product ยง4 with the empty type.\n"
"\n"
"Elements of product types are pairs of elements, one from the first type and one from the second type.\n"
"\n"
"But the empty type does not have any elements! So this means the product ยง5 cannot have any elements either.\n"
"\n"
"More precisely, the type ยง6 is *equivalent* to the empty type in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions ยง7 and ยง8, which as discussed in a previous level, indicates that ยง9 cannot have any elements either."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Ex Falso"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#: Game.Levels.ProductWorld.L01_Pairing
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Now Lean asks you to supply an element of type ยง0. Which tactic applies here?"
msgstr ""

#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "Proving Excluded Middle"
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Uncurrying"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Now how do we prove a conjunction?"
msgstr ""

#. ยง0: `cases`
#. ยง1: `rcases`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "This proves the symmetry of disjunction. Practice using both the ยง0 and ยง1 tactics to get used to them."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `ยฌ (P โจ Q)`
#. ยง3: `ยฌ P โง ยฌ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "For any propositions ยง0 and ยง1, the propositions ยง2 and ยง3 are logically equivalent."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "This can be solved in two ways. Can you find them both?"
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingAssumedImplication
msgid "Proving Assumed Implication"
msgstr ""

#. ยง0: `exact`
#. ยง1: `ยซ{f}ยป`
#. ยง2: `apply`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "You can use the tactic ยง0 by supplying ยง1 with two arguments, in the correct order, with spaces in between (but no parentheses). Alternatively you can use the tactic ยง2."
msgstr ""

#. ยง0: `assumption`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "The ยง0 tactic tries to solve the main goal using a hypothesis of compatible type, or else fails."
msgstr ""

#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In the next world, we will finally introduce the slippery topic of equality."
msgstr ""

#: Game.Levels.CoproductWorld
msgid "Coproduct World"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Sum.inl : A โ A โ B`
#. ยง3: `A`
#. ยง4: `A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types ยง0 and ยง1, the function ยง2 can be used to include elements of type ยง3 as elements of the coproduct type ยง4."
msgstr ""

#. ยง0: `p : P`
#. ยง1: `h : P โ Q`
#. ยง2: `Q`
#. ยง3: `h p : Q`
#. ยง4: `Q`
#. ยง5: `h : P โ Q`
#. ยง6: `p : P`
#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Modus ponens tells us that under hypotheses ยง0 and ยง1 then ยง2 is true.\n"
"\n"
"In fact there is another syntax that may be used to write this proof. In Lean, we may write ยง3 for the proof of ยง4 obtained by applying the hypothesis ยง5 to the proof ยง6.\n"
"\n"
"Can you see why the following theorem is another form of modus ponens?"
msgstr ""

#. ยง0: `h : P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `R`
#. ยง6: `P`
#. ยง7: `R`
#. ยง8: `Q`
#. ยง9: `Q`
#. ยง10: `R`
#. ยง11: `P`
#. ยง12: `h : P โจ Q`
#. ยง13: `cases h`
#. ยง14: `P`
#. ยง15: `Q`
#. ยง16: `cases`
#. ยง17: `h : P โจ Q`
#. ยง18: `rcases h with p | q`
#. ยง19: `cases h`
#. ยง20: `p : P`
#. ยง21: `q : Q`
#. ยง22: `p`
#. ยง23: `q`
#. ยง24: `P โจ Q`
#. ยง25: `Q โจ P`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Given a hypothesis ยง0 we know that *either* ยง1 or ยง2 is true (or possibly both are true).\n"
"\n"
"But we don't know *which* of ยง3 or ยง4 is true.\n"
"\n"
"If we want to use a hypothesis like this to prove some other proposition ยง5 is true we need proofs that cover either of the two cases: that is, we need to show that ยง6 implies ยง7 (whether or not ยง8 is true) and also that ยง9 implies ยง10 (whether or not ยง11 is true).\n"
"\n"
"If we have an assumption of the form ยง12, then type ยง13 to ask Lean to consider both cases: the first being that ยง14 is true and the second being that ยง15 is true.\n"
"\n"
"There is another tactic, similar to ยง16, which allows you to give explicit names for the hypotheses assumed in each case.\n"
"\n"
"If given a hypothesis ยง17, then ยง18 can be used in place of ยง19 to give hypotheses ยง20 in the first case and ยง21 in the second. (Here you can choose any variable names for ยง22 and ยง23.)\n"
"\n"
"For example, arguing by cases, we can prove that or is symmetric, that is that ยง24 implies ยง25."
msgstr ""

#. ยง0: `exact ยซ{p}ยป.1`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Now type ยง0 to return the first projection."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a still function type, so continue with ยง0."
msgstr ""

#. ยง0: `g : A โ C`
#. ยง1: `h : B โ C`
#. ยง2: `A โ B โ C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "We've seen that functions out of a coproduct can be split into component functions. Similarly, component functions ยง0 and ยง1 can be assembled into a function of type ยง2, as we will explore in the next level."
msgstr ""

#. ยง0: `g : X โ A`
#. ยง1: `h : X โ A`
#. ยง2: `X`
#. ยง3: `A ร B`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "Combine a pair of functions ยง0 and ยง1 into a single function from ยง2 to the product type ยง3."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `Classical.em P  : P โจ ยฌ P`
#. ยง6: `P`
#. ยง7: `em P : P โจ ยฌ P`
#. ยง8: `byContradiction : ยฌ ยฌ P โ P`
#. ยง9: `P`
#. ยง10: `em`
#. ยง11: `em`
#. ยง12: `P`
#. ยง13: `P`
#. ยง14: `Q`
#: Game.Levels.ClassicalWorld.L02_ExcludedMiddle
msgid "The *law of excluded middle* asserts that for any proposition ยง0, either ยง1 is true or ยง2 is false.\n"
"\n"
"In other words, for any proposition ยง3, ยง4 is always true.\n"
"\n"
"Lean has a built-in name ยง5 for *the law of excluded middle* at the proposition ยง6. In Classical World, classical reasoning techniques are open, so you can refer to this proof by typing ยง7.\n"
"\n"
"Note that in contrast to ยง8, the proposition ยง9 is an *explicit argument* of the function ยง10. So if you type just ยง11, Lean will ask which proposition you have in mind.\n"
"\n"
"This is because when you are applying proof by contradiction, it is usually clear from context which proposition ยง12 is involved, whereas when you are appealing to the law of excluded middle, this is often not so clear.\n"
"\n"
"See if you can use the law of excluded middle to prove that for any propositions ยง13 and ยง14 one\n"
"of the following four conjunctions holds."
msgstr ""

#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "Next move on to Conjunction World to meet our second logical connective."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P โจ Q`
#. ยง2: `P โง Q โ P โจ Q`
#. ยง3: `P โจ Q โ P โง Q`
#. ยง4: `P โง Q โ P โจ Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โจ Q`
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "The proposition ยง0 is *stronger* than the proposition ยง1 because ยง2 is true in general, but the implication ยง3 does not necessarily hold.\n"
"\n"
"Note the implication ยง4 holds because the mathematical *or* is &ldquo;inclusive&rdquo;, meaning that if ยง5 and ยง6 are both true, then ยง7 is true, and in fact can be proven in two different ways."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `exact ยซ{p}ยป`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "To use the hypothesis ยง0 to reach this conclusion type ยง1."
msgstr ""

#. ยง0: `(P โง Q) โง R`
#. ยง1: `P โง (Q โง R)`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Conjunction is associative: ยง0 is true if and only if ยง1 is true."
msgstr ""

#. ยง0: `โง`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the ยง0 is the outermost logical connective. How do you prove conjunctions?"
msgstr ""

#: Game.Levels.ImplicationWorld.L08_ModusPonensAgain
msgid "Now we are ready for the boss level!"
msgstr ""

#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "Think about where the contradiction will ultimately arise from."
msgstr ""

#. ยง0: `ยซ{i}ยป`
#. ยง1: `ยซ{p}ยป`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What can we prove with the hypotheses ยง0 and ยง1?"
msgstr ""

#. ยง0: `ยซ{f}ยป ยซ{x}ยป`
#. ยง1: `exact ยซ{f}ยป ยซ{x}ยป`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "What is the type of the term ยง0? If you're not sure, you can type ยง1 and read the error message to find out."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `g โ f : A โ C`
#. ยง5: `\\circ`
#. ยง6: `โ`
#. ยง7: `g โ f`
#. ยง8: `a : A`
#. ยง9: `f a : B`
#. ยง10: `g (f a) : C`
#. ยง11: `comp : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง12: `g : B โ C`
#. ยง13: `f : A โ B`
#. ยง14: `comp g f : A โ C`
#. ยง15: `g`
#. ยง16: `f`
#. ยง17: `a : A`
#. ยง18: `g (f a) : C`
#. ยง19: `comp`
#. ยง20: `โ`
#. ยง21: `comp g f`
#. ยง22: `g โ f`
#: Game.Levels.FunctionWorld.L07_CompositionRevisited
msgid "Recall that given functions ยง0 and ยง1 there is a *composite function* from ยง2 to\n"
"ยง3 denoted ยง4, using ยง5 to type ยง6.\n"
"\n"
"The function ยง7 is defined to be the function that sends ยง8 first to the element ยง9 and then\n"
"to the element ยง10.\n"
"\n"
"Define composition as a multivariable function between function types ยง11.\n"
"\n"
"We think of composition as the function that takes ยง12 and ยง13 to the composite function ยง14.\n"
"\n"
"It can also be thought of a function that takes ยง15, ยง16, and ยง17 to the element ยง18.\n"
"\n"
"Aside: Lean treats the functions ยง19 and ยง20 slightly differently because the former uses the usual notation for multivariable functions (where the arguments are provided afterwards as ยง21) while the latter uses infix notation (where the function name appears inbetween the two arguments as ยง22)."
msgstr ""

#. ยง0: `P`
#. ยง1: `exact ยซ{p}ยป`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now the goal is just to prove ยง0. Type ยง1 to supply this proof."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `a : A`
#. ยง3: `const a : B โ A`
#. ยง4: `x : B`
#. ยง5: `a : A`
#: Game.Levels.FunctionWorld.L04_ConstantFunctions
msgid "For any types ยง0 and ยง1 and element ยง2, there is a constant function ยง3 that sends any ยง4 to the element ยง5."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Alternatively, you can type `exact โจp,qโฉ' using '\\<' and '\\>' to type the angle brackets."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โง ยฌ Q โ ยฌ (P โ Q)`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In Negation World, we proved that for any propositions ยง0 and ยง1:\n"
"\n"
"ยง2.\n"
"\n"
"The objective of the Boss Level is to prove the converse implication.\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "In the next level we'll meet the universal property of conjunctions."
msgstr ""

#. ยง0: `T โจ U โ V โง Y`
#. ยง1: `Q โ P โ T`
#. ยง2: `Y โ Q โ W`
#. ยง3: `(V โง W) โจ (X โง Y) โ Z`
#. ยง4: `(R โ S โ U) โง (V โ R โ X)`
#. ยง5: `P โง (Q โจ R) โง S`
#. ยง6: `Z`
#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "If ยง0 and ยง1 and ยง2 and\n"
"ยง3 and ยง4 then  ยง5 implies ยง6."
msgstr ""

#. ยง0: `A`
#. ยง1: `a : A`
#. ยง2: `a = a`
#. ยง3: `rfl : a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For a type ยง0 and element ยง1, the proposition ยง2 is true because there is a proof\n"
"ยง3 witnessing the reflexivity of equality."
msgstr ""

#. ยง0: `And.symm`
#. ยง1: `exact And.symm`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? In fact, we gave a name ยง0 to the proof given in the previous level, as you can see in the list of theorems to the right. Try typing ยง1 at an appropriate place in your proof."
msgstr ""

#. ยง0: `g : B โ C`
#. ยง1: `f : A โ B`
#. ยง2: `g โ f : A โ C`
#. ยง3: `x : A`
#. ยง4: `g (f x)`
#: Game.Levels.FunctionWorld.L03_ComposingFunctions
msgid "Given functions ยง0 and ยง1, define the composite function ยง2 that sends ยง3 to ยง4."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now the goal is a function type. What tactic is used to define functions?"
msgstr ""

#. ยง0: `Function.curry : (A ร B โ C) โ (A โ B โ C)`
#. ยง1: `A โ B โ C`
#. ยง2: `A ร B โ C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"We'll now study the reverse process, which converts a function of type ยง1 to a function of type ยง2."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `apply ยซ{f}ยป`
#. ยง2: `ยซ{A}ยป`
#. ยง3: `ยซ{B}ยป`
#: Game.Levels.FunctionWorld.L05_MultivariableFunctions
msgid "Since ยง0 is a function with two variables, after ยง1 we now have two goals, where we need to supply first an element of type ยง2 and then an element of type ยง3."
msgstr ""

#. ยง0: `h : S โ T`
#. ยง1: `apply h`
#. ยง2: `T`
#. ยง3: `S`
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
#: Game.Levels.ImplicationWorld.L03_ComposingImplication
msgid "In the presence of a hypothesis ยง0, the tactic ยง1 reduces the problem of proving ยง2 to the problem of proving ยง3. Can this be used here?"
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Define the canonical function projecting from a product type to its first argument."
msgstr ""

#. ยง0: `S โ X`
#. ยง1: `T โ W`
#. ยง2: `R โ Y`
#. ยง3: `W โ Q`
#. ยง4: `U โ S`
#. ยง5: `Y โ T`
#. ยง6: `X โ V`
#. ยง7: `Q โ U`
#. ยง8: `V โ Z`
#. ยง9: `P โ R`
#. ยง10: `P`
#. ยง11: `Z`
#: Game.Levels.ImplicationWorld.L09_BossLevel
msgid "If ยง0, ยง1, ยง2, ยง3, ยง4, ยง5, ยง6, ยง7, ยง8 and ยง9 are true then ยง10 implies ยง11."
msgstr ""

#. ยง0: `B โ A โ A โ B`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The same construction defines a function of type ยง0, demonstrating the symmetry of the coproduct."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.FunctionWorld.L06_SwappingInputs
msgid "Look carefully at the order of the arguments of ยง0."
msgstr ""

#: Game.Levels.ConjunctionWorld
msgid "Conjunction World"
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "From Empty"
msgstr ""

#. ยง0: `ยฌ (P โง ยฌ P)`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `ยฌ P`
#. ยง4: `P โ ยฌ P โ Q`
#. ยง5: `ยฌ P โ P โ Q`
#. ยง6: `P`
#. ยง7: `P โ Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "In the last level we provided the *law of noncontradiction*: ยง0\n"
"\n"
"In this level, we will see that it is possible to prove any proposition ยง1 from the hypothesis that both ยง2 and ยง3 are true.\n"
"\n"
"In other words, ยง4 is always true.\n"
"\n"
"If we swapped order of the hypotheses, a similar proof would also show that ยง5 is true. In other words, if ยง6 is false, then ยง7 is always true.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#. ยง2: `ยฌ Q โ ยฌ P`
#. ยง3: `P โ Q`
#. ยง4: `ยฌ Q โ ยฌ P`
#. ยง5: `P โ Q`
#: Game.Levels.ClassicalWorld.L03_Contrapositive
msgid "We have seen that the implication ยง0 implies the implication ยง1.\n"
"\n"
"The implication ยง2 is called the *contrapositive* of ยง3.\n"
"\n"
"In classical logic, these two statements are logically equivalent.\n"
"\n"
"That means, arguing classically, we can prove that ยง4 implies ยง5.\n"
"\n"
"Can you figure out how to prove this?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `b : A`
#. ยง4: `A โ B`
#. ยง5: `Sum.inr : B โ A โ B`
#. ยง6: `Sum.inl, Sum.inr : A โ A โ A`
#. ยง7: `A`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types ยง0 and ยง1, the coproduct type ยง2 has two kinds of elements. The second kind can be thought of as copies of elements ยง3 included into the coproduct ยง4 *on the right*.\n"
"\n"
"Lean has a built in function called ยง5.\n"
"\n"
"Note that ยง6 are *different functions* (as long as the type ยง7 has at least one element) in a way we will be able to make more precise later."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty.elim : Empty โ A`
#. ยง2: `f : A โ Empty`
#. ยง3: `A`
#. ยง4: `Empty`
#. ยง5: `A`
#. ยง6: `A`
#. ยง7: `f : A โ Empty`
#. ยง8: `a : A`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have seen that any type ยง0 has a function from the empty type ยง1.\n"
"\n"
"By contrast, if there is a function ยง2 from ยง3 to the empty type ยง4 then ยง5 must be very special: this is only possible if ยง6 is *equivalent* to the empty type.\n"
"\n"
"We do not have all the tools needed to define equivalence of types just yet, so in this level we observe something else.\n"
"\n"
"We will see that if there is a function ยง7 and if there is an element ยง8, then we get an element of the empty type, which is very strange indeed!"
msgstr ""

#. ยง0: `(P โง Q โ R) โ (P โ Q โ R)`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "This proves that ยง0. We will now investigate the converse implication."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `absurd`
#. ยง3: `P โ ยฌ P โ Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "For any propositions ยง0 and ยง1, ยง2 proves that ยง3."
msgstr ""

#. ยง0: `ยซ{c}ยป.1`
#. ยง1: `ยซ{c}ยป.2`
#. ยง2: `ยซ{c}ยป : P โง ยฌ P`
#. ยง3: `have := ยซ{c}ยป.1`
#. ยง4: `have := ยซ{c}ยป.2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that ยง0 and ยง1 are the notations used for components of a conjunction, like ยง2. You can use these names directly or introduce them as assumptions with ยง3 and ยง4."
msgstr ""

#: Game.Levels.ClassicalWorld.L05_ProvingExcludedMiddle
msgid "We are now ready for the Boss Level of Classical World."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Component Functions"
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty`
#. ยง2: `A ร Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "For any type ยง0, there are functions in both directions between the types ยง1 and ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type ยง0, there is a function ยง1 encoding the elimination rule of the empty type."
msgstr ""

#. ยง0: `have nq : ยฌ Q := ยซ{pnq}ยป.2`
#. ยง1: `ยฌ Q`
#. ยง2: `\\neg`
#. ยง3: `ยฌ`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try ยง0 to add a proof of ยง1 to your\n"
"assumptions, where ยง2 is used to type ยง3."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImpliedAssumption
msgid "Proving Implied Assumption"
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `Sum.inl : A โ A โ B`
#. ยง2: `g : A โ C`
#. ยง3: `f`
#. ยง4: `f : A โ B โ C`
#. ยง5: `Sum.inr : B โ A โ B`
#. ยง6: `h : B โ C`
#. ยง7: `A โ B โ C`
#. ยง8: `A โ C`
#. ยง9: `B โ C`
#. ยง10: `A โ B โ C`
#. ยง11: `(A โ C) ร (B โ C)`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Consider a function ยง0 mapping out of a coproduct type.\n"
"\n"
"By composing with the function ยง1 we obtain a function ยง2 which can be thought of as one of the two *component functions* associated to ยง3.\n"
"\n"
"The other component function is defined by composing ยง4 with the function ยง5 to obtain a function ยง6.\n"
"\n"
"Since a *single* function of type ยง7 decomposes into a pair of functions of types ยง8 and ยง9, we will define a function from the function type ยง10 into the product of the function types ยง11."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Negating Disjunction"
msgstr ""

#. ยง0: `ยซ{f}ยป : ยซ{A}ยป โ ยซ{B}ยป`
#. ยง1: `ยซ{a}ยป : ยซ{A}ยป`
#. ยง2: `ยซ{f}ยป ยซ{a}ยป`
#. ยง3: `exact ยซ{f}ยป ยซ{a}ยป`
#. ยง4: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The syntax for the application of the function ยง0 on the element ยง1 is just ยง2. So type ยง3 to obtain an element of type ยง4."
msgstr ""

#. ยง0: `ev : A โ (A โ B) โ B`
#. ยง1: `fun a f โฆ f a`
#. ยง2: `(A โ B) โ A โ B`
#. ยง3: `fun f a โฆ f a`
#: Game.Levels.FunctionWorld.L08_Evaluation
msgid "The evaluation function has type ยง0 and is defined by the formula ยง1. By swapping variables, we can also think of evaluation as defining a function ยง2 where this latter function is defined by ยง3."
msgstr ""

#. ยง0: `ยฌ (P โง Q)`
#. ยง1: `ยฌ P โง ยฌ Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Combined with what we know already, we have established a logical equivalence between  ยง0 and ยง1 in classical logic."
msgstr ""

#. ยง0: `h : P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `And.symm h`
#. ยง4: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Given a hypothesis ยง0 for some propositions ยง1 and ยง2, ยง3 is a proof of ยง4."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Boss level"
msgstr ""

#. ยง0: `(P โจ Q) โง (R โจ S)`
#. ยง1: `(P โง R) โจ (P โง S) โจ (Q โง R) โจ (Q โง S)`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "ยง0 holds if and only if ยง1 holds."
msgstr ""

#. ยง0: `Empty.elim : Empty โ A`
#. ยง1: `exact Empty.elim`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Lean has a built-in name ยง0 for the function you have just defined. Thus ยง1 will also solve this level. This function has been added to the library."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `(A โ C) ร (B โ C)`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "We will see later that functions of type ยง0 are uniquely determined by their component functions ยง1."
msgstr ""

#. ยง0: `X โ A ร B`
#. ยง1: `(X โ A) ร (X โ B)`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The *universal property* of the product is the correspondence between functions ยง0 into a product and pairs of functions ยง1.\n"
"\n"
"We are now ready for the boss level of Product World."
msgstr ""

#. ยง0: `Q`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "It is possible to prove any proposition ยง0 from the hypothesis that both ยง1 and ยง2 are true."
msgstr ""

#. ยง0: `P`
#. ยง1: `Classical.byContradiction : ยฌ ยฌ P โ P`
#. ยง2: `P`
#. ยง3: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "For any proposition ยง0, ยง1 proves that if ยง2 is not false, then ยง3 is true."
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "In a compound proposition, the outermost logical connective (the one applied last in forming the proposition) often determines the overall proof strategy."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Have a look at the library of definitions for a function whose domain is the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Logical Equivalence"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P`
#. ยง2: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "In classical logic, for any proposition ยง0, ยง1 implies ยง2."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "How can you use ยง0 and ยง1 to get a contradiction?"
msgstr ""

#: Game.Levels.EmptyWorld
msgid "Empty World"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `P`
#. ยง3: `False`
#. ยง4: `p : P`
#. ยง5: `P`
#. ยง6: `False`
#. ยง7: `P`
#. ยง8: `np : ยฌ P`
#. ยง9: `P`
#. ยง10: `False`
#. ยง11: `np : ยฌ P`
#. ยง12: `False`
#. ยง13: `ยฌ ยฌ P`
#. ยง14: `ยฌ ยฌ P โ P`
#. ยง15: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Let ยง0 be a proposition.\n"
"\n"
"We have learned that there is a default strategy to prove ยง1, i.e., that ยง2 implies ยง3.\n"
"\n"
"The strategy is to start by assuming we have a proof ยง4, in other words, assuming that ยง5 is true.\n"
"\n"
"Then the goal is to derive an element of ยง6, also known as a *contradiction*.\n"
"\n"
"This proof strategy is fully compatible with constructive mathematics.\n"
"\n"
"There is a related, by distinct, strategy that can be used to prove a proposition ยง7 assuming classical logic called &ldquo;proof by contradiction&rdquo;. Here one assumes we have a proof ยง8, in other words, assuming that ยง9 is false.\n"
"\n"
"Then the goal is again to derive an element of ยง10, also known as a contradiction.\n"
"\n"
"Such a proof &mdash; assuming ยง11 and then deriving an element of ยง12 &mdash; constructs an element of ยง13.\n"
"\n"
"In classical logic, there is an implication ยง14, which is why &ldquo;proof by contradiction&rdquo; can be used to ultimately prove that ยง15 is true."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `f a : B`
#. ยง3: `f`
#. ยง4: `a`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Given a function ยง0 and an element ยง1, there is an element ยง2 obtained by evaluating the function ยง3 at ยง4."
msgstr ""

#: Game
msgid "First Year Seminar 270"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Modus Tollens"
msgstr ""

#: Game
msgid "Mathematicians from all over &mdash; most of whom have never met one another &mdash; nevertheless agree to an incredible extent about the nature of the mathematical universe. How did this degree of consensus come about?\n"
"\n"
"Firstly mathematicians have developed a precise formal language which allows them to define new abstract concepts and state their properties in an unambiguous way. A mathematical *proposition* is a well-formed mathematical statement that is either true or false, for instance:\n"
"\n"
"* &ldquo;There are infinitely many prime numbers.&rdquo;\n"
"* &ldquo;Every prime number is even.&rdquo;\n"
"* &ldquo;There are infinitely many prime numbers that are two less than another prime.&rdquo;\n"
"\n"
"Mathematicians distinguish between the true propositions, the false ones, and the ones whose truth value is not yet known through *proofs* made precise in the formal language of mathematical logic.\n"
"\n"
"While the idea of a mathematical proof is over 2000 years old, the practice of proof writing continues to evolve. Today mathematicians may elect to use a tool called a computer proof assistant that can provide real-time feedback to a theorem prover about the status of a logical argument that is currently under development.\n"
"\n"
"The aim of this game will be to introduce proof writing in a computer proof assistant while developing skils that can be used to develop proofs in other contexts: on paper, in conversation with a friend, or in your head.\n"
"\n"
"There is one caveat, that we will address explicitly. The formal vocabulary we will introduce to discuss mathematical proof is somewhat different from the one that most mathematicians learn. The mathematics we will be developing is essentially unchanged but the formal language introduced here will make it easier to be fully precise about every step in a proof, as is required to convince a computer that a logical argument in sound."
msgstr ""
