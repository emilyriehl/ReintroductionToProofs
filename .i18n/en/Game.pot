msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-20\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "In the next level, we will meet the universal property of conjunctions."
msgstr ""

#. ยง0: `Empty.elim`
#. ยง1: `Prod.snd`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "If your answer does not use the functions ยง0 and ยง1, you might have fun trying to solve this level again using them in appropriate places."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "While the goal is complicated to read, the outermost logical connective is a conjunction."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `A`
#. ยง2: `h : โ x : A, P x`
#. ยง3: `x : A`
#. ยง4: `P x`
#. ยง5: `a : A`
#. ยง6: `h`
#. ยง7: `P a`
#. ยง8: `h`
#. ยง9: `x : A`
#. ยง10: `h x : P x`
#. ยง11: `P x`
#. ยง12: `h`
#. ยง13: `h x`
#. ยง14: `P x`
#. ยง15: `h y`
#. ยง16: `P y`
#. ยง17: `h a : P a`
#. ยง18: `P a`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Let ยง0 be a predicate over a type ยง1.\n"
"\n"
"Suppose we have a proof ยง2 that for all ยง3, ยง4 is true.\n"
"\n"
"Then if we are given any particular ยง5. We can use ยง6 to provide a proof of ยง7.\n"
"\n"
"How?\n"
"\n"
"Recall that we can think of proofs of universally quantified statements as *dependent functions*.\n"
"\n"
"Thus, ยง8 can be thought of as a function that takes ยง9 to a proof ยง10 of the proposition ยง11.\n"
"\n"
"We say that ยง12 is a *dependent* function because the element ยง13 proves the proposition ยง14, while the element ยง15 proves a different proposition, namely ยง16.\n"
"\n"
"In particular, ยง17 is our desired proof of the proposition ยง18."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "More Component Functions"
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Disjunction Boss Level"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f`
#. ยง3: `f`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "For functions ยง0 and ยง1 if ยง2 is injective, then so is ยง3."
msgstr ""

#. ยง0: `left`
#. ยง1: `right`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "The tactics ยง0 and ยง1 are useful for defining elements of coproduct types or defining functions valued in coproduct types. In the next level, we will begin to consider functions mapping out of coproduct types."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `f : A โ B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A ร B`
#. ยง7: `โจa, bโฉ : A ร B`
#. ยง8: `a : A`
#. ยง9: `b : B`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `A โ B`
#. ยง13: `a : A`
#. ยง14: `Sum.inl a : A โ B`
#. ยง15: `b : B`
#. ยง16: `Sum.inr b : A โ B`
#. ยง17: `f : A โ B โ C`
#. ยง18: `C`
#. ยง19: `A`
#. ยง20: `B`
#: Game.Levels.CoproductWorld
msgid "Given any types ยง0 and ยง1 we have studied\n"
"\n"
"* function types ยง2 whose elements ยง3 are *functions* from ยง4 to ยง5 and\n"
"\n"
"* product types ยง6 whose elements ยง7 are *pairs* of elements ยง8 and ยง9.\n"
"\n"
"In this world, we'll study another binary type forming operation. Given two types ยง10 and ยง11, there is a type ยง12 called the *coproduct type* which has two varieties of elements:\n"
"\n"
"* elements ยง13 define elements ยง14\n"
"* elements ยง15 define elements ยง16.\n"
"\n"
"Together, these constructions define the two *introduction rules* for coproduct types. Coproduct types also have an *elimination rule*, which gives a strategy for defining a function ยง17 whose inputs belong to a coproduct type and whose outputs take values in an arbitrary type ยง18.\n"
"\n"
"This elimination rule tells us that functions out of a coproduct can be defined &ldquo;by cases&rdquo; &mdash; that is, by independently specifying the images of those elements that come from ยง19 and those elements that come from ยง20.\n"
"\n"
"Collectively, these rules characterize coproduct types and can be used to establish their properties, which we will explore in the levels that follow."
msgstr ""

#. ยง0: `ยฌ Q`
#. ยง1: `Q โ False`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that ยง0 is an abbreviation for the type ยง1."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "The function ยง0 is bijective."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `A โ C`
#. ยง2: `B โ C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "A function of type ยง0 may be split into component functions of types ยง1 and ยง2."
msgstr ""

#. ยง0: `x y : Empty`
#. ยง1: `x = y`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "The empty type is a proposition: for ยง0, ยง1."
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "Absurd"
msgstr ""

#. ยง0: `A โ B โ C โ D โ E`
#. ยง1: `A โ (B โ (C โ (D โ E)))`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "More generally, ยง0 abbreviates the iterated function type ยง1. Explicit parentheses must be used to express iterated function types with any other parenthesizations."
msgstr ""

#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "More Transitivity"
msgstr ""

#. ยง0: `gf_is_surj`
#. ยง1: `ยซ{c}ยป`
#. ยง2: `have hc := gf_is_surj ยซ{c}ยป`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "To use the hypothesis ยง0 at ยง1 type ยง2."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What sort of type does ยง0 belong to? Can we extract other elements from an element of this type?"
msgstr ""

#. ยง0: `let`
#. ยง1: `have`
#. ยง2: `let`
#. ยง3: `a : A`
#. ยง4: `b : B`
#. ยง5: `let p : A ร B := โจa, bโฉ`
#. ยง6: `let f : A โ B := fun _ โฆ b`
#. ยง7: `b`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The ยง0 tactic is like ยง1, but for creating elements of types rather than proofs of propositions. The ยง2 tactic will add new elements to your context provided you can define them. For example, given elements ยง3 and ยง4, you can type ยง5 to add their pair to the context or type ยง6 to add the constant function at ยง7 to the context."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `A`
#. ยง2: `โ x : A, P x`
#. ยง3: `a : A`
#. ยง4: `P a`
#. ยง5: `p_a : P a`
#. ยง6: `โจa, p_aโฉ : โ x : A, P x`
#. ยง7: `โจa, p_aโฉ`
#. ยง8: `P a`
#. ยง9: `p_a : P a`
#. ยง10: `a : A`
#. ยง11: `and : Bool โ Bool โ Bool`
#. ยง12: `x && y = and x y`
#. ยง13: `or : Bool โ Bool โ Bool`
#. ยง14: `x || y = or x y`
#. ยง15: `b : B`
#. ยง16: `b && b = b || b`
#. ยง17: `use`
#. ยง18: `โ x : A, P x`
#. ยง19: `use a`
#. ยง20: `a : A`
#. ยง21: `P a`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Let ยง0 be a predicate over a type ยง1.\n"
"\n"
"To prove the proposition ยง2 it suffices to find any element ยง3 so that ยง4 holds.\n"
"\n"
"If you have a proof ยง5, then the same notation used for conjunctions and product types can be used to define an element ยง6.\n"
"\n"
"Here the element ยง7 can be thought of as a *dependent pair*, where the type ยง8 of the right component ยง9 depends on the left component ยง10.\n"
"\n"
"Recall the function ยง11 capturing the logical notion of conjunction. Lean uses alternate notation ยง12.\n"
"\n"
"Recall also the function ยง13 capturing the logical notion of disjunction. Lean uses the alternate notation ยง14\n"
"\n"
"In this level, you are asked to prove that there exists some boolean ยง15 so that ยง16.\n"
"\n"
"The tactic ยง17 is used to introduce proofs of existentially quantified predicates.\n"
"\n"
"If the goal is to prove ยง18, one can type ยง19 referencing a specific element ยง20 to reduce the goal to proving ยง21."
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
#: Game.Levels.BooleanWorld.L07_DeMorgan
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "What is the outermost logical connective?"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `f : A โ B`
#. ยง2: `โ x y : A, f x = f y โ x = y`
#. ยง3: `f : A โ B`
#. ยง4: `b : B`
#. ยง5: `x : A`
#. ยง6: `f x = b`
#. ยง7: `not : Bool โ Bool`
#. ยง8: `not`
#. ยง9: `Bool.not_injective`
#. ยง10: `Bool.not_surjective`
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "We have introduced two properties that may or may not hold of a given function ยง0.\n"
"\n"
"Recall that a function ยง1 is *injective* if ยง2.\n"
"\n"
"Recall that a function ยง3 is *surjective* if for every ยง4 there exists some ยง5 so that ยง6.\n"
"\n"
"If a function is both injective and surjective, then it is called *bijective*.\n"
"\n"
"We have shown that the function ยง7 is both injective and surjective. Thus, we conclude that ยง8 is bijective.\n"
"\n"
"You do not need to reprove these results, which can be found in your library with the names ยง9 and ยง10."
msgstr ""

#. ยง0: `Unit`
#. ยง1: `โจโฉ`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type ยง0 has a canonical element ยง1."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `b : B`
#. ยง3: `f a = b`
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "A function ยง0 must be *total* meaning for each ยง1 there is some ยง2 so\n"
"that ยง3."
msgstr ""

#. ยง0: `.1`
#. ยง1: `.2`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Note the ยง0 and ยง1 notation can be iterated."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `constructor`
#. ยง4: `P โง Q`
#. ยง5: `P`
#. ยง6: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "To prove a conjunction ยง0 we need to supply a proof of both ยง1 and ยง2.\n"
"\n"
"This expresses the introduction rule for the logical operation of conjunction.\n"
"\n"
"Use the tactic ยง3 to ask Lean to break up the goal or proving ยง4 into two steps, of first proving ยง5 and then proving ยง6."
msgstr ""

#. ยง0: `And.symm`
#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "You might be able to shorten your proof by applying the theorem ยง0 from our library at the appropriate point. In the next two levels, we will establish the precise relationship between bijective functions and invertible functions."
msgstr ""

#. ยง0: `A`
#. ยง1: `a : A`
#. ยง2: `a = a`
#. ยง3: `rfl : a = a`
#. ยง4: `rfl`
#. ยง5: `a = a`
#. ยง6: `a = a`
#. ยง7: `exact rfl`
#. ยง8: `rfl`
#. ยง9: `exact rfl`
#. ยง10: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Let ยง0 be a type with an element ยง1. Then the proposition ยง2 is always true\n"
"because there is a proof ยง3 witnessing the *reflexivity* of equality.\n"
"\n"
"In Lean, ยง4 is a name for an element of the type ยง5. So to produce a proof of ยง6, you\n"
"can type ยง7. As a shorthand, Lean also defines a tactic called ยง8 that is shorthand for\n"
"ยง9. So you can solve the goal by typing simply ยง10."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition ยง0, ยง1."
msgstr ""

#. ยง0: `A`
#. ยง1: `A โ Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "In summary, something very strange happens if the types ยง0 and ยง1 both have elements."
msgstr ""

#. ยง0: `x : A ร (B โ C)`
#. ยง1: `x`
#. ยง2: `x`
#. ยง3: `โจy, zโฉ`
#. ยง4: `y : A`
#. ยง5: `z : B โ C`
#. ยง6: `z`
#. ยง7: `Sum.inl b`
#. ยง8: `b : B`
#. ยง9: `Sum.inr c`
#. ยง10: `c : C`
#. ยง11: `x : A ร (B โ C)`
#. ยง12: `โจy, Sum.inl bโฉ`
#. ยง13: `โจy, bโฉ : A ร B`
#. ยง14: `x`
#. ยง15: `โจy, Sum.inr cโฉ`
#. ยง16: `โจy, cโฉ : A ร C`
#. ยง17: `A ร (B โ C) โ (A ร B) โ (A ร C)`
#. ยง18: `(A ร B) โ (A ร C) โ A ร (B โ C)`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "How should we think about an element of type ยง0?.\n"
"\n"
"Since ยง1 belongs to a product type, it can be split into two components. That is ยง2 has the form of a pair ยง3 with ยง4 and ยง5. And since ยง6 belongs to a coproduct type, there are two possible cases: it can have the form ยง7 for some ยง8 or it can have the form ยง9 for some ยง10. In the first case, the original ยง11 is a pair of the form ยง12 coming from ยง13 which in the second case ยง14 is a pair of the form ยง15 coming from ยง16.\n"
"\n"
"This explains the *distributivity* of products over coproducts, which can be encoded by a pair of functions, one of the form ยง17 and the other of the form ยง18.\n"
"\n"
"Your challenge in this level is to define these functions.\n"
"\n"
"While it may be complicated to think about the entire construction at once, you can use the context and goal types at each stage of the construction to help guide you.\n"
"\n"
"The introduction rules and their associated tactics can be used to transform the goal state into simpler goal states. Simultaneously, the elimination rules can be used to define new elements out of any elements that appear in your context of objects."
msgstr ""

#. ยง0: `ยซ{f}ยป : A โ Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have an assumption ยง0. What can be done with an element of a function type?"
msgstr ""

#. ยง0: `intro h1 h2 h3`
#. ยง1: `have`
#. ยง2: `</>`
#. ยง3: `editor mode`
#. ยง4: `>_`
#. ยง5: `typewriter mode`
#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "We are now ready for the Boss Level of Implication World.\n"
"\n"
"Multiple hypothesis can be introduced at once by writing ยง0 etc. You might consider using names that will help you remember which propositions are proven by each hypothesis!\n"
"\n"
"While it is not necessary to solve this level, you may enjoy experimenting with the ยง1 tactic that was recently added to the tactic library.\n"
"\n"
"To delete a proof (or proof attempt) and start over click on the button labelled ยง2 in the upper right hand corner to enter ยง3. Then delete all the lines of your first proof (or proof attempt). Clicking on ยง4 takes you back to ยง5."
msgstr ""

#. ยง0: `have pq : P โง Q := โจยซ{p}ยป , ยซ{nq}ยปโฉ`
#. ยง1: `apply ยซ{npq}ยป`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Try ยง0 or try ยง1."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Second Projection"
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Using Functions"
msgstr ""

#. ยง0: `โ`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the ยง0 is the outermost logical connective. If you've forgotten what this means, you can look it up in the library."
msgstr ""

#. ยง0: `ยซ{f}ยป.1`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What type does ยง0 belong to? Is this useful?"
msgstr ""

#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "Move on to Advanced Function World to use quantifiers to study important properties of functions."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Currying"
msgstr ""

#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Universal Truth"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `A โ B โ C`
#. ยง4: `B โ A โ C`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "For any types ยง0, ยง1, and ยง2, the function types ยง3 and ยง4 are equivalent."
msgstr ""

#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "From a function of two variables, define another function of two variables, where the inputs are swapped."
msgstr ""

#: Game.Levels.BooleanWorld
msgid "Boolean World"
msgstr ""

#. ยง0: `ยฌ (P โง ยฌ P)`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `ยฌ P`
#. ยง4: `P โ ยฌ P โ Q`
#. ยง5: `ยฌ P โ P โ Q`
#. ยง6: `P`
#. ยง7: `P โ Q`
#. ยง8: `exfalso`
#. ยง9: `exfalso`
#. ยง10: `Q`
#. ยง11: `False`
#. ยง12: `False.elim : Empty โ Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "In the last level we proved the *law of noncontradiction*: ยง0.\n"
"\n"
"In this level, we will see that it is possible to prove any proposition ยง1 from the hypothesis that both ยง2 and ยง3 are true.\n"
"\n"
"In other words, ยง4 is always true.\n"
"\n"
"If we swapped order of the hypotheses, a similar proof would also show that ยง5 is true. In other words, if ยง6 is false, then ยง7 is always true.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck.\n"
"\n"
"While not necessary to solve this level, it is also possible to use the tactic ยง8 which is now in your library. The tactic ยง9 reduces the goal of proving a proposition ยง10 to the goal of proving ยง11 by applying the proof of the implication ยง12."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does either proof in this logical equivalence seem familiar? Do they both seem familar?"
msgstr ""

#. ยง0: `ยฌ P`
#. ยง1: `P`
#. ยง2: `P โ False`
#. ยง3: `\\neg`
#. ยง4: `ยฌ`
#: Game.Levels.NegationWorld.L02_Negation
msgid "ยง0, read as &ldquo; not ยง1&rdquo; is an abbreviation for ยง2. Use ยง3 to type ยง4."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `f : A โ Empty`
#. ยง3: `A โ B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "For any types ยง0 and ยง1, if there is a function ยง2 then there is also a function ยง3."
msgstr ""

#. ยง0: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Now Lean reminds you of the other goal, which is to prove ยง0. Which tactic applies here?"
msgstr ""

#. ยง0: `Nat.zero_add : โ n : โ, 0 + n = n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "The second half of this proves the theorem ยง0, which is now in your library."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "Predecessor of Successor"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `
#. flip Function.comp : (A โ B) โ (B โ C) โ (A โ C)`
#. ยง4: `C`
#. ยง5: `Empty`
#. ยง6: `exact flip Function.comp`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types ยง0, ยง1, and ยง2, we have the function ยง3 defined by exchanging the inputs. This specializes in the case where ยง4 is the type ยง5 to define the function we seek here. Indeed, this level can be solved with ยง6. Does this perspective make this construction feel less strange?"
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "Negating Implication"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Recall the ยง0 tactic."
msgstr ""

#. ยง0: `P โจ Q โ R`
#. ยง1: `P โจ Q โ R`
#. ยง2: `P โ R`
#. ยง3: `P`
#. ยง4: `P โจ Q`
#. ยง5: `R`
#. ยง6: `P โจ Q โ R`
#. ยง7: `Q โ R`
#. ยง8: `P โ R`
#. ยง9: `Q โ R`
#. ยง10: `P โจ Q โ R`
#. ยง11: `P โ R`
#. ยง12: `Q โ R`
#. ยง13: `P โจ Q โ R`
#. ยง14: `P โจ Q โ R`
#. ยง15: `(P โ R) โง (Q โ R)`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What must be true in order to have ยง0?\n"
"\n"
"On the one hand, if ยง1 is true, then ยง2 is true, because ยง3 implies ยง4, which implies ยง5.\n"
"\n"
"Similar reasoning shows that if ยง6 is true, then ยง7 is true.\n"
"\n"
"Conversely, if *either* ยง8 or ยง9 are true, this does not necessarily imply that ยง10 is true. Can you see why?\n"
"\n"
"However, if *both* ยง11 and ยง12 are true, then ยง13 is true, as you can argue using the strategy of proof by cases.\n"
"\n"
"The aim of this level is to establish a logical equivalence between ยง14 and ยง15."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `P`
#. ยง3: `False`
#. ยง4: `p : P`
#. ยง5: `P`
#. ยง6: `False`
#. ยง7: `P`
#. ยง8: `np : ยฌ P`
#. ยง9: `P`
#. ยง10: `False`
#. ยง11: `np : ยฌ P`
#. ยง12: `False`
#. ยง13: `ยฌ ยฌ P`
#. ยง14: `ยฌ ยฌ P โ P`
#. ยง15: `P`
#. ยง16: `ยฌ ยฌ P โ P`
#. ยง17: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Let ยง0 be a proposition.\n"
"\n"
"We have learned that there is a default strategy to prove ยง1, i.e., that ยง2 implies ยง3.\n"
"\n"
"The strategy is to start by assuming we have a proof ยง4, in other words, assuming that ยง5 is true.\n"
"\n"
"Then the goal is to derive an element of ยง6, also known as a *contradiction*.\n"
"\n"
"This proof strategy is fully compatible with constructive mathematics.\n"
"\n"
"There is a related, by distinct, strategy in classical logic that can be used to prove a proposition ยง7 assuming called &ldquo;proof by contradiction&rdquo;. Here one assumes we have a proof ยง8, in other words, assuming that ยง9 is false.\n"
"\n"
"The goal is again to derive an element of ยง10, also known as a contradiction.\n"
"\n"
"Such a proof &mdash; assuming ยง11 and then deriving an element of ยง12 &mdash; constructs an element of ยง13.\n"
"\n"
"In classical logic, there is an implication ยง14, which is why &ldquo;proof by contradiction&rdquo; can be used to ultimately prove that ยง15 is true.\n"
"\n"
"To prove ยง16 in Lean, type ยง17 to tell Lean that we are appealing to the proof by contradiction strategy."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `cases ยซ{b}ยป`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "As our previous theorem is not in the library, we'll have to reprove it. Recall ยง0 only applies for *definitional* equalities, and we only have this for certain cases of Booleans. Try ยง1."
msgstr ""

#. ยง0: `assumption`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "You can solve the goal by explicitly referring to the named hypothesis that Lean supplied or by typing ยง0 to indicate that the goal matches an assumption."
msgstr ""

#. ยง0: `โจ`
#. ยง1: `P โง R`
#. ยง2: `(P โง S) โจ ((Q โง R) โจ (Q โง S))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Thus the outermost logical connective is the ยง0 combining ยง1 and ยง2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Do you see how this relates to the previous level?"
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "Composing Implication"
msgstr ""

#. ยง0: `โ โ โ`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Now your goal is to define a function of type ยง0. Lean will accept any function of this type, but be careful. If you define a *different* function than the predecessor function, the properties you will be asked to prove later will not hold."
msgstr ""

#. ยง0: `ยซ{hk}ยป`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "Now you can rewrite along the hypothesis ยง0."
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "Currying Implication"
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "The converse implication is more subtle because if ยง0 is false we don't know which of ยง1 or ยง2 is false. This will be addressed in Classical World."
msgstr ""

#. ยง0: `e : E`
#. ยง1: `E`
#. ยง2: `exact e`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "If there is an assumption ยง0 and the goal has type ยง1, then ยง2 closes the goal."
msgstr ""

#. ยง0: `(P โจ Q) โจ R`
#. ยง1: `P โจ (Q โจ R)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Or is associative: ยง0 is true if and only if ยง1 is true."
msgstr ""

#. ยง0: `or`
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "Was it necessary to consider all four cases of two boolean elements or can you define this function by considering fewer cases? The function ยง0 is now in your library."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `f : A โ B`
#. ยง2: `g : B โ A`
#. ยง3: `g โ f = id`
#. ยง4: `f โ g = id`
#. ยง5: `A`
#. ยง6: `A`
#. ยง7: `โ a : A, g (f a)`
#. ยง8: `B`
#. ยง9: `B`
#. ยง10: `โ b : B, f (g a)`
#. ยง11: `f`
#. ยง12: `f`
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "Using function extensionality, we can give a third logically equivalence characterization of what it means for a function ยง0 to be bijective or invertible.\n"
"\n"
"A function ยง1 is an *isomorphism* if there exists a function ยง2 so that ยง3 and ยง4.\n"
"\n"
"The first equation is between functions from ยง5 to ยง6. By function extensionality, it is equivalent to the condition that ยง7.\n"
"\n"
"The second equation is between functions from ยง8 to ยง9. By function extensionality, it is equivalent to the condition that ยง10.\n"
"\n"
"In Lean, isomorphisms of types are also called *equivalences*, perhaps acknowledging a newly discovered connection between dependent type theory and homotopy theory.\n"
"\n"
"For the Boss Level, prove the logical equivalence between the conditions that whether ยง11 is invertible or whether ยง12 is an isomorphism."
msgstr ""

#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "Equality Proposition"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `ยฌ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "For any proposition ยง0, ยง1 is logically equivalent to ยง2."
msgstr ""

#. ยง0: `P : A โ B โ Prop`
#. ยง1: `โ z : B, โ w : A, P w z`
#. ยง2: `โ x : A, โ y : B, P x y`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Given a family of propositions ยง0, ยง1implies ยง2"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `f : A โ B โ C`
#. ยง4: `Function.swap f : B โ A โ C`
#. ยง5: `b : B`
#. ยง6: `a : A`
#. ยง7: `f a b : C`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "For any types ยง0, ยง1, and ยง2 and function ยง3, ยง4 is the function that carries ยง5 and ยง6 to ยง7."
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{C}ยป`
#. ยง2: `intro x`
#. ยง3: `ยซ{A}ยป`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "To define a function from ยง0 to ยง1, type ยง2 to introduce an\n"
"arbitrary element of type ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `comp : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง4: `f : A โ B`
#. ยง5: `g : B โ C`
#. ยง6: `comp g f : A โ C`
#. ยง7: `a : A`
#. ยง8: `g (f a) : C`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "For types ยง0, ยง1, and ยง2, the function ยง3 takes a function ยง4 and a function ยง5 to the composite function ยง6 defined to take ยง7 to the element ยง8."
msgstr ""

#. ยง0: `cases b <;> rfl`
#. ยง1: `<;>`
#. ยง2: `rfl`
#. ยง3: `not โ not : Bool โ Bool`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "This level can be solved in one line with ยง0 where the ยง1 indicates that the\n"
"tactic ยง2 should be applied in each of the cases. It follows that ยง3 is equal to the identity function by something called *function extensionality* that will be discussed in Advanced Function World."
msgstr ""

#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "Move on to Implication World to revisit these constructions from the prospective of propositions rather than types."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `apply ยซ{f}ยป`
#. ยง2: `ยซ{A}ยป`
#. ยง3: `ยซ{B}ยป`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Since ยง0 is a function with two variables, after ยง1 we now have two goals, where we need to supply first an element of type ยง2 and then an element of type ยง3. Lean records the first of these as the &ldquo;Active Goal&rdquo; and the second of these as &ldquo;Goal 2&rdquo;."
msgstr ""

#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "In the next level, we will learn about negating universal quantifiers."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "The lesson of this level is to pay attention to the big picture, namely what exactly you are being asked ot prove under what hypotheses."
msgstr ""

#. ยง0: `b`
#. ยง1: `b && b = b || b`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "There is some boolean ยง0 so that ยง1"
msgstr ""

#. ยง0: `True`
#. ยง1: `โจโฉ : True`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The proposition ยง0 has a canonical element ยง1, which may be typed using '\\\\<' and '\\\\>'."
msgstr ""

#. ยง0: `intro w x y z p q r`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall you can introduce multiple variables and hypothesis at once by typing ยง0."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `P x : Prop`
#. ยง2: `x : A`
#. ยง3: `w = x โ x = y โ y = z โ w = z`
#. ยง4: `w x y z : A`
#. ยง5: `w`
#. ยง6: `x`
#. ยง7: `y`
#. ยง8: `z`
#. ยง9: `โ w x y z : A, w = x โ x = y โ y = z โ w = z`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall that predicates ยง0 can also be thought of as indexed families of propositions: in this case, we have a proposition ยง1 for each element ยง2.\n"
"\n"
"More generally, we might consider propositions indexed by multiple variables, either drawn repeatedly from the same type or drawn from different types.\n"
"\n"
"In this level, we will consider the family of propositions\n"
"\n"
"ยง3\n"
"\n"
"indexed by four variables ยง4.\n"
"\n"
"Here this implication is true no matter what the specific elements ยง5, ยง6, ยง7, and ยง8 are.\n"
"\n"
"Thus, we will be able to prove\n"
"\n"
"ยง9\n"
"\n"
"an enhanced verison of the transitivity of equality."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#. ยง2: `P โง Q`
#. ยง3: `Q โง P`
#. ยง4: `P โง Q โ Q โง P`
#. ยง5: `(P โง Q) โ (Q โง P)`
#. ยง6: `P โง Q โ Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "If ยง0 is true, then ยง1 is too.\n"
"\n"
"In other words, ยง2 implies ยง3, as is expressed by the proposition ยง4 which is implicitly parenthesized as ยง5.\n"
"\n"
"In a compound proposition such as ยง6, formed by iteratively applying logical connectives, the outermost logical connective (the one applied last in forming the proposition) often determines the overall proof strategy.\n"
"\n"
"Can you prove this?"
msgstr ""

#. ยง0: `S`
#. ยง1: `s : S`
#. ยง2: `exact s`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "If the goal is to prove ยง0 and we have a hypothesis ยง1, the tactic ยง2 supplies the required proof."
msgstr ""

#. ยง0: `โง`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โง Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โง Q`
#. ยง7: `P โง Q`
#. ยง8: `P โง Q`
#. ยง9: `p : P`
#. ยง10: `q : Q`
#. ยง11: `โจp,qโฉ : P โง Q`
#. ยง12: `\\<`
#. ยง13: `\\>`
#. ยง14: `h : P โง Q`
#. ยง15: `P`
#. ยง16: `Q`
#. ยง17: `h.1 : P`
#. ยง18: `h.2 : Q`
#: Game.Levels.ConjunctionWorld
msgid "The logical connective of *conjunction*, denoted by ยง0, is the mathematical version of *and*.\n"
"\n"
"For arbitrary propositions ยง1 and ยง2, ยง3 is a new proposition asserting that ยง4 *and* ยง5 *are both true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง6.\n"
"* How to use a hypothesis of the form ยง7 to prove something else.\n"
"\n"
"To prove ยง8, one must supply proofs ยง9 and ยง10, which can be done using the syntax ยง11. Use ยง12 and ยง13 to type the angle brackets.\n"
"\n"
"If we have a proof ยง14 then we can extract proofs that ยง15 and ยง16 are true using the syntax ยง17 and ยง18.\n"
"\n"
"Like the analogy between function types and implication, there is a close analogy between product types and the logical operation of conjunction.\n"
"\n"
"The reuse of the syntax we first introduced for product types is deliberate, as the introduction and elimination rules for conjunctions precisely mirror those introduced for product types."
msgstr ""

#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "In the next level, we will search for a second element of the type of types."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "ยง0 implies ยง1."
msgstr ""

#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "Swapping Inputs"
msgstr ""

#. ยง0: `rcases ยซ{even}ยป with โจd, hdโฉ`
#. ยง1: `let โจd, hdโฉ := ยซ{even}ยป`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Type ยง0 or ยง1 to decompose the hypothesis."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Using And"
msgstr ""

#. ยง0: `Unit`
#. ยง1: `โจโฉ : Unit`
#. ยง2: `x y : Unit`
#. ยง3: `x = y`
#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "Recall from Type World that Lean has a built in unit type ยง0 that contains just one element denoted ยง1.\n"
"\n"
"The unit type is a proposition, meaning that it has at most one element.\n"
"\n"
"More precisely, if ยง2 are elements of the unit type, then we can prove ยง3 by a definitional equality, aka, by reflexivity."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "Can you figure out how you would encode other logical equivalences involving proposition variables as equalities involving booleans?"
msgstr ""

#. ยง0: `A`
#. ยง1: `x y : A`
#. ยง2: `x = y`
#. ยง3: `x`
#. ยง4: `y`
#. ยง5: `x = y`
#. ยง6: `x`
#. ยง7: `y`
#. ยง8: `A`
#. ยง9: `P`
#. ยง10: `x = y`
#. ยง11: `x = y`
#. ยง12: `p : x = y`
#. ยง13: `x`
#. ยง14: `y`
#. ยง15: `A`
#. ยง16: `2 + 2 = 4`
#. ยง17: `(2 + 2) 4 : โ`
#. ยง18: `0 = 1`
#. ยง19: `0 1 : โ`
#. ยง20: `0 = 1`
#. ยง21: `x = y`
#. ยง22: `x y : A`
#. ยง23: `x = y`
#. ยง24: `x = y`
#. ยง25: `p : x = y`
#. ยง26: `x`
#. ยง27: `y`
#. ยง28: `p`
#. ยง29: `x`
#. ยง30: `y`
#. ยง31: `x`
#: Game.Levels.EqualityWorld
msgid "Consider a type ยง0. For any two elements ยง1 there is a proposition ยง2\n"
"that encodes the mathematical assertion that ยง3 and ยง4 are *equal*.\n"
"\n"
"Note that the proposition ยง5 is only well-formed if ยง6 and ยง7 are elements of the same type ยง8.\n"
"\n"
"Like with generic propositions ยง9, the proposition ยง10 is not necessarily *true*.\n"
"\n"
"To prove that\n"
"ยง11 is true, we must construct an element ยง12 which can be thought of as a *proof* that\n"
"ยง13 equals ยง14 as elements of type ยง15.\n"
"\n"
"For example: ยง16 is true for elements ยง17. In Natural Numbers World, we will see a proof of this.\n"
"\n"
"But the proposition ยง18 is false, again for\n"
"ยง19.\n"
"\n"
"In Natural Numbers World, we will see how to prove its *negation*, in other words that ยง20 is false.\n"
"\n"
"To understand the proposition ยง21 for elements ยง22, we must understand:\n"
"\n"
"* How to prove propositions of the form ยง23.\n"
"* How to use hypotheses of the form ยง24 to prove other propositions or define elements of other types.\n"
"\n"
"The introduction rule for proving equality is surprisingly weak, only proving equalities that hold trivially &ldquo;by reflexivity&rdquo; or &ldquo;by definition&rdquo;.\n"
"\n"
"By contrast, the elimination rule for using proofs of equality is quite strong, expressing something like the *indiscernibility of identicals*: informally, if we have ยง25, then anything that is true of ยง26 must also be true of ยง27 (and conversely).\n"
"\n"
"Lean provides a tactic that can be applied to the proof ยง28 to convert a goal involving the element ยง29 to an analogous goal with ยง30 substituted in place of ยง31."
msgstr ""

#. ยง0: `+ : โ โ โ โ โ`
#. ยง1: `add_zero n : n + 0 = n`
#. ยง2: `add_succ m n : m + succ n = succ (m + n)`
#. ยง3: `succ m + n = succ (m + n)`
#. ยง4: `m`
#. ยง5: `n`
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "The addition function ยง0 is defined by the equations\n"
"\n"
"* ยง1 and\n"
"* ยง2.\n"
"\n"
"It is of course also true that ยง3 for all natural numbers ยง4 and ยง5, but this equation does not hold by definition.\n"
"\n"
"Instead you have to prove it by induction!\n"
"\n"
"Good luck."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "The function ยง0 is invertible."
msgstr ""

#. ยง0: `use ??`
#. ยง1: `??`
#. ยง2: `m`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "To prove the existential quantifier, type ยง0 with an explicit numeral in the place of ยง1 to supply a well-chosen value of ยง2."
msgstr ""

#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Applying Implication"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `p : P`
#. ยง4: `q : Q`
#. ยง5: `โ`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `P โ Q`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `P โ Q`
#. ยง12: `P โ Q`
#. ยง13: `P โ Q`
#. ยง14: `A โ B`
#: Game.Levels.ImplicationWorld
msgid "We now step away from considerations involving types and their elements and turn our attention to propositions and their proofs.\n"
"\n"
"We begin our study of proofs with *propositional logic*.\n"
"\n"
"Many mathematical propositions are built out of simpler propositions using logical connectives. The structure of a compound proposition &mdash; that is, which connectives appear where &mdash; often suggests proof techniques, as we will discover.\n"
"\n"
"To study these connectives, we require *proposition variables* &mdash; denoted with letters like ยง0, ยง1, ยง2 &mdash; which stand for generic propositions, which may be true or false.\n"
"\n"
"The slogan *propositions as types* tells us that we can consider propositions as special cases of *types*.\n"
"\n"
"We think of the elements ยง3 and ยง4 as *proofs* that these propositions are true.\n"
"\n"
"Just as type forming operations can be used to build more complicated types out of existing types, *logical connectives* can be used to build more complicated propositions out of existing propositions.\n"
"\n"
"In this level we study the logical connective *implication* denoted by ยง5.\n"
"\n"
"For arbitrary *propositions* ยง6 and ยง7, ยง8 is a new proposition asserting that *if* ยง9 *is true then* ยง10 *is true*.\n"
"\n"
"To understand how implications work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง11.\n"
"* How to use a hypothesis of the form ยง12 to prove something else.\n"
"\n"
"We'll learn the rules for proving implications and using implications in the levels that follow.\n"
"\n"
"The introduction and elimination rules for implications precisely mirror the introduction and elimination rules for function types.\n"
"\n"
"This analogy is further emphasized by the fact that we use the same notation for implications ยง13 as for\n"
"function types ยง14. The Lean tactics that were introduced to define and work with functions will play an analogous role when proving or using implications."
msgstr ""

#. ยง0: `ยซ{p}ยป : P`
#. ยง1: `ยฌ P`
#. ยง2: `ยฌ Q`
#. ยง3: `right`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Because  ยง0, it is unlikely that you will be able to prove ยง1. So instead try to prove ยง2. You can focus on this goal by using the tactic ยง3."
msgstr ""

#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "Now you can start to apply some hypotheses to reduce the goal to one of your assumptions. Which tactic can be used here?"
msgstr ""

#. ยง0: `False`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "The proposition ยง0 has no elements."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `left`
#. ยง3: `P โจ Q`
#. ยง4: `P`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `left`
#. ยง8: `A โ B`
#. ยง9: `A`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For propositions ยง0 and ยง1, the ยง2 tactic converts a goal of ยง3 to a goal of ยง4. For types ยง5 and ยง6, the ยง7 tactic converts a goal of ยง8 into a goal of ยง9."
msgstr ""

#. ยง0: `And.curry : (P โง Q โ R) โ (P โ Q โ R)`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "This proves the theorem ยง0, which is now in your library. We will next establish the converse implication."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `โจp.1, p.2โฉ`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "A term ยง0 in a product type is definitionally equal to the pairing of its projections ยง1."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `f`
#. ยง2: `f`
#. ยง3: `f`
#. ยง4: `g : B โ A`
#. ยง5: `f`
#. ยง6: `b : B`
#. ยง7: `g b : A`
#. ยง8: `f (g b) = b`
#. ยง9: `f`
#. ยง10: `โ x : A, f x = b`
#. ยง11: `A`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Suppose ยง0 is a bijective function, meaning ยง1 is both injective and surjective.\n"
"\n"
"Then it follows that ยง2 is invertible.\n"
"\n"
"The proof is more delicate, however, than the previous case as it requires classical logic rather than constructive logic.\n"
"\n"
"To define an inverse for ยง3, we must define a function ยง4 that &ldquo;un-does&rdquo; the action of ยง5.\n"
"For an element ยง6, we in particular want ยง7 to be chosen so that ยง8.\n"
"\n"
"Our hypothesis that ยง9 is surjective tells us that ยง10. But it doesn't give us a &ldquo;formula&rdquo; to pick a particular element of ยง11.\n"
"\n"
"Instead, we must appeal to something called the *axiom of choice* to make an explicit choice. We will\n"
"explain how to do so at that stage in the proof."
msgstr ""

#. ยง0: `Boss Level`
#. ยง1: `assumption`
#. ยง2: `exact`
#. ยง3: `Type`
#. ยง4: `Type`
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "Each world will end with a ยง0, which is intended to be more challenging than the levels that came before.\n"
"\n"
"It is not so easy to design a challenging exercise involving only the tactics ยง1 and ยง2 but nevertheless, we will end with a puzzle that you may find interesting.\n"
"\n"
"Your task in this level, like in the previous level, is to define an element in the type ยง3.\n"
"\n"
"In the previous level, you were asked to do this in the empty context. Here our context contains certain assumptions which could potentially be used to make your task easier.\n"
"\n"
"You are allowed, if you insist, to solve this level in the same way you solved the previous level. But we challenge you to define a different element of the type ยง4 than you used previously."
msgstr ""

#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "By Assumption"
msgstr ""

#. ยง0: `0`
#. ยง1: `rfl`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "To check that your function was defined correctly, we ask you to calculate its values on ยง0 and on successors. Hopefully you will be able to solve the goals with ยง1."
msgstr ""

#. ยง0: `cases ยซ{hpqr}ยป`
#. ยง1: `rcases ยซ{hpqr}ยป with hpq | hr`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "You can use ยง0 to split your hypothesis into cases or ยง1 to name your own variables."
msgstr ""

#. ยง0: `f : Bool โ Bool โ Bool`
#. ยง1: `f true true = true โง f false true = false โง f true false = false โง f false false = false`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Now you are asked to check that the function ยง0 that you just defined actually *is* the conjunction function. Specifically, you are asked to check that ยง1."
msgstr ""

#. ยง0: `A ร B โ C`
#. ยง1: `A โ B โ C`
#. ยง2: `A โ B โ C`
#. ยง3: `A ร B โ C`
#. ยง4: `(A ร B โ C) โ (A โ B โ C)`
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "*Currying* is the operation that converts a function of type ยง0 into a function of type ยง1.\n"
"\n"
"*Uncurrying* is the operation that converts a function of type ยง2 into a function of type ยง3.\n"
"\n"
"These operations are inverses, defining an equivalence of types\n"
"\n"
"ยง4.\n"
"\n"
"Note the currying and uncurrying functions are in the library, so can be used (rather than re-defined) in the proof."
msgstr ""

#. ยง0: `โ`
#. ยง1: `0 : โ`
#. ยง2: `succ : โ โ โ`
#. ยง3: `โ m n : โ, succ m = succ n โ m = n`
#. ยง4: `ยฌ (โ n : โ, succ n = 0)`
#. ยง5: `โ P : โ โ Prop, P 0 โ (โ k : โ, P k โ P (succ k)) โ (โ n : โ, P n)`
#. ยง6: `โ`
#. ยง7: `0 : โ`
#. ยง8: `succ : โ โ โ`
#. ยง9: `โ P : โ โ Type, P 0 โ (โ k : โ, P k โ P (succ k)) โ (โ n : โ, P n)`
#. ยง10: `โ`
#. ยง11: `0 : โ`
#. ยง12: `succ : โ โ โ`
#. ยง13: `โ`
#. ยง14: `0`
#. ยง15: `succ n`
#. ยง16: `n : โ`
#. ยง17: `โ`
#: Game.Levels.NaturalNumbersWorld
msgid "In this world, we will introduce the type ยง0 of natural numbers.\n"
"\n"
"In traditional foundations, the natural numbers are characterized by a series of axioms discovered roughly contemporaneously by Dedekind and Peano that are commonly called the *Peano postulates*. There are five axioms:\n"
"\n"
"  1. There is a natural number ยง1 called *zero*.\n"
"\n"
"  2. There is a function ยง2 that sends any natural number to its *successor*.\n"
"\n"
"  3. The successor function is injective: ยง3.\n"
"\n"
"  4. Zero is not the successor of any natural number: ยง4.\n"
"\n"
"  5. The principle of mathematical induction: ยง5.\n"
"\n"
"In type theory, the type ยง6 of natural numbers is instead characterized by introduction and elimination rules:\n"
"\n"
"* The *introduction rules* tell us that there is a natural number ยง7 as well as natural numbers obtained by applying the function ยง8.\n"
"* The *elimination rule* extends the principle of mathematical induction to families of types as well as families of propositions: ยง9.\n"
"\n"
"Together these rules say that ยง10 is an *inductive type* freely generated by ยง11 and ยง12. We may define (dependent) functions out of the inductive type ยง13 &ldquo;by induction&rdquo; by considering only the cases of ยง14 and ยง15 for some ยง16.\n"
"\n"
"The type-theoretic definition of ยง17 closely resembles Peano's first, second, and fifth axioms and in fact implies the other two, as we will see by the end of this world."
msgstr ""

#. ยง0: `g : A โ C`
#. ยง1: `h : B โ C`
#. ยง2: `A โ B โ C`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Two functions ยง0 and ยง1 combine to define a single function of type ยง2."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `b : B`
#. ยง2: `x : A`
#. ยง3: `f x = b`
#. ยง4: `f : A โ B`
#. ยง5: `g : B โ C`
#. ยง6: `g โ f : A โ C`
#. ยง7: `g : B โ C`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "Recall that a function ยง0 is *surjective* if for every ยง1 there exists some ยง2 so that ยง3.\n"
"\n"
"In the level, we will consider a composable pair of functions ยง4 and ยง5.\n"
"\n"
"We will show that if the composite ยง6 is surjective, then the function ยง7 is surjective too."
msgstr ""

#. ยง0: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "The type ยง0 is the type of types at the smallest universe level."
msgstr ""

#: Game.Levels.TypeWorld
msgid "Type World"
msgstr ""

#: Game
msgid "ReintroToProofs"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `cases h : ยซ{x}ยป`
#. ยง1: `h : ยซ{x}ยป = false`
#. ยง2: `h : ยซ{x}ยป = true`
#. ยง3: `cases k : ยซ{y}ยป`
#. ยง4: `match ยซ{x}ยป , ยซ{y}ยป with | ? , ? => exact ? | ? , ? => exact ? | ? , ? => exact ? | ? , ? => exact ?`
#. ยง5: `?`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "If you are using typewriter mode, try ยง0 to add hypotheses ยง1 and ยง2 that clarify which case you are in. Similarly, try ยง3 whenever you are ready to consider cases on the second boolean variable. Alternatively, you can define the function on one line with ยง4 replacing each ยง5 with appropriate boolean elements."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "In the next level, we will introduce a fundamental property of bijective functions, namely their\n"
"invertibility."
msgstr ""

#. ยง0: `fun x โฆ a`
#. ยง1: `x : B`
#. ยง2: `a : A`
#. ยง3: `fun _ โฆ a`
#. ยง4: `exact fun _ โฆ a`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "The formula for the constant function is ยง0. In other words, given any input ยง1, the output is always the specified term ยง2. Since the formula for the output does not depend on the input term, this can also be written as ยง3, so try solving this level with ยง4"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Modus Ponens"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "Invertibility"
msgstr ""

#. ยง0: `have rs : R โจ S := ยซ{h}ยป.2`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try ยง0."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `ยซ{p}ยป : ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Now the goal is to prove ยง0 assuming ยง1. Which tactic can be used to supply this proof?"
msgstr ""

#. ยง0: `P`
#. ยง1: `p : P`
#. ยง2: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "Under the hypothesis that we have a proposition ยง0 and a proof ยง1, we may conclude that ยง2 is true."
msgstr ""

#. ยง0: `Prod.fst : A ร B โ A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions."
msgstr ""

#. ยง0: `n`
#. ยง1: `Nat.pred_succ n`
#. ยง2: `Nat.pred (succ n) = n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "For all natural numbers ยง0, ยง1 proves that ยง2."
msgstr ""

#. ยง0: `Bool`
#. ยง1: `false`
#. ยง2: `true`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The type ยง0 is the type of booleans. It contains two elements, denoted ยง1 and ยง2."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "We are now ready for the Boss Level of Disjunction World."
msgstr ""

#. ยง0: `exact tr โจโฉ`
#. ยง1: `False`
#. ยง2: `tr`
#. ยง3: `โจโฉ : True`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Type ยง0 to return an element of ยง1 defined using the function ยง2 and the element ยง3."
msgstr ""

#. ยง0: `x y : Bool`
#. ยง1: `and x y = and y x`
#. ยง2: `x && y`
#. ยง3: `and x y`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
msgid "For any booleans ยง0, ยง1, capturing the symmetry of conjunction.\n"
"\n"
"Note Lean has an alternate notation ยง2 for ยง3."
msgstr ""

#. ยง0: `1`
#. ยง1: `2`
#. ยง2: `3`
#. ยง3: `4`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "Explicit numerals ยง0, ยง1, ยง2, ยง3, and so on are defined as repeated successors of the previous numerals."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โจ ยฌ P โ (ยฌ ยฌ P โ P)`
#. ยง2: `ยฌ ยฌ P โ P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `P`
#. ยง6: `exact em P`
#. ยง7: `apply byContradiction`
#. ยง8: `have np : ยฌ P := ?`
#. ยง9: `?`
#. ยง10: `have np : ยฌ P := by`
#. ยง11: `ยฌ P`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In Negation World, we proved that for any proposition ยง0: ยง1\n"
"\n"
"In other words, we showed that the law of excluded middle implies double negation elimination.\n"
"\n"
"We now show that converse: that double negation elimination implies the law of excluded middle. More\n"
"precisely, if we assume that ยง2 for all propositions ยง3, then we can show that ยง4 for\n"
"all proposition ยง5.\n"
"\n"
"While the proof will feel like an application of classical logic, using the strategy of proof by contradiction, in\n"
"fact the proof can be understood as a proof in constructive mathematics.\n"
"\n"
"This is because we are arguing under the assumption that double negation elimination holds, which means\n"
"we are working in a setting where the strategy of proof by contradiction applies.\n"
"\n"
"You can solve this level immediately with ยง6 &mdash; evading the boss &mdash; but try starting with ยง7 instead and see if you can argue without appealing to the law of excluded middle.\n"
"\n"
"You might wish to prove a few lemmas in the middle of this proof. We have seen that this can be done by typing ยง8 if you can supply the full name of the proof in place of the ยง9.\n"
"\n"
"Alternatively, switch into editor mode and type ยง10 and then move down to the next line. You'll see that Lean has replaced the overall goal by a local goal, in this case to prove the proposition ยง11 from the hypotheses in your context. This allows you to give a multi-line tactic proof."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This case is similar to the previous one. Can you figure out how to solve it?"
msgstr ""

#. ยง0: `Prop`
#. ยง1: `Type`
#. ยง2: `Prop : Type`
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "Note that elements of ยง0 are considered to be at a smaller universe level than elements of ยง1, which is why we have ยง2. Now move on to Function World to meet your first type forming operation."
msgstr ""

#. ยง0: `have q : Q := ยซ{i}ยป ยซ{p}ยป`
#. ยง1: `Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try ยง0 to add a proof of ยง1 to your assumptions."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `P x : Prop`
#. ยง4: `x : A`
#. ยง5: `โ x : A, P x`
#. ยง6: `P x`
#. ยง7: `x : A`
#. ยง8: `x : A`
#. ยง9: `P x`
#. ยง10: `โ x : A, P x`
#. ยง11: `x : A`
#. ยง12: `P x`
#. ยง13: `P x`
#. ยง14: `x : A`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Let ยง0 be a predicate over a type ยง1.\n"
"\n"
"As the notation suggests, a predicate is naturally regarded as a function, whose domain is the type ยง2 and whose target is the type of propositions.\n"
"\n"
"It is also natural to think of a predicate as an indexed family of propositions: we have propositions ยง3 indexed by the elements ยง4.\n"
"\n"
"To prove that ยง5 holds, one must show that ยง6 is true for each ยง7.\n"
"\n"
"That is, one must introduce an arbitrary element ยง8 and then construct a proof of ยง9.\n"
"\n"
"In other words, to prove ยง10, one must construct what is sometimes called a *dependent function* that carries ยง11 to an element of ยง12. Such functions are called &ldquo;dependent&rdquo; because the proposition ยง13 may vary with the input element ยง14."
msgstr ""

#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "Constant Functions"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld
msgid "Advanced Function World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Start by identifying the outermost logical connective and use the tactic corresponding to its introduction rule."
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#. ยง1: `rcases ยซ{p}ยป with x | c`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Now use ยง0 or ยง1 or similar to give your own variable names."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `intro p`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Now Lean wants you to check that the first function followed by the second function yields the identity function at every element ยง0. Start with ยง1."
msgstr ""

#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "This proves the associativity of disjunction."
msgstr ""

#. ยง0: `p : x = y`
#. ยง1: `rw [p]`
#. ยง2: `x`
#. ยง3: `y`
#. ยง4: `rw [โ p]`
#. ยง5: `y`
#. ยง6: `x`
#. ยง7: `rw`
#. ยง8: `rfl`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Given a hypothesis ยง0, the tactic ยง1 will replace each ยง2 in the goal by ยง3. Writing ยง4 will replace the each ยง5 in the goal by ยง6. This is a slightly less powerful version than the ยง7 tactic in Mathlib, which will attempt to close the goal with ยง8."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `Function.uncurry : (A โ B โ C) โ (A ร B โ C)`
#. ยง4: `f : A โ B โ C`
#. ยง5: `p : A ร B`
#. ยง6: `f p.1 p.2 : C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "For any types ยง0, ยง1, and ยง2, ยง3 is the function that sends ยง4 to the function that sends ยง5 to ยง6."
msgstr ""

#. ยง0: `x : A ร (B โ C)`
#. ยง1: `rcases x with โจa, b | cโฉ`
#. ยง2: `a : A`
#. ยง3: `b : B`
#. ยง4: `a : A`
#. ยง5: `c : C`
#. ยง6: `x : (A ร B) โ (A ร C)`
#. ยง7: `rcases x with โจa, bโฉ | โจa, cโฉ`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You might enjoy solving this level again with the following syntactic tricks. If given an element ยง0, then ยง1 will split into two cases, one of which involves elements ยง2 and ยง3 and the other of which involves elements ยง4 and ยง5. Similarly, if given ยง6, then ยง7 will split into the same pair of cases."
msgstr ""

#: Game.Levels.BooleanWorld.L01_Negation
msgid "Your first objective is to define the negation function."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "More Distributivity"
msgstr ""

#. ยง0: `True`
#. ยง1: `Prop`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The proposition ยง0 and the type ยง1 are now in your library of definitions."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "If ยง0 is true, then if ยง1 is true, then ยง2 is true."
msgstr ""

#. ยง0: `have`
#. ยง1: `p : P`
#. ยง2: `h : P โ Q`
#. ยง3: `have q : Q := h p`
#. ยง4: `q : Q`
#. ยง5: `h p`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "The ยง0 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions ยง1 and ยง2, type ยง3 to add a proof ยง4 defined by ยง5."
msgstr ""

#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "We will meet some further applications of the equality type in Boolean World. Head there next."
msgstr ""

#. ยง0: `(โ x : A, ยฌ (P x)) โ ยฌ (โ x : A, P x)`
#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "We have just proven an implication\n"
"\n"
"ยง0.\n"
"\n"
"Use classical logic to prove the converse implication.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Use ยง0 to isolate the goal of defining the inverse function."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `exact โจrfl, rfl, rfl, rfl, rflโฉ`
#. ยง2: `rfl`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "You can avoid the repeated applications of the ยง0 tactic by solving this level with ยง1. In the next level, we will encounter other equalities between natural numbers that can be proven with ยง2."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "How do you construct elements of a function type?"
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `Sum.inl : A โ A โ B`
#. ยง2: `g : A โ C`
#. ยง3: `f`
#. ยง4: `f : A โ B โ C`
#. ยง5: `Sum.inr : B โ A โ B`
#. ยง6: `h : B โ C`
#. ยง7: `A โ B โ C`
#. ยง8: `A โ C`
#. ยง9: `B โ C`
#. ยง10: `A โ B โ C`
#. ยง11: `(A โ C) ร (B โ C)`
#. ยง12: `f : A โ B โ C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Consider a function ยง0 mapping out of a coproduct type.\n"
"\n"
"By composing with the function ยง1 we obtain a function ยง2 which can be thought of as one of the two *component functions* associated to ยง3.\n"
"\n"
"The other component function is defined by composing ยง4 with the function ยง5 to obtain a function ยง6.\n"
"\n"
"Since a *single* function of type ยง7 decomposes into a pair of functions of types ยง8 and ยง9, we may  define a function from the function type ยง10 to the product of the function types ยง11. Thus carries a function ยง12 to its pair of component functions.\n"
"\n"
"Your task in this level is to define this operation, which splits a function out of a coproduct into into component functions."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "The DeMorgan equalities relate the operations of conjunction, disjunction, and negation on booleans."
msgstr ""

#. ยง0: `False`
#. ยง1: `ยซ{eq}ยป`
#. ยง2: `ยซ{neq}ยป`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Revisit Negation World to remind yourself how to get an element of ยง0 from ยง1 and ยง2."
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `P`
#. ยง2: `Q โจ R`
#. ยง3: `P โง Q`
#. ยง4: `P โง R`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "What does it mean if ยง0 holds?\n"
"\n"
"Then certainly ยง1 is true and also ยง2 is true.\n"
"\n"
"So we can conclude that ยง3 is true or ยง4 is true, demonstrating one of the implications in the following logical equivalence."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `B โ A`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "For any types ยง0 and ยง1, the coproduct types ยง2 and ยง3 are equivalent."
msgstr ""

#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Commuting Quantifiers"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `Function.curry : (A ร B โ C) โ (A โ B โ C)`
#. ยง4: `f : A ร B โ C`
#. ยง5: `a : A`
#. ยง6: `b : B`
#. ยง7: `f โจa, bโฉ : C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "For any types ยง0, ยง1, and ยง2, ยง3 is the function that sends ยง4 to the function that sends ยง5 and ยง6 to ยง7."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `ยซ{nq}ยป`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What can you prove with ยง0 and ยง1?"
msgstr ""

#. ยง0: `ยฌ (true = false)`
#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "For the Boss Level of Natural Numbers World you are challenged to prove the fifth Peano axiom, that zero is not the successor of any natural numbers.\n"
"\n"
"For guidance, revisit the proof that ยง0 from Boolean World.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `P โจ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "There are two ways to prove ยง0 from the given hypotheses. Can you find them both?"
msgstr ""

#. ยง0: `! x`
#. ยง1: `not x`
#. ยง2: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Here Lean writes ยง0 for ยง1, where ยง2 is the boolean negation function."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "Successor Injectivity"
msgstr ""

#. ยง0: `h : P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `h.1 : P`
#. ยง4: `h.2 : Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "A hypothesis ยง0 provides explicit proofs of both ยง1 and ยง2 which are denoted in Lean by ยง3 and ยง4.\n"
"\n"
"Collectively, this expresses the pair of elimination rules for the logical operation of conjunction."
msgstr ""

#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "In the next level, we will prove a similar universal property for coproduct types."
msgstr ""

#. ยง0: `A`
#. ยง1: `f : A โ Empty`
#. ยง2: `a : A`
#. ยง3: `Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "For any type ยง0, if there is a function ยง1 and there is an element ยง2, then there is an element of the ยง3 type."
msgstr ""

#. ยง0: `A โ B โ C ร D`
#. ยง1: `(A โ C) ร (B โ C) ร (A โ D) ร (B โ D)`
#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "A function of type ยง0 can be broken into component functions of type ยง1 and conversely the component functions assemble into a function from the coproduct type to the product type."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "The empty type is a weird type, so what was the point of this world? The hope is that your experience defining functions involving the empty type will prepare you to think about what it means to prove that a proposition is false in Negation World. Go there next."
msgstr ""

#. ยง0: `ยฌ (P โง Q)`
#. ยง1: `P โง Q`
#. ยง2: `P โง Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โง Q`
#. ยง8: `ยฌ P โจ ยฌ Q`
#. ยง9: `ยฌ (P โง Q)`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"On the one hand, it suffices for just ยง3 to be false.\n"
"\n"
"On the other hand, it suffices for just ยง4 to be false.\n"
"\n"
"That is, if either ยง5 or ยง6 is false, then ยง7 is false.\n"
"\n"
"In this level, we will prove that ยง8 implies ยง9."
msgstr ""

#. ยง0: `h : P โ Q`
#. ยง1: `p : P`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "We've seen that an implication ยง0 can be applied in the presense of a proof ยง1 to provide a proof of the proposition ยง2. This explains how implications are *used* in proofs of other statements. In the next level, we will see how implications can be *proven*."
msgstr ""

#: Game.Levels.ProductWorld
msgid "Product World"
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "When in doubt, recall the introduction rule for equality types."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use the ยง0 tactic to define a term in a function type."
msgstr ""

#. ยง0: `exact fun g f a โฆ ?`
#. ยง1: `?`
#. ยง2: `exact fun g f โฆ ?`
#. ยง3: `?`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Can you solve this level in one line by using ยง0 with the appropriate thing in place of the ยง1?\n"
"\n"
"Can you solve this level in one line by using ยง2 with the appropriate thing in place of the ยง3?"
msgstr ""

#. ยง0: `not : Bool โ Bool`
#. ยง1: `and : Bool โ Bool โ Bool`
#. ยง2: `Bool โ Bool โ Bool`
#. ยง3: `Bool โ Bool โ Bool`
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "We have seen that the logical operation of negation can be encoded as a function ยง0.\n"
"\n"
"We have also defined a function ยง1 that encodes the logical operation of conjunction.\n"
"\n"
"In this level, we will define a function ยง2 that encodes the logical operation of disjunction.\n"
"\n"
"Again, this level comes with two pre-defined goals: the first is to define the disjunction function ยง3 and the second is to check that your definition is correct by calculating the values of the function you defined on explicit pairs of booleans."
msgstr ""

#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "In the next level, we will explore the consequences of exchanging the order of universal and existential quantifiers."
msgstr ""

#. ยง0: `have`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "For the Boss Level of Conjunction World, the task is to prove a complicated implication.\n"
"\n"
"After introducing all of the allowed hypotheses, you may find it helpful to prove that some intermediate propositions are true using the ยง0 tactic.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A โ B) โ C`
#. ยง4: `A โ (B โ C)`
#. ยง5: `a : A`
#. ยง6: `b : B`
#. ยง7: `c : C`
#. ยง8: `b : B`
#. ยง9: `Sum.inl (Sum.inr b) : (A โ B) โ C`
#. ยง10: `Sum.inr (Sum.inl b) : A โ (B โ C)`
#. ยง11: `((A โ B) โ C) โ (A โ (B โ C))`
#. ยง12: `(A โ (B โ C)) โ ((A โ B) โ C)`
#. ยง13: `(((A โ B) โ C) โ (A โ (B โ C))) ร ((A โ (B โ C)) โ ((A โ B) โ C))`
#. ยง14: `A โ B โ C`
#. ยง15: `A โ (B โ C)`
#. ยง16: `x : A โ B โ C`
#. ยง17: `rcases x with a | b | c`
#. ยง18: `a : A`
#. ยง19: `b : B`
#. ยง20: `c : C`
#. ยง21: `y : (A โ B) โ C`
#. ยง22: `rcases y with (a | b) | c`
#. ยง23: `a : A`
#. ยง24: `b : B`
#. ยง25: `c : C`
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Given three types ยง0, ยง1, and ยง2, the coproduct type construction may be iterated to define types ยง3 and ยง4.\n"
"\n"
"For both of these types, there are three cases of elements: those coming from ยง5, those coming from ยง6, and those coming from ยง7. The notation for the corresponding elements of the iterated coproduct type depends on the parentheses: the terms ยง8 include as ยง9 but include as ยง10.\n"
"\n"
"The objective in this level is to define a pair of functions between these types in each direction, the first of type ยง11 and the second of type ยง12. That is, define a single element of type\n"
"\n"
"ยง13\n"
"\n"
"By convention, the notation ยง14 is an abbreviation for the coproduct type ยง15. For an element ยง16, typing ยง17 will split directly into the three cases corresponding to elements ยง18, ยง19, or ยง20.\n"
"\n"
"Similarly, for an element ยง21, ยง22 will split directly into the three cases corresponding to elements ยง23, ยง24, or ยง25."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Define the currying function, convering a function out of a product type into a function of two variables."
msgstr ""

#: Game.Levels.TypeWorld.L01_Elements
msgid "In the next level, we will learn about elements of propositions."
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `A`
#. ยง2: `Sum.inl : A โ A โ B`
#. ยง3: `left`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "To define an element of type ยง0 by defining an element of type ยง1 and applying the function ยง2, start by typing ยง3."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โง Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "For any propositions ยง0 and ยง1, if ยง2 is false or ยง3 is false then ยง4 is false."
msgstr ""

#. ยง0: `โ x : A, P x`
#. ยง1: `a : A`
#. ยง2: `P a`
#. ยง3: `โ x : A, ยฌ (P x)`
#. ยง4: `โ x : A, ยฌ (P x)`
#. ยง5: `ยฌ (โ x : A, P x)`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "How would you disprove a statement of the form\n"
"\n"
"ยง0?\n"
"\n"
"To do this, it is necessary to show that for *every* ยง1, ยง2 is not true.\n"
"\n"
"That is, it is necessary to prove\n"
"\n"
"ยง3.\n"
"\n"
"In this level we will prove ยง4 implies\n"
"ยง5 and conversely."
msgstr ""

#. ยง0: `Nat.add_comm : โ m n : โ, m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "This proves the theorem ยง0, which is now in your library."
msgstr ""

#. ยง0: `Bool โ Prop`
#. ยง1: `let P : Bool โ Prop := by intro b ; match b with | false => exact False | true => exact True`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Define a function ยง0 by ยง1."
msgstr ""

#. ยง0: `P โง ยฌ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "In the next level, we will see that a contradiction of the form ยง0 can be used to prove any proposition."
msgstr ""

#. ยง0: `and : Bool โ Bool โ Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "The function ยง0 captures the logical operation of conjunction."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#. ยง1: `ยซ{p}ยป`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "What sort of inputs does the function ยง0 require and how can these be extracted from ยง1?"
msgstr ""

#. ยง0: `Prop`
#. ยง1: `Prop`
#. ยง2: `True`
#. ยง3: `โจโฉ : True`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `p : P`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `Prop`
#. ยง13: `Retry`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "Lean has a built in type of propositions denoted ยง0.\n"
"\n"
"In the empty context, ยง1 contains propositions like ยง2, which is the true proposition, with canonical proof ยง3.\n"
"\n"
"In this level, we consider the context given by two propositions ยง4 and ยง5 together with a proof ยง6 of ยง7.\n"
"\n"
"Thus, ยง8 is a proposition that we have assumed to be true, while ยง9 is a proposition that may or may not be true.\n"
"\n"
"Under these assumptions, either ยง10 or ยง11 define elements of ยง12. Use the ยง13 button to solve this level in multiple ways."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "This equality does not hold by definition, so ยง0 fails. But your context has a new hypothesis that can help."
msgstr ""

#. ยง0: `โ`
#. ยง1: `0: โ`
#. ยง2: `succ : โ โ โ`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "The type of natural numbers is denoted ยง0. It is an inductive type freely generated by ยง1 and the function ยง2 taking each natural number to its successor."
msgstr ""

#. ยง0: `Bool.noConfusion`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "We have added the theorem ยง0 to the library."
msgstr ""

#. ยง0: `ยซ{na}ยป`
#. ยง1: `ยซ{npa}ยป`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "There are various ways to use ยง0 and ยง1 to get a contradiction."
msgstr ""

#. ยง0: `ext`
#. ยง1: `f g : A โ B`
#. ยง2: `f x = g x`
#. ยง3: `x : A`
#. ยง4: `ext`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "The ยง0 tactic can be used to apply function extensionality, changing a goal involving proving equality between functions ยง1 into a goal of proving ยง2 for an arbitrary ยง3. The ยง4 tactic  applies similar extensionality lemmas that have been proven for other types."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The goal is an implication. What tactic can be used to start a proof?"
msgstr ""

#. ยง0: `induction`
#. ยง1: `2 * d + 1 + 1 = 2 * (d + 1)`
#. ยง2: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The ยง0 tactic is now in your library.\n"
"\n"
"It is a bit surprising that the last equation ยง1 holds by ยง2. This has to do with the way that addition and multiplication are defined in Lean. We will explore the definition of addition in a future level."
msgstr ""

#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Universal Elimination"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Combined with what we know already, we have established a logical equivalence between the implications ยง0 and ยง1 in classical logic."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#. ยง1: `false`
#. ยง2: `true`
#. ยง3: `true`
#. ยง4: `false`
#: Game.Levels.BooleanWorld.L01_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The negation function ยง0 sends the boolean ยง1 to ยง2 and ยง3 to ยง4."
msgstr ""

#. ยง0: `Nat.add_succ`
#. ยง1: `rw [add_succ]`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "To apply the theorem ยง0 type ยง1."
msgstr ""

#. ยง0: `and : Bool โ Bool โ Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "There is a function ยง0 that captures the logical operation of conjunction."
msgstr ""

#. ยง0: `x`
#. ยง1: `cases x`
#. ยง2: `x`
#. ยง3: `cases`
#. ยง4: `h : P โจ Q`
#. ยง5: `cases h`
#. ยง6: `P`
#. ยง7: `Q`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Assuming ยง0 is a variable in the local context with an inductive type, ยง1 splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on ยง2, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well. ยง3 detects unreachable cases and closes them automatically.\n"
"\n"
"For example, given an assumption ยง4, ยง5 splits the main goal into two goals, one assuming ยง6 holds and the other assuming ยง7 holds."
msgstr ""

#: Game.Levels.TypeWorld.L07_BossLevel
#: Game.Levels.FunctionWorld.L10_BossLevel
#: Game.Levels.ImplicationWorld.L10_BossLevel
#: Game.Levels.ProductWorld.L10_BossLevel
#: Game.Levels.ConjunctionWorld.L10_BossLevel
#: Game.Levels.EmptyWorld.L07_BossLevel
#: Game.Levels.NegationWorld.L11_BossLevel
#: Game.Levels.ClassicalWorld.L06_BossLevel
#: Game.Levels.EqualityWorld.L10_BossLevel
#: Game.Levels.BooleanWorld.L09_BossLevel
#: Game.Levels.QuantifierWorld.L09_BossLevel
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
#: Game.Levels.EquivalenceWorld.L07_BossLevel
#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "Boss Level"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What is the logical structure of the goal?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Bijective Implies Invertible"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Composing Surjectivity"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ (P โง ยฌ P)`
#. ยง2: `P`
#. ยง3: `ยฌ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition ยง0, the following is true:\n"
"\n"
"ยง1\n"
"\n"
"This is sometimes called the *law of noncontradiction*.\n"
"\n"
"It asserts that it is not the case that both ยง2 and ยง3 are true.\n"
"\n"
"Do you see how this relates to the previous levels?"
msgstr ""

#. ยง0: `f : X โ A ร B`
#. ยง1: `fun x โฆ (f x).1 : X โ A`
#. ยง2: `fun x โฆ (f x).2 : X โ B`
#. ยง3: `g : X โ A`
#. ยง4: `h : X โ B`
#. ยง5: `X`
#. ยง6: `X โ A ร B`
#. ยง7: `g`
#. ยง8: `h`
#. ยง9: `let`
#. ยง10: `let`
#. ยง11: `have`
#. ยง12: `p : (X โ A) ร (X โ B)`
#. ยง13: `X โ A`
#. ยง14: `X โ B`
#. ยง15: `let`
#. ยง16: `let g : X โ A := p.1`
#. ยง17: `p`
#. ยง18: `g`
#. ยง19: `let h : X โ B := p.2`
#. ยง20: `p`
#. ยง21: `h`
#. ยง22: `let`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "We've seen that functions ยง0 into product types can be decomposed into component functions ยง1 and ยง2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions.\n"
"\n"
"To that end consider an arbitrary pair of functions ยง3 and ยง4 that have the same domain type ยง5 but are otherwise unrelated.\n"
"\n"
"These functions can be combined to define a single function of type ยง6 whose component functions are defined by ยง7 and ยง8, respectively.\n"
"\n"
"Your task in this level is to define the operation that produces a function into a product type from a pair of component functions.\n"
"\n"
"While it is not strictly necessary to solve this level, we use this opportunity to introduce the ยง9 tactic. The ยง10 tactic is similar to the ยง11 tactic from Implication World, but it is used for creating elements of types rather than proofs of propositions.\n"
"\n"
"Suppose your context contains an element ยง12. Using this element it is possible to define functions of type ยง13 and ยง14. The ยง15 tactic can be used to add these to your context with explicit names.\n"
"\n"
"Typing ยง16 will add the function defined by the first component of ยง17 to your context and give it the name ยง18. Similarly, typing ยง19 will add the function defined by the second component of ยง20 to your context and give it the name ยง21.\n"
"\n"
"Practice using the ยง22 tactic while solving this level."
msgstr ""

#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "Right Inclusion"
msgstr ""

#. ยง0: `False.elim : Empty โ P`
#. ยง1: `exact False.elim`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Lean has a built-in name ยง0 for the theorem you have just proven. Thus ยง1 will also solve this level. This theorem has been added to the library."
msgstr ""

#. ยง0: `ยซ{nor}ยป`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What can you do with the hypothesis ยง0?"
msgstr ""

#. ยง0: `Bool`
#. ยง1: `false : Bool`
#. ยง2: `true : Bool`
#. ยง3: `Bool โ Bool`
#. ยง4: `false`
#. ยง5: `true`
#. ยง6: `true`
#. ยง7: `false`
#. ยง8: `intro b`
#. ยง9: `Bool`
#. ยง10: `b`
#. ยง11: `false`
#. ยง12: `true`
#. ยง13: `cases b`
#. ยง14: `false`
#. ยง15: `true`
#. ยง16: `cases`
#. ยง17: `intro b`
#. ยง18: `match b with | false => exact ? | true => exact ?`
#. ยง19: `?`
#. ยง20: `Bool`
#. ยง21: `Bool โ Bool`
#. ยง22: `true`
#. ยง23: `false`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Recall the type ยง0 of booleans has two elements denoted ยง1 and ยง2.\n"
"\n"
"In this level, our aim is to define a function ยง3 that encodes the logical operation of negation, i.e., sends ยง4 to ยง5 and ยง6 to ยง7.\n"
"\n"
"You can start to define this function in the usual way, by typing ยง8. Lean will then update the goal to ask you to supply an element of type ยง9. But which element should you pick?\n"
"\n"
"The correct answer depends on whether ยง10 is ยง11 or ยง12. The type of Booleans is an example of an *inductive type*, which is\n"
"similar to a coproduct type, and thus you can type ยง13 to split into the two possible cases.\n"
"\n"
"Note the first case provided by Lean is the case of ยง14 while the second case is the case of ยง15.\n"
"\n"
"Unfortunately, it is difficult to see which case is which in typewriter mode. Try toggling to editor mode and perhaps add a few blank lines at the bottom to see if you can see what case you are in.\n"
"\n"
"Alternatively, if you prefer to stay in typewriter mode, you can avoid the ยง16 tactic and define the entire function at once in one line.\n"
"\n"
"After ยง17, try typing ยง18 where each ยง19 should be replaced by the appropriate element of ยง20.\n"
"\n"
"Note this level comes with two pre-defined goals: the first is to define the negation function ยง21 and the second is to check that your definition is correct by calculating the values of the function you defined on the booleans ยง22 and ยง23."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โ Q`
#. ยง3: `ยฌ Q โ ยฌ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "For any propositions ยง0 and ยง1, if ยง2 holds then ยง3 also holds."
msgstr ""

#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "This function is in the library. Rather than redefine it, can you use it?"
msgstr ""

#. ยง0: `Bool.noConfusion`
#. ยง1: `ยฌ (false = true)`
#. ยง2: `ยฌ (true = false)`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "ยง0 proves ยง1 or ยง2 for booleans."
msgstr ""

#. ยง0: `P โง Q โ R`
#. ยง1: `P โ Q โ R`
#. ยง2: `P โ (Q โ R)`
#. ยง3: `(P โ Q) โ R`
#. ยง4: `And.curry`
#. ยง5: `And.uncurry`
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "We now establish a logical equivalence between ยง0 and ยง1.\n"
"\n"
"This is why implications of the form ยง2 are so much more common than implications of the form ยง3.\n"
"\n"
"The two implications that comprise this logical equivalence are referred to as *currying* and *uncurrying* because they are the logical analogs of the currying and uncurrying operations on functions of two variables.\n"
"\n"
"Note the two implications proven in the previous two levels have been added to the theorem library, should you wish to use them. Their full names are ยง4 and ยง5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "A function is *bijective* if it is both injective and surjective."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P โง Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If ยง0 is true then ยง1 is true."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `b : B`
#. ยง2: `a : A`
#. ยง3: `f a = b`
#. ยง4: `f : A โ B`
#. ยง5: `g : B โ C`
#. ยง6: `g โ f : A โ C`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Recall that a function ยง0 is *surjective* if for every ยง1 there exists some ยง2 so that ยง3.\n"
"\n"
"Your task in this level is to show that surjective functions compose: if ยง4 is surjective and ยง5 is surjective, then ยง6 is surjective."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Introducing And"
msgstr ""

#. ยง0: `cases`
#. ยง1: `cases ยซ{hpq}ยป`
#. ยง2: `rcases ยซ{hpq}ยป with hp | hq`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "The hypothesis generated by the ยง0 tactic isn't directly useable yet. Try ยง1 again, or ยง2 to name your own variables."
msgstr ""

#. ยง0: `A โ Empty`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `f : A โ Empty`
#. ยง4: `A โ B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "In this level, we will explore another weird consequence of the hypothesis that we have a function of type ยง0.\n"
"\n"
"Let ยง1 and ยง2 be any types and assume there is a function ยง3.\n"
"\n"
"Then it is always possible to define a function ยง4.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `f : A โ B โ C`
#. ยง2: `a : A`
#. ยง3: `b : B`
#. ยง4: `f a b : C`
#. ยง5: `f`
#. ยง6: `a`
#. ยง7: `b`
#. ยง8: `A โ B โ C`
#. ยง9: `B โ A โ C`
#. ยง10: `A โ B โ C`
#. ยง11: `B`
#. ยง12: `A`
#. ยง13: `C`
#. ยง14: `intro f b a`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Recall that an element of type ยง0 can be thought of as a function of two variables.\n"
"\n"
"Given ยง1, ยง2, and ยง3, ยง4 denotes ยง5 applied first to ยง6 and then to ยง7.\n"
"\n"
"From a function of type ยง8, we can define a function of type ยง9 by exchanging the order of the variables that are input into the function.\n"
"\n"
"Here the goal is a multivariable function type that takes three inputs &mdash; of types ยง10 and ยง11 and ยง12 &mdash; and returns one ouput, of type ยง13. If you like, you can start with ยง14 to introduce all three variables at once."
msgstr ""

#. ยง0: `x = x`
#. ยง1: `x : A`
#. ยง2: `x = y`
#. ยง3: `y = x`
#. ยง4: `x = y`
#. ยง5: `y = z`
#. ยง6: `x = z`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "We've seen that equality is *reflexive*, meaning that ยง0 for any element ยง1.\n"
"\n"
"We've also proven that equality is *symmetric*: if ยง2 then ยง3.\n"
"\n"
"In this level, we will prove that equality is *transitive*: if ยง4 and ยง5, then ยง6."
msgstr ""

#. ยง0: `apply ยซ{h}ยป`
#. ยง1: `exact ยซ{h}ยป ยซ{p}ยป`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "You can use ยง0 or conclude with ยง1. Can you understand the meaning of both proofs?"
msgstr ""

#. ยง0: `P`
#. ยง1: `A`
#. ยง2: `P`
#. ยง3: `p : P`
#. ยง4: `p`
#. ยง5: `P`
#. ยง6: `P`
#. ยง7: `p`
#. ยง8: `P`
#. ยง9: `P`
#. ยง10: `p`
#. ยง11: `P`
#. ยง12: `P`
#. ยง13: `p`
#. ยง14: `P`
#. ยง15: `P`
#. ยง16: `P`
#. ยง17: `assumption`
#. ยง18: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "In this level, we consider a proposition ยง0 in place of a type ยง1.\n"
"\n"
"When a proposition ยง2 has an element ยง3 we think of ยง4 as a *proof* that the proposition ยง5 is true.\n"
"\n"
"The context for this level collectively asserts that ยง6 is a proposition and ยง7 is a proof of ยง8. In particular, our assumptions imply that the proposition ยง9 is true.\n"
"\n"
"As we will see, it is useful to have an explicit name ยง10 for the proof that ยง11 is true. When we reference the truth of the proposition ยง12 to prove other propositions, we will do so by referring to the element ยง13.\n"
"\n"
"Our goal, which is displayed to the right of the vertical line, is to prove the proposition ยง14.\n"
"\n"
"We know that ยง15 is true because we have assumed that ยง16 is true. So the tactic ยง17 can be used to tell Lean that ยง18 is true by assumption."
msgstr ""

#. ยง0: `use`
#. ยง1: `Bool`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Type ยง0 followed by the name of an element of ยง1 that you believe will satisfy the predicate."
msgstr ""

#. ยง0: `intro`
#. ยง1: `Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "To prove a universally quantified statement, start with ยง0 to introduce arbitrary elements of type ยง1. "
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "The inverse of an invertible function is invertible."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "The function ยง0 is injective."
msgstr ""

#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Define the composition of two functions as a multivariable function between function types."
msgstr ""

#. ยง0: `ยซ{lem}ยป`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Now might be a good time to case split on the hypothesis ยง0."
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "What is the outermost logical connective? What tactic is used to prove statements of this form?"
msgstr ""

#. ยง0: `p : P`
#. ยง1: `h : P โ Q`
#. ยง2: `Q`
#. ยง3: `h`
#. ยง4: `P โ Q`
#. ยง5: `Q`
#. ยง6: `P`
#. ยง7: `p : P`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `p : P`
#. ยง11: `h : P โ Q`
#. ยง12: `h`
#. ยง13: `P`
#. ยง14: `Q`
#. ยง15: `h`
#. ยง16: `p`
#. ยง17: `Q`
#. ยง18: `h p`
#. ยง19: `exact h p`
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "We just proved modus ponens using backwards reasoning.\n"
"\n"
"We were given proofs ยง0 and ยง1 were true and argued that it follows that ยง2 is also true.\n"
"\n"
"To show this, we used the proof ยง3 of the implication ยง4 to argue that to prove that ยง5 is true it suffices to prove that ยง6 is true.\n"
"\n"
"We then noted that the element ยง7 proves that ยง8 is true.\n"
"\n"
"Lean also has a syntax that allows us to directly construct a proof of ยง9 out of the proofs ยง10 and ยง11.\n"
"\n"
"The proof ยง12 can be thought of as a *function* that converts proofs of ยง13 into proofs of ยง14.\n"
"\n"
"In particular, we can apply the function ยง15 to the proof ยง16 to obtain a proof of ยง17 denoted by ยง18.\n"
"\n"
"Thus, you can solve this level, proving modus ponens again, simply by typing ยง19."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `f : A ร B โ C`
#. ยง3: `โจa, bโฉ : A ร B`
#. ยง4: `h : C โ D`
#. ยง5: `a' : A`
#. ยง6: `b' : B`
#. ยง7: `g : A ร B โ C`
#. ยง8: `โจa',b'โฉ : A ร B`
#. ยง9: `k : C โ D`
#. ยง10: `p : a = a'`
#. ยง11: `q : b = b'`
#. ยง12: `r : h โ f = k โ g`
#. ยง13: `h โ f`
#. ยง14: `k โ g`
#. ยง15: `h โ f`
#. ยง16: `k โ g`
#. ยง17: `r`
#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "For the Boss Level of Equality World, you are asked to prove an equality of a more elaborate form than we've seen thus far.\n"
"\n"
"On the left-hand side of the equality is an element defined by\n"
"\n"
"* starting with a pair of elements ยง0 and ยง1,\n"
"* applying a function ยง2 to the pair ยง3, and\n"
"* then applying a function ยง4 to the result.\n"
"\n"
"On the right-hand side of the equality is an element defined by\n"
"* starting with a pair of elements ยง5 and ยง6,\n"
"* applying a function ยง7 to the pair ยง8, and\n"
"* then applying a function ยง9 to the result.\n"
"\n"
"In general, these elements would be distinct. However, we have assumed that we have equalities ยง10, ยง11, and ยง12.\n"
"\n"
"The last of these hypotheses is in a form that makes it somewhat difficult to use, as the functions ยง13 and ยง14 do not appear explicitly in the goal.\n"
"\n"
"But if you recall the way that composition of functions is defined, you'll see that these elements do appear implicitly in the goal.\n"
"\n"
"To solve this level, you will need to prove and then rewrite along another equality so that at least one of the functions ยง15 or ยง16 appears explicitly in the goal. This technique will be used frequently in Advanced Function World.\n"
"\n"
"Then you will be able to use the hypothesis ยง17 to complete the proof.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `have eq : โ a : A, (g โ f) a = g (f a) := fun a โฆ rfl`
#. ยง1: `(g โ f) x = (g โ f) y`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Alternatively, you could prove lemmas by ยง0 and then use rewrites to convert the goal into one where you can apply the hypothesis ยง1. Because the lemmas hold by definitional equality, you were able to skip that step."
msgstr ""

#. ยง0: `ยซ{b}ยป`
#. ยง1: `surj ยซ{b}ยป : โ x : A, f x = ยซ{b}ยป`
#. ยง2: `a`
#. ยง3: `let a := (surj ยซ{b}ยป).choose`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "At this stage of the proof, the idea is to apply the surjectivity hypothesis at ยง0, using the element ยง1. To extract an element of ยง2 satisfying this condition type ยง3."
msgstr ""

#. ยง0: `rw [p, q]`
#. ยง1: `rw [q, p]`
#. ยง2: `rw [โ q, โ p]`
#. ยง3: `rw [โ q, p]`
#. ยง4: `rw [โ p, โ q]`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Try solving the goal by rewriting in both directions. You can also experiment with multiple rewrites at once, using a comma to separate multiple proofs of equality inside the brackets. Why does ยง0 work but ยง1 not? Why does ยง2 or ยง3 work but ยง4 not?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "Inverse Invertibility"
msgstr ""

#. ยง0: `g : B โ A`
#. ยง1: `f (g (f ยซ{x}ยป)) = f ยซ{x}ยป`
#. ยง2: `ยซ{x}ยป : A`
#. ยง3: `g (f (ยซ{x}ยป))`
#. ยง4: `f`
#. ยง5: `f ยซ{x}ยป`
#. ยง6: `apply (surj f ยซ{x}ยป).choose_spec`
#. ยง7: `f ยซ{x}ยป : B`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "If ยง0 is the name of the inverse function you defined using the axiom of choice, now you are now meant to show that ยง1 for an arbitrary element ยง2. This element ยง3 was chosen using the surjectivity hypothesis so that when you apply ยง4 you get the element ยง5 back. Type ยง6 to apply the other half of the surjectivity hypothesis at the element ยง7."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `x : A`
#. ยง5: `f x : B`
#. ยง6: `g (f x) : C`
#. ยง7: `exact fun x โฆ ?`
#. ยง8: `?`
#. ยง9: `</>`
#. ยง10: `editor mode`
#. ยง11: `>_`
#. ยง12: `typewriter mode`
#. ยง13: `typewriter mode`
#. ยง14: `retry`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions ยง0 and ยง1 there is a *composite function* from ยง2 to ยง3.\n"
"\n"
"It is defined to be the function that sends ยง4 first to the element ยง5 and then\n"
"to the element ยง6.\n"
"\n"
"Can you solve this level in one line by using ยง7 with the appropriate thing in place of the ยง8?\n"
"\n"
"Alternatively, you can use other tactics to define the required function step by step.\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled ยง9 in the upper right hand corner to enter ยง10. Then delete all the lines of your first proof (or proof attempt). Clicking on ยง11 takes you back to ยง12.\n"
"\n"
"You can also delete a proof attempt in line by line in ยง13 using the ยง14 button to the right of that line."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "You have two things to prove. To break the goals into pieces, type `constructor."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `(P โ Q) โง (Q โ P)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "ยง0, read as &ldquo;ยง1 if and only if ยง2&rdquo; is an abbreviation for ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `id : A โ A`
#. ยง2: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type ยง0, the identity function ยง1 is the function defined by sending and arbitrary element ยง2 to itself."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Think carefully about what ยง0 proves and what proofs can be extracted from this."
msgstr ""

#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "Functions out of product types are well-defined, both regarding equalities between elements and equalities between hypotheses."
msgstr ""

#. ยง0: `And.symm`
#. ยง1: `P โง Q`
#. ยง2: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "The proof you have just constructed is now recorded as a theorem called ยง0 in the library to the right.\n"
"\n"
"In fact ยง1 is true if and only if ยง2 is true, as we will now demonstrate."
msgstr ""

#. ยง0: `X`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `X โ A ร B`
#. ยง4: `(X โ A) ร (X โ B)`
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "For any types ยง0, ยง1, and ยง2, the types ยง3 and ยง4 are equivalent."
msgstr ""

#. ยง0: `intro p`
#. ยง1: `p : A ร B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The goal is a term of a function type so type ยง0 to give yourself a term ยง1."
msgstr ""

#. ยง0: `cases h : x`
#. ยง1: `cases k :
#. cases y`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L05_Disjunction
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "Recall ยง0 and ยง1 may make it clearer which cases are which."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P โ P`
#. ยง2: `P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `P`
#. ยง6: `P`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The Boss Level of Negation World previews the next world by studying the relationship between two *classical* tautologies that we have not been able to prove involving a proposition ยง0.\n"
"\n"
"One statement we have not been able to prove is called *double negation elimination*: ยง1.\n"
"\n"
"Double negation elimination asserts that if ยง2 is not false, then ยง3 must be true.\n"
"\n"
"Another statement we have not been able to prove is called *law of excluded middle*: ยง4.\n"
"\n"
"The law of excluded middle asserts that either ยง5 is true or ยง6 is false.\n"
"\n"
"In Classical World, we'll explore why these statements fall outside the realm of *constructive logic*.\n"
"\n"
"But what we *can* prove constructively is that for any proposition ยง7, the law of excluded middle for ยง8 implies double negation elimination for ยง9.\n"
"\n"
"Have fun!"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "And Implies Or"
msgstr ""

#. ยง0: `n`
#. ยง1: `0`
#. ยง2: `(โ m : โ, 0 = 2 * m) โจ (โ m : โ, 0 = 2 * m + 1)`
#. ยง3: `left`
#. ยง4: `right`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "You are first asked to prove the base case assuming the natural number ยง0 from the original statement is ยง1. Thus your goal is to prove ยง2. Use the tactic ยง3 to indicate that you'd like to prove the left-hand statement or ยง4 to indicate that you'd like to prove the right-hand statement."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What proof strategy is available with an element of a coproduct type?"
msgstr ""

#. ยง0: `โ โ โ โ โ`
#. ยง1: `Nat.add m n`
#. ยง2: `m + n`
#. ยง3: `add_zero m : m + 0 = m`
#. ยง4: `add_succ m n : m + succ n = succ (m + n)`
#. ยง5: `add_assoc a b c : (a + b) + c = a + (b + c)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The binary addition function ยง0 is called ยง1, with notation ยง2. This is the usual sum of natural numbers, defined via the following two hypotheses:\n"
"\n"
"ยง3\n"
"\n"
"ยง4\n"
"\n"
"Other theorems about naturals, such as ยง5, are proved by induction using these two basic theorems.\""
msgstr ""

#. ยง0: `ยซ{Q}ยป โ ยซ{P}ยป`
#. ยง1: `intro q`
#. ยง2: `q : ยซ{Q}ยป`
#. ยง3: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "To prove an implication, which in this case has the form ยง0, type ยง1 to introduce an assumption ยง2 and update the goal to ยง3."
msgstr ""

#. ยง0: `Nat.pred : โ โ โ`
#. ยง1: `0`
#. ยง2: `0`
#. ยง3: `succ n`
#. ยง4: `n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "The function ยง0 is defined by recursion to send ยง1 to ยง2 and ยง3 to ยง4."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `pred : โ โ โ`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Use the tactic ยง0 to split the level into two goals, the first of which is to define the function ยง1."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `p : A ร B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `p : A ร B`
#. ยง5: `p.1 : A`
#. ยง6: `p.2 : B`
#. ยง7: `p.fst : A`
#. ยง8: `p.snd : B`
#. ยง9: `A ร B โ A`
#. ยง10: `A ร B โ B`
#. ยง11: `p : A ร B`
#. ยง12: `A`
#. ยง13: `B`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "The elimination rules for product types tell us which elements can be constructed from an element ยง0.\n"
"\n"
"There are two elimination rules: from an element ยง1, we may extract an element of ยง2, thought of as its first component, and also an element of ยง3, thought of as its second component.\n"
"\n"
"In Lean, the elements defined by projecting from ยง4 are denoted ยง5 and ยง6 or ยง7 and ยง8.\n"
"\n"
"These rules define *projection functions* of type ยง9 and ยง10, which take an element ยง11 and return the corresponding components from ยง12 and ยง13 respectively.\n"
"\n"
"Your task in this level is to define the first projection function."
msgstr ""

#. ยง0: `+ : โ โ โ โ โ`
#. ยง1: `add_zero n : n + 0 = n`
#. ยง2: `add_succ m n : m + succ n = succ (m + n)`
#. ยง3: `0 + n = n`
#. ยง4: `n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "The addition function ยง0 is defined by the equations\n"
"\n"
"* ยง1 and\n"
"* ยง2.\n"
"\n"
"It is of course also true that ยง3 for all natural numbers ยง4, but this equation does not hold by definition.\n"
"\n"
"Instead you have to prove it by induction!\n"
"\n"
"Good luck."
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Type ยง0 to ask Lean to consider all possible cases involving a proof of false. As there are no cases, this will complete the proof."
msgstr ""

#. ยง0: `ยซ{m}ยป`
#. ยง1: `ยซ{n}ยป`
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "You can apply induction on either variable ยง0 or ยง1. It will be easiest, however, to induct on the same variable we used to define the addition function."
msgstr ""

#: Game.Levels.NegationWorld
msgid "Negation World"
msgstr ""

#. ยง0: `x = y`
#. ยง1: `y = x`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Equality is symmetric: if ยง0 then ยง1."
msgstr ""

#. ยง0: `false : Bool`
#. ยง1: `true : Bool`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "The elements ยง0 and ยง1 are not equal."
msgstr ""

#. ยง0: `ยซ{P}ยป โ ยซ{Q}ยป`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "Which tactics can be used to prove ยง0 with our given assumptions?"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `f`
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "The function ยง0 is an isomorphism if and only if ยง1 is invertible."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What implications can you extract from ยง0?"
msgstr ""

#. ยง0: `cases`
#. ยง1: `Empty`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Use the ยง0 tactic to consider all possible cases for elements of ยง1."
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "The converse implication is more subtle, and will be addressed in the Classical World."
msgstr ""

#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "Unit Proposition"
msgstr ""

#. ยง0: `ยซ{C}ยป`
#. ยง1: `exact`
#. ยง2: `apply`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Now that the goal is an element of type ยง0 there are several ways to proceed. You can use ยง1 or ยง2."
msgstr ""

#. ยง0: `Function.uncurry : (A โ B โ C) โ (A ร B โ C)`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"The operations of *currying* and *uncurrying* are inverses in a sense we will be able to make precise later."
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "First Projection"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ x y : A, f x = f y โ x = y`
#. ยง2: `f : A โ B`
#. ยง3: `g : B โ C`
#. ยง4: `g โ f : A โ C`
#. ยง5: `f`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Recall that a function ยง0 is *injective* if ยง1.\n"
"\n"
"In this level, we will prove that if ยง2 and ยง3 are functions, then if the composite ยง4 is injective, the function ยง5 must also be injective."
msgstr ""

#. ยง0: `exact b`
#. ยง1: `assumption`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Both ยง0 and ยง1 can be used here."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ (A โ B) โ B`
#. ยง3: `a : A`
#. ยง4: `ev a`
#. ยง5: `(A โ B) โ B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "For types ยง0 and ยง1, the evaluation function has type ยง2, meaning that for ยง3, ยง4 has type ยง5."
msgstr ""

#. ยง0: `cases ยซ{h}ยป`
#. ยง1: `rcases ยซ{h}ยป with pr | ps | qr | qs`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Uses ยง0 or ยง1 to break the hypothesis into the constituent cases"
msgstr ""

#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Composition Revisited"
msgstr ""

#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Noncontradiction"
msgstr ""

#. ยง0: `Q`
#. ยง1: `exact ยซ{h}ยป.2`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now Lean reminds you of the other goal, which is to prove ยง0. Type ยง1 to supply this proof."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#. ยง1: `Show more help!`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now your goal is a proof of ยง0. Can you figure out how to finish the proof? If you need a reminder, click the button ยง1"
msgstr ""

#. ยง0: `Sum.inl : A โ A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "The function ยง0 provides the first introduction rule for coproduct types. In the next level, we will explore the second introduction rule."
msgstr ""

#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Not Equal"
msgstr ""

#. ยง0: `exact โจFunction.curry, Function.uncurry, fun f โฆ rfl, fun f โฆ rflโฉ`
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "Note this level can be solved in one line with\n"
"ยง0. Can you make sense of this proof?"
msgstr ""

#. ยง0: `let e := ยซ{f}ยป ยซ{a}ยป`
#. ยง1: `let e : Empty := ยซ{f}ยป ยซ{a}ยป`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Use ยง0 or ยง1 to add an element of the empty type to the list of assumptions."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `x y : A`
#. ยง2: `p : x = y`
#. ยง3: `congrArg f p : f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "For a function ยง0 between types, elements ยง1, and a proof ยง2, then ยง3."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#. ยง3: `\\circ`
#. ยง4: `โ`
#. ยง5: `x : A`
#. ยง6: `(g โ f) x`
#. ยง7: `g (f x)`
#. ยง8: `g`
#. ยง9: `f`
#. ยง10: `g โ f`
#. ยง11: `exact g โ f`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Lean has built in notation for the composite of ยง0 and ยง1 namely ยง2, using ยง3 to type ยง4.\n"
"\n"
"Given ยง5, ยง6 is defined to be the element ยง7, which is why the function ยง8 appears on the left of ยง9 in the notation ยง10.\n"
"\n"
"Try solving this level with ยง11."
msgstr ""

#. ยง0: `cases`
#. ยง1: `rcases`
#. ยง2: `ยซ{p}ยป`
#. ยง3: `B โ C`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You can use ยง0 or ยง1 either on ยง2 to split it up into components or directly on its component in ยง3.Be careful to use the syntax that is appropriate for terms of product or coproduct types, respectively."
msgstr ""

#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
msgid "Conjunction Symmetry"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `โจa, bโฉ : A ร B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "By pairing any element ยง0 with any element ยง1, there is an element ยง2."
msgstr ""

#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Paired Projections"
msgstr ""

#. ยง0: `h : โ a : A, P a`
#. ยง1: `P : A โ Prop`
#. ยง2: `h.choose_spec`
#. ยง3: `h.choose : A`
#. ยง4: `P (h.choose)`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Given a proof ยง0 for some ยง1, ยง2 gives a proof that the\n"
"element ยง3 satisfies ยง4."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `Q โ R`
#. ยง2: `P โ R`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "If ยง0, then if ยง1, then ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If the proposition ยง0 is true, then ยง1 is true."
msgstr ""

#. ยง0: `apply (surj ยซ{b}ยป).choose_spec`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Type ยง0 to apply the other half of the surjectivity hypothesis."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `ยซ{P}ยป`
#. ยง2: `ยซ{Q}ยป`
#. ยง3: `ยซ{Q}ยป`
#. ยง4: `ยซ{P}ยป`
#. ยง5: `apply ยซ{h}ยป`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The hypothesis ยง0 can be used to convert a proof of ยง1 into a proof of ยง2. This can be thought of as a step that reduces the problem of proving ยง3 to the problem of proving ยง4. To apply this hypothesis type ยง5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "Bijectivity"
msgstr ""

#. ยง0: `Sum.inr : B โ A โ B`
#. ยง1: `A โ B`
#. ยง2: `B`
#. ยง3: `apply Sum.inr`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "To use the built in function ยง0 to change the goal from ยง1 to ยง2 type ยง3."
msgstr ""

#. ยง0: `Empty`
#. ยง1: `Empty`
#. ยง2: `A`
#. ยง3: `A`
#. ยง4: `Empty.elim : Empty โ A`
#. ยง5: `Empty โ A`
#. ยง6: `X`
#. ยง7: `A`
#. ยง8: `x : X`
#. ยง9: `A`
#. ยง10: `Empty`
#. ยง11: `A`
#. ยง12: `Empty`
#: Game.Levels.EmptyWorld
msgid "In this world, we will introduce the *empty type*, which is commonly denoted by ยง0 in Lean.\n"
"\n"
"In general, types are characterized by:\n"
"* Introduction rules: which explain how to construct elements of the given type.\n"
"* Elimination rules: which explain how to use elements of the given type to construct elements of other types.\n"
"\n"
"In the case of the empty type, there are no introduction rules. This corresponds colloquially to the idea that the empty type has &ldquo;no elements.&rdquo;\n"
"\n"
"The elimination rule for the empty type defines a function from ยง1 to any other type ยง2, with no obligations on the type ยง3. This provides a canonical element ยง4 of the function type.\n"
"\n"
"There is another way to understand why the type ยง5 should always have an element.\n"
"\n"
"In order to define a function from a type ยง6 to a type ยง7 one must fulfill the following obligation: for each ยง8 one must specify an element of type ยง9.\n"
"\n"
"In the case of a function from the type ยง10 to a type ยง11, there are no obligations because the empty type has no elements.\n"
"\n"
"In this world, we will explore constructions involving the ยง12 type."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#. ยง2: `P โ Q`
#. ยง3: `ยฌ Q โ ยฌ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "In this level, we will study the relationship between an implication ยง0 and its *contrapositive*, which is the statement ยง1.\n"
"\n"
"The objective in this level is to prove that ยง2 implies ยง3.\n"
"\n"
"In fact, the construction of this proof should feel very familiar!\n"
"\n"
"The other direction of implication is considerably more subtle and will be discussed in Classical World."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โง Q) โง R`
#. ยง4: `P โง (Q โง R)`
#. ยง5: `P โง Q โง R`
#. ยง6: `P โง (Q โง R)`
#. ยง7: `h : (P โง Q) โง R`
#. ยง8: `h.1 : P โง Q`
#. ยง9: `h.2 : R`
#. ยง10: `h.1.1 : P`
#. ยง11: `h.1.2 : Q`
#. ยง12: `k : P โง (Q โง R)`
#. ยง13: `k.1 : P`
#. ยง14: `k.2 : Q โง R`
#. ยง15: `k.2.1 : Q`
#. ยง16: `k.2.2 : R`
#. ยง17: `p : P`
#. ยง18: `q : Q`
#. ยง19: `r : R`
#. ยง20: `โจโจp, qโฉ, rโฉ : (P โง Q) โง R`
#. ยง21: `โจp, โจq, rโฉโฉ : P โง (Q โง R)`
#. ยง22: `โจp, q, rโฉ : P โง Q โง R`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "For propositions ยง0, ยง1, and ยง2, ยง3 is true if and only if ยง4 is true.\n"
"\n"
"Lean likes to drop parentheses whenever possible so uses ยง5 as an abbreviation for ยง6. While it's difficult to remember this convention, at least the two possible statements are logically equivalent!\n"
"\n"
"Given a proof ยง7, we obtain proofs ยง8 and ยง9. From the first of these,\n"
"we obtain further proofs ยง10 and ยง11.\n"
"\n"
"A proof ยง12 can be decomposed similarly, using different notation. Now we have proofs ยง13 and ยง14 and the latter proof decomposes further as ยง15 and ยง16.\n"
"\n"
"Similarly, given proofs ยง17, ยง18, ยง19, then ยง20 while ยง21 are proofs of the triple conjunction. Lean allows the shorthand ยง22 for the latter proof.\n"
"\n"
"Your goal in this level is to prove the associativity of conjunction."
msgstr ""

#. ยง0: `P`
#. ยง1: `p : P`
#. ยง2: `p`
#. ยง3: `P`
#. ยง4: `P`
#. ยง5: `assumption`
#. ยง6: `p`
#. ยง7: `exact p`
#. ยง8: `assumption`
#. ยง9: `exact`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "We warm up by revisiting our first mathematical theorem, proven already in Type World.\n"
"\n"
"This theorem concerns an arbitrary proposition ยง0 which can be any well-formed mathematical statement.\n"
"\n"
"The hypothesis ยง1  can be thought of as providing a *proof* ยง2 that the proposition ยง3 is true. Our objective is to conclude that ยง4 is true, given this hypothesis.\n"
"\n"
"This is true by assumption, and you can type ยง5 to tell Lean this.\n"
"\n"
"But it is a bit more precise to tell Lean this is true by the assumption ยง6 which can be done by typing ยง7.\n"
"\n"
"If it is helpful to review the ยง8 and ยง9 tactics, you can read more about them in the tactic library on the upper right."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "The goal is still an implication, so try another ยง0."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that you've completed the proof in the first case, Lean expects you to provide a proof in the second case."
msgstr ""

#. ยง0: `exact โจp,qโฉ`
#. ยง1: `\\<`
#. ยง2: `\\>`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Alternatively, you can type ยง0 using ยง1 and ยง2 to type the angle brackets."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "In the next levels, we will study general properties of surjective functions."
msgstr ""

#: Game.Levels.ClassicalWorld
msgid "Classical World"
msgstr ""

#. ยง0: `ยซ{a}ยป`
#. ยง1: `f ยซ{a}ยป = ยซ{b}ยป`
#. ยง2: `have ha : f a = b := (surj b).choose_spec`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "You can also add the proof that your element ยง0 satisfies the equation ยง1 to the context by typing ยง2."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Let us now explore other implications that are provable with this strategy."
msgstr ""

#. ยง0: `! ยซ{x}ยป = ! ยซ{y}ยป`
#. ยง1: `! ยซ{x}ยป`
#. ยง2: `not ยซ{x}ยป`
#. ยง3: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "You should also introduce the hypothesis ยง0. Here Lean writes ยง1 for ยง2, where ยง3 is the boolean negation function."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Using Or"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Surjectivity"
msgstr ""

#. ยง0: `intro n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Start with ยง0 to prove the universally quantified statement."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `B`
#. ยง2: `const a : B โ A`
#. ยง3: `x : B`
#. ยง4: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "For a term ยง0 and a type ยง1, ยง2 is the function defined by sending ยง3 to ยง4."
msgstr ""

#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Note the similarly with the first level of Equality World. In fact, all of the statements we have proven about arbitrary elements of types can be reinterpreted as proving universally quantified propositions."
msgstr ""

#. ยง0: `apply Function.Injective.of_comp succ pred`
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "One of several options is to start the proof with ยง0, specializing a general result from Advanced Function World to this particular case. You are now ready for the Boss Level."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "The successor function is injective."
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "Left Inclusion"
msgstr ""

#. ยง0: `p : P`
#. ยง1: `h : P โ Q`
#. ยง2: `Q`
#. ยง3: `h p : Q`
#. ยง4: `h`
#. ยง5: `P โ Q`
#. ยง6: `p`
#. ยง7: `P`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Modus ponens tells us that under hypotheses ยง0 and ยง1 then ยง2 is true.\n"
"\n"
"The proof is given by ยง3, thought of as the result of applying the proof ยง4 of the implication ยง5 to the proof ยง6 of ยง7.\n"
"\n"
"Can you see why the following theorem is another form of modus ponens?"
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "Commuting Addition"
msgstr ""

#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Composing Functions"
msgstr ""

#. ยง0: `ยซ{ne}ยป`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "How can you use the hypothesis ยง0?"
msgstr ""

#. ยง0: `f a : B`
#. ยง1: `f`
#. ยง2: `a`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "While the tactics used in this level and the previous one are different, both solutions ultimately tell Lean to use the element ยง0 built by applying the function ยง1 to the element ยง2."
msgstr ""

#. ยง0: `h : P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `R`
#. ยง6: `P`
#. ยง7: `R`
#. ยง8: `Q`
#. ยง9: `Q`
#. ยง10: `R`
#. ยง11: `P`
#. ยง12: `h : P โจ Q`
#. ยง13: `cases h`
#. ยง14: `P`
#. ยง15: `Q`
#. ยง16: `cases`
#. ยง17: `h : P โจ Q`
#. ยง18: `rcases h with p | q`
#. ยง19: `cases h`
#. ยง20: `p : P`
#. ยง21: `q : Q`
#. ยง22: `p`
#. ยง23: `q`
#. ยง24: `A โ B`
#. ยง25: `P โจ Q`
#. ยง26: `Q โจ P`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Given a hypothesis ยง0, we know that *either* ยง1 or ยง2 is true (or possibly both are true).\n"
"\n"
"But we don't know *which* of ยง3 or ยง4 is true.\n"
"\n"
"If we want to use a hypothesis like this to prove some other proposition ยง5 is true we need proofs that cover either of the two cases: that is, we need to show that ยง6 implies ยง7 (whether or not ยง8 is true) and also that ยง9 implies ยง10 (whether or not ยง11 is true).\n"
"\n"
"If we have an assumption of the form ยง12, then type ยง13 to ask Lean to consider both cases: the first being that ยง14 is true and the second being that ยง15 is true.\n"
"\n"
"There is another tactic, similar to ยง16, which allows you to give explicit names for the hypotheses assumed in each case.\n"
"\n"
"When given a hypothesis ยง17, then ยง18 can be used in place of ยง19 to give hypotheses ยง20 in the first case and ยง21 in the second. (Here you can choose any variable names for ยง22 and ยง23.)\n"
"\n"
"This proof strategy should be reminiscent of a definition by cases of a function mapping out of a coproduct type ยง24. Recall the same tactics may be used for that sort of construction.\n"
"\n"
"In this level, use the strategy of arguing by cases to prove that or is symmetric, that is that ยง25 implies ยง26."
msgstr ""

#. ยง0: `rw [ยซ{p}ยป, ยซ{q}ยป, ยซ{r}ยป]`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall you can rewrite along multiple hypothesized equalities at once by typing ยง0."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `โจf, g, ฮฑ, ฮฒโฉ : A โ B`
#. ยง6: `f : A โ B`
#. ยง7: `g : B โ A`
#. ยง8: `ฮฑ : โ a : A, g (f a) = a`
#. ยง9: `ฮฒ : โ b : B, f (g b) = b`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "For types ยง0 and ยง1, ยง2 is the type of equivalences between ยง3 and ยง4. Its elements have the form ยง5 where ยง6, ยง7, ยง8, and ยง9."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `ยซ{rs}ยป : ยซ{R}ยป โจ ยซ{S}ยป`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "This completes the proof in the case where ยง0 holds because ยง1 holds. Now we've started the case where ยง2 holds, which requires another case split over the proof ยง3."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `Or.inl : P โ P โจ Q`
#. ยง2: `Or.inr : Q โ P โจ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way. Alternatively, you can prove ยง0 by applying either of the implications ยง1 and ยง2 that are now in the library."
msgstr ""

#: Game.Levels.DisjunctionWorld
msgid "Disjunction World"
msgstr ""

#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "Evaluation"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "The statement is a conjunction so use ยง0 to break into subgoals."
msgstr ""

#. ยง0: `A`
#. ยง1: `x : A`
#. ยง2: `y : A`
#. ยง3: `x = y`
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "For any type ยง0, for all elements ยง1, there exists an element ยง2, so that ยง3."
msgstr ""

#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Using Functions Backwards"
msgstr ""

#. ยง0: `w x y z : A`
#. ยง1: `w = x `
#. ยง2: `x = y`
#. ยง3: `y = z`
#. ยง4: `w = z`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "For all ยง0 if ยง1 and ยง2 and ยง3 then ยง4."
msgstr ""

#. ยง0: `Empty`
#. ยง1: `Empty`
#. ยง2: `A`
#. ยง3: `Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The type ยง0 has no elements &mdash; or, more precisely, the type ยง1 has no introduction rules.\n"
"\n"
"Consequently, for any other type ยง2, there is always a function ยง3.\n"
"\n"
"The task in this level is to define it."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "The goal is a product type. You can use ยง0 to split into two goals, defining each component function separately."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ x y : A, f x = f y โ x = y`
#. ยง2: `f : A โ B`
#. ยง3: `g : B โ C`
#. ยง4: `g โ f : A โ C`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Recall that a function ยง0 is *injective* if ยง1.\n"
"\n"
"In this level, we will prove that if ยง2 and ยง3 are both injective functions, then the composite ยง4 must also be injective."
msgstr ""

#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "Excluded Middle"
msgstr ""

#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Modus Ponens Again"
msgstr ""

#. ยง0: `x = x`
#. ยง1: `x : A`
#. ยง2: `x = y`
#. ยง3: `y = x`
#. ยง4: `x = y โ y = x`
#. ยง5: `p : x = y`
#. ยง6: `y = x`
#. ยง7: `rw`
#. ยง8: `p : x = y`
#. ยง9: `p : x = y`
#. ยง10: `rw [p]`
#. ยง11: `x`
#. ยง12: `y`
#. ยง13: `y = x`
#. ยง14: `p`
#. ยง15: `y = y`
#. ยง16: `rw [โ p]`
#. ยง17: `\\l`
#. ยง18: `โ`
#. ยง19: `y`
#. ยง20: `x`
#. ยง21: `rw [โ p]`
#. ยง22: `rw [p]`
#. ยง23: `x = x`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "We've already seen that equality is *reflexive*, meaning that ยง0 for any element ยง1.\n"
"\n"
"In this level, we will prove that equality is also symmetric: if ยง2 then ยง3.\n"
"\n"
"To prove the implication ยง4 we may assume that we have a proof ยง5. This allows us to appeal to the elimination rule of equality types to prove our goal that ยง6 also holds.\n"
"\n"
"To do this, we will make use of the ยง7 tactic, pronounced &ldquo;rewrite,&rdquo; which is the primary way we will use a hypothesis of the form ยง8.\n"
"\n"
"If we have a hypothesis ยง9, then ยง10 will look for the first instance of the element ยง11 in the goal type and change it to ยง12.\n"
"\n"
"In the case here, the goal is to show that ยง13, so rewriting along ยง14 will change the goal to ยง15, which is easier to prove.\n"
"\n"
"This tactic can be used in two directions: ยง16 &mdash; using ยง17 to type ยง18 &mdash; will look for the first instance of a ยง19 in the goal and replace it with ยง20. Thus typing ยง21 instead of ยง22 will change the goal to ยง23.\n"
"\n"
"Try solving this level using both directions of rewriting."
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Note the goal window in the interactive theorem prover keeps track of exactly what proposition you are trying to prove."
msgstr ""

#. ยง0: `cases x <;> cases y <;> rfl`
#. ยง1: `<;>`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "This proof can be written in one line as ยง0 where the ยง1 means &ldquo;do the following in all cases&rdquo;."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "You have a very close approximation to this function in your library. Can you see how to modify it to have the form you need here?"
msgstr ""

#. ยง0: `Unit โ Unit`
#. ยง1: `Bool`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "The types ยง0 and ยง1 are equivalent."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Ex Falso"
msgstr ""

#. ยง0: `ยซ{A}ยป`
#: Game.Levels.ProductWorld.L01_Pairing
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Now Lean asks you to supply an element of type ยง0. Which tactic applies here?"
msgstr ""

#. ยง0: `f : Bool โ Bool`
#. ยง1: `f true = false โง f false = true`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Now you are asked to check that the function ยง0 that you just defined actually *is* the negation function. Specifically, you are asked to check that ยง1."
msgstr ""

#. ยง0: `cases`
#. ยง1: `rcases`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "This proves the symmetry of disjunction. Practice using both the ยง0 and ยง1 tactics to get used to them."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Now how do we prove a conjunction?"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ x : A, ยฌ (P x)`
#. ยง2: `ยฌ (โ x : A, P x)`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Given a family of propositions ยง0,  ยง1 is logically equivalent to ยง2"
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "This can be solved in two ways. Can you find them both?"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `ยฌ (P โจ Q)`
#. ยง3: `ยฌ P โง ยฌ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "For any propositions ยง0 and ยง1, the propositions ยง2 and ยง3 are logically equivalent."
msgstr ""

#. ยง0: `assumption`
#: Game.Levels.TypeWorld.L01_Elements
msgid "The ยง0 tactic tries to solve the main goal using a hypothesis of compatible type, or else fails."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ x : A, ยฌ (P x)`
#. ยง2: `ยฌ (โ x : A, P x)`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "Given a family of propositions ยง0,  ยง1 implies ยง2"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "We will explore the precise relationship between bijective functions and invertible functions soon. But first, we show that the inverse of an invertible function is again invertible."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Sum.inl : A โ A โ B`
#. ยง3: `A`
#. ยง4: `A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types ยง0 and ยง1, the function ยง2 can be used to include elements of type ยง3 as elements of the coproduct type ยง4."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "In the next levels, we will study general properties of injective functions."
msgstr ""

#. ยง0: `and : Bool โ Bool โ Bool`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "The function ยง0 is symmetric."
msgstr ""

#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "In the next levels, we will study the effect of negating existential and universal quantifiers."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `exact ยซ{p}ยป`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "To use the hypothesis ยง0 to reach this conclusion type ยง1."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A ร B) ร C`
#. ยง4: `A ร (B ร C)`
#. ยง5: `p : (A ร B) ร C`
#. ยง6: `p.1 : A ร B`
#. ยง7: `p.2 : C`
#. ยง8: `p.1 : A ร B`
#. ยง9: `p.1.1 : A`
#. ยง10: `p.1.2 : B`
#. ยง11: `q : A ร (B ร C)`
#. ยง12: `q.1 : A`
#. ยง13: `q.2 : B ร C`
#. ยง14: `q.2 : B ร C`
#. ยง15: `q.2.1 : B`
#. ยง16: `q.2.2 : C`
#. ยง17: `((A ร B) ร C) โ (A ร (B ร C))`
#. ยง18: `(A ร (B ร C)) โ ((A ร B) ร C)`
#. ยง19: `(((A ร B) ร C) โ (A ร (B ร C))) ร ((A ร (B ร C)) โ ((A ร B) ร C))`
#. ยง20: `(A ร B) ร C`
#. ยง21: `A ร (B ร C)`
#. ยง22: `A ร B ร C`
#. ยง23: `A ร (B ร C)`
#. ยง24: `A ร B ร C`
#. ยง25: `(A ร B) ร C`
#. ยง26: `a : A`
#. ยง27: `b : B`
#. ยง28: `c : C`
#. ยง29: `โจa,b,cโฉ : A ร B ร C`
#. ยง30: `โจa, โจb,cโฉโฉ : A ร (B ร C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Given three types ยง0, ยง1, and ยง2, the product type construction may be iterated to define types ยง3 and ยง4.\n"
"\n"
"A term ยง5 has projections ยง6 and ยง7. Then ยง8 has further projections ยง9 and ยง10.\n"
"\n"
"A term ยง11 has projections ยง12 and ยง13. Then ยง14 has further projections ยง15 and ยง16.\n"
"\n"
"Use this to define a *pair* of functions, the first of type ยง17 and the second of type ยง18. That is, define a single element of type\n"
"\n"
"ยง19\n"
"\n"
"These functions indicate that the product types ยง20 and ยง21 are closely related.\n"
"\n"
"By convention, the notation ยง22 is an abbreviation for the product type ยง23.\n"
"\n"
"Lean also provides a shorthand notation for elements of ยง24 that is not available for elements of ยง25.\n"
"\n"
"Given ยง26, ยง27, and ยง28, we may write ยง29 to abbreviate ยง30."
msgstr ""

#. ยง0: `ยซ{i}ยป`
#. ยง1: `ยซ{p}ยป`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What can we prove with the hypotheses ยง0 and ยง1?"
msgstr ""

#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Think about where the contradiction will ultimately arise from."
msgstr ""

#. ยง0: `g_is_surj`
#. ยง1: `ยซ{c}ยป`
#. ยง2: `have gc := g_is_surj ยซ{c}ยป`
#. ยง3: `let โจb, hbโฉ := g_is_surj c`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "To use the hypothesis ยง0 at ยง1 type ยง2 or ยง3."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "For the Boss Level of Empty World, we construct something that is just weird.\n"
"\n"
"Your challenge is to define functions in both directions between types that are formed by iteratively applying certain type forming operations to the empty type.\n"
"\n"
"Interestingly each of these types has an element, which can be used to define the functions if you wish.\n"
"\n"
"There are other strategies to defining the funtions as well, so you may enjoy trying to solve this level in multiple ways.\n"
"\n"
"Have fun!"
msgstr ""

#. ยง0: `x y : A`
#. ยง1: `x`
#. ยง2: `y`
#. ยง3: `p : x = y`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `p : P โ Q`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: `p : A โ B`
#. ยง12: `A โ B`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `A`
#. ยง16: `B`
#. ยง17: `f : A โ B`
#. ยง18: `g : B โ A`
#. ยง19: `ฮฑ : โ a : A, g (f a) = a`
#. ยง20: `ฮฒ : โ b : B, f (g b) = b`
#. ยง21: `P โ Q`
#. ยง22: `f : P โ Q`
#. ยง23: `g : Q โ P`
#. ยง24: `A`
#. ยง25: `B`
#. ยง26: `B`
#. ยง27: `A`
#. ยง28: `ฮฑ`
#. ยง29: `g โ f = id`
#. ยง30: `ฮฒ`
#. ยง31: `f โ g = id`
#. ยง32: `f`
#. ยง33: `g`
#. ยง34: `f`
#. ยง35: `g`
#. ยง36: `A`
#. ยง37: `B`
#. ยง38: `โจf, g, ฮฑ, ฮฒโฉ : A โ B`
#: Game.Levels.EquivalenceWorld
msgid "What does it mean for two things to be &ldquo;the same&rdquo;?\n"
"\n"
"The answer depends on what sort of things we are talking about.\n"
"\n"
"We have seen what it means for two elements of the same type to be the same. Given ยง0, we think of ยง1 and ยง2 as being &ldquo;the same&rdquo; if they are *equal*, meaning there is an element ยง3 in the equality type.\n"
"\n"
"We have also seen what it means for two propositions to be the same. Given propositions ยง4 and ยง5, we think of ยง6 and ยง7 as being &ldquo;the same&rdquo; if they are *logically equivalent*, meaning there is an element ยง8.\n"
"\n"
"What does it mean for two types to be &ldquo;the same&rdquo;?\n"
"\n"
"In this level, we will learn the answer: two types ยง9 and ยง10 are &ldquo;the same&rdquo; if they are *equivalent*. This means there is some element ยง11 in the type ยง12 of *equivalences* between ยง13 and ยง14 that we will introduce.\n"
"\n"
"To define an equivalence between ยง15 and ยง16 we need four pieces of data:\n"
"\n"
"* a function ยง17\n"
"* a function ยง18\n"
"* a proof ยง19\n"
"* a proof ยง20\n"
"\n"
"The first two pieces of data resemble the data required by a logical equivalence ยง21. For that one needs proofs ยง22 and ยง23 of the implications in each direction.\n"
"\n"
"The remaining data is relevant because functions carry more information than implications. In particular, there may be multiple functions from ยง24 to ยง25 and from ยง26 to ยง27.\n"
"\n"
"By function extensionality, the proof ยง28 witnesses the fact that ยง29 while the proof ยง30 witnesses the fact that ยง31. Together this tells us that the functions ยง32 and ยง33 are *inverses*.\n"
"\n"
"In other words, if ยง34 and ยง35 are thought of as operations that exchange elements of types ยง36 and ยง37, both operations can be undone by applying the other operation.\n"
"\n"
"The data ยง38 is sometimes also referred to as an *isomorphism* or a *bijection* but in Lean the term *equivalence* is more common."
msgstr ""

#. ยง0: `โ (x : A), P x`
#. ยง1: `use`
#. ยง2: `a : A`
#. ยง3: `P a`
#. ยง4: `โ (x y : A), P x y`
#. ยง5: `use a, a'`
#. ยง6: `use`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "For goals of the form ยง0 the tactic ยง1 can be used to provide an element ยง2 which will satisfy ยง3. For multiple constructors like ยง4, you can provide comma-separated values: ยง5.\n"
"\n"
"Note that the version of the ยง6 tactic for this game is somewhat weaker than the real one in Mathlib, which automatically tries to solve the remaining goal."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `a : A`
#. ยง3: `const a : B โ A`
#. ยง4: `x : B`
#. ยง5: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "For any types ยง0 and ยง1 and element ยง2, there is a constant function ยง3 that sends any ยง4 to the element ยง5."
msgstr ""

#. ยง0: `induction ยซ{n}ยป with k hk`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "To start a proof by induction in Lean, type ยง0. This will split the goal into two cases: proving the base case and the inductive step."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "Adding Successors"
msgstr ""

#. ยง0: `T โจ U โ V โง Y`
#. ยง1: `Q โ P โ T`
#. ยง2: `Y โ Q โ W`
#. ยง3: `(V โง W) โจ (X โง Y) โ Z`
#. ยง4: `(R โ S โ U) โง (V โ R โ X)`
#. ยง5: `P โง (Q โจ R) โง S`
#. ยง6: `Z`
#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "If ยง0 and ยง1 and ยง2 and\n"
"ยง3 and ยง4 then  ยง5 implies ยง6."
msgstr ""

#. ยง0: `And.symm`
#. ยง1: `exact And.symm`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? In fact, we gave a name ยง0 to the proof given in the previous level, as you can see in the list of theorems to the right. Try typing ยง1 at an appropriate place in your proof."
msgstr ""

#. ยง0: `A`
#. ยง1: `a : A`
#. ยง2: `a = a`
#. ยง3: `rfl : a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For a type ยง0 and element ยง1, the proposition ยง2 is true because there is a proof\n"
"ยง3 witnessing the reflexivity of equality."
msgstr ""

#. ยง0: `Function.curry : (A ร B โ C) โ (A โ B โ C)`
#. ยง1: `A โ B โ C`
#. ยง2: `A ร B โ C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"We'll now study the reverse process, which converts a function of type ยง1 to a function of type ยง2."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ g : B โ A, (โ a : A, g (f a) = a) โง (โ b : B, f (g b) = b)`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "A function ยง0 is *invertible* if ยง1."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `R โจ S`
#. ยง2: `P โง R`
#. ยง3: `P โง S`
#. ยง4: `Q โง R`
#. ยง5: `Q โง S`
#. ยง6: `P โจ Q`
#. ยง7: `R โจ S`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "A more involved form of distributivity is also true.\n"
"\n"
"If ยง0 holds and ยง1 holds then at least one of the following four propositions holds: ยง2 or ยง3 or ยง4 or ยง5.\n"
"\n"
"Conversely, if either of these four conjunctions holds, then ยง6 holds and ยง7 holds.\n"
"\n"
"Demonstrate the following logical equivalence."
msgstr ""

#. ยง0: `B โ A โ A โ B`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The same construction defines a function of type ยง0, demonstrating the symmetry of the coproduct."
msgstr ""

#: Game.Levels.ConjunctionWorld
msgid "Conjunction World"
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Look carefully at the order of the arguments of ยง0."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "In the next level, we will learn what it means for a function to be both injective and surjective."
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "From Empty"
msgstr ""

#. ยง0: `ยซ{i}ยป`
#. ยง1: `ยซ{nq}ยป`
#. ยง2: `have`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "What can you prove using ยง0 and ยง1? Use the tactic ยง2 to add this to your context."
msgstr ""

#. ยง0: `ยซ{P}ยป โ ยซ{P}ยป`
#. ยง1: `intro p`
#. ยง2: `p : ยซ{P}ยป`
#. ยง3: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "When the goal has the form ยง0, type ยง1 to introduce an assumption ยง2 and update the goal to ยง3."
msgstr ""

#. ยง0: `P : โ โ Prop`
#. ยง1: `P 0 โ (โ k : โ, P k โ P (succ k)) โ (โ n : โ, P n)`
#. ยง2: `โ n : โ, P n`
#. ยง3: `P 0`
#. ยง4: `โ k : โ, P k โ P (succ k)`
#. ยง5: `P : โ โ Type`
#. ยง6: `P 0 โ (โ k : โ, P k โ P (succ k)) โ (โ n : โ, P n)`
#. ยง7: `p_0 : P 0`
#. ยง8: `k : โ`
#. ยง9: `p_succ k : P k โ P (succ k)`
#. ยง10: `n : โ`
#. ยง11: `P n`
#. ยง12: `fun _ โฆ A : โ โ Type`
#. ยง13: `A`
#. ยง14: `A โ (โ โ A โ A) โ (โ โ A)`
#. ยง15: `f_0 : A`
#. ยง16: `f_succ : โ โ A โ A`
#. ยง17: `โ โ A`
#. ยง18: `f : โ โ A`
#. ยง19: `f 0 = f_0`
#. ยง20: `f (succ k) = f_succ k (f k)`
#. ยง21: `pred : โ โ โ`
#. ยง22: `pred 0 = 0`
#. ยง23: `pred (succ k) = k`
#. ยง24: `โ โ A`
#. ยง25: `fun n โฆ match n with | zero => ? | succ k => ?`
#. ยง26: `?`
#. ยง27: `A`
#. ยง28: `f_0 : A`
#. ยง29: `f_succ : โ โ A โ A`
#. ยง30: `fun n โฆ match n with | zero => f_0 | succ k => f_succ k (f k)`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Recall the principle of mathematical induction, which applies to an arbitrary family of propositions\n"
"ยง0 and asserts that\n"
"\n"
"ยง1\n"
"\n"
"That is, to prove ยง2 it suffices to verify:\n"
"* the base case ยง3 and\n"
"* the inductive step ยง4.\n"
"\n"
"The full elimination rule of the type of natural numbers is known in traditional foundations as the\n"
"*principle of mathematical recursion*. It applies to an arbitrary family of types ยง5 and defines an element of type\n"
"\n"
"ยง6\n"
"\n"
"The meaning is now slightly different as the arrows should be read as functions rather than implication.\n"
"\n"
"This says that:\n"
"\n"
"* given an element ยง7\n"
"* and a function that for all ยง8 defines a function ยง9\n"
"\n"
"then there is a function that for all ยง10 chooses an element of type ยง11.\n"
"\n"
"This is easiest to understand in the case of a constant type family ยง12 defined using a type ยง13.\n"
"\n"
"Now recursion defines a function of type ยง14. This says that:\n"
"\n"
"* given an element ยง15\n"
"* and a function ยง16\n"
"\n"
"then we may recursively define a function ยง17.\n"
"\n"
"We define the function ยง18 by specifying that\n"
"* ยง19 and\n"
"* ยง20.\n"
"Formally speaking, these equalities comprise the *computation rules* for the natural numbers type.\n"
"\n"
"In this level, your objective is to define a particular function ยง21 by recursion so that\n"
"* ยง22 and\n"
"* ยง23.\n"
"\n"
"In Lean, a function of type ยง24 can be defined recursively using the syntax ยง25 where each ยง26 is replaced by an appropriate element of ยง27.\n"
"\n"
"For example, using the data of ยง28 and ยง29, the corresponding recursively defined function is\n"
"\n"
"ยง30."
msgstr ""

#. ยง0: `n`
#. ยง1: `n + 0 = n`
#. ยง2: `0 + n = n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "For all natural numbers ยง0, ยง1 and ยง2."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `ยฌ Q โ ยฌ P`
#. ยง2: `ยฌ Q โ ยฌ P`
#. ยง3: `P โ Q`
#. ยง4: `ยฌ Q โ ยฌ P`
#. ยง5: `P โ Q`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "We have seen that the implication ยง0 implies the implication ยง1.\n"
"\n"
"The implication ยง2 is called the *contrapositive* of ยง3.\n"
"\n"
"In classical logic, these two statements are logically equivalent.\n"
"\n"
"That means, arguing classically, we can prove that ยง4 implies ยง5.\n"
"\n"
"Can you figure out how to prove this?"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#. ยง3: `x : A`
#. ยง4: `g (f x)`
#. ยง5: `Function.comp : (B โ C) โ (A โ B) โ (A โ C)`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions ยง0 and ยง1, the *composite function* ยง2 is defined to send ยง3 to the element ยง4. *Composition* itself defines a function ยง5 between function types."
msgstr ""

#. ยง0: `Classical.em P : P โจ ยฌ P`
#. ยง1: `em _`
#. ยง2: `_`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "The classical tautology ยง0 has been added to your library of theorems and can be referred to by the name ยง1, with the desired proposition replacing the ยง2, whenever classical reasoning is open."
msgstr ""

#. ยง0: `ยซ{c}ยป.1`
#. ยง1: `ยซ{c}ยป.2`
#. ยง2: `ยซ{c}ยป : P โง ยฌ P`
#. ยง3: `have := ยซ{c}ยป.1`
#. ยง4: `have := ยซ{c}ยป.2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that ยง0 and ยง1 are the notations used for components of a conjunction, like ยง2. You can use these names directly or introduce them as assumptions with ยง3 and ยง4."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `ยซ{n}ยป.succ`
#. ยง1: `succ ยซ{n}ยป`
#. ยง2: `ยซ{n}ยป`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Here you are asked to show that the value of the function you have just defined at ยง0, i.e., at ยง1, equals ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `(P โ Q) โง (Q โ P)`
#. ยง9: `P โ Q`
#. ยง10: `(P โ Q) โง (Q โ P)`
#. ยง11: `P โ Q`
#. ยง12: `P`
#. ยง13: `Q`
#. ยง14: `โ`
#. ยง15: `\\iff`
#. ยง16: `โ`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Two propositions ยง0 and ยง1 are *logically equivalent* if ยง2 implies ยง3 and ยง4 also implies ยง5.\n"
"\n"
"The assertion that ยง6 and ยง7 are logically equivalent can be expressed by the compound proposition ยง8.\n"
"\n"
"Because this notion will appear frequently in what follows, we introduce ยง9 as a useful shorthand for ยง10.\n"
"\n"
"The proposition ยง11 asserts that ยง12 is true *if and only if* ยง13 is true. In fact, the symbol ยง14 is typed using ยง15.\n"
"\n"
"See the library of definitions to the right for a reminder about what the symbol ยง16 means.\n"
"\n"
"The notion of logical equivalence enables us to upgrade our understanding of associativity of symmetry as follows."
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "Proving Implied Assumption"
msgstr ""

#. ยง0: `ev : A โ (A โ B) โ B`
#. ยง1: `fun a f โฆ f a`
#. ยง2: `(A โ B) โ A โ B`
#. ยง3: `fun f a โฆ f a`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "The evaluation function has type ยง0 and is defined by the formula ยง1. By swapping variables, we can also think of evaluation as defining a function ยง2 where this latter function is defined by ยง3."
msgstr ""

#. ยง0: `h : P โง Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `And.symm h`
#. ยง4: `Q โง P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Given a hypothesis ยง0 for some propositions ยง1 and ยง2, ยง3 is a proof of ยง4."
msgstr ""

#. ยง0: `y = y`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Note that the goal is now to prove ยง0. What tactic applies?"
msgstr ""

#. ยง0: `Empty.elim : Empty โ A`
#. ยง1: `exact Empty.elim`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Lean has a built-in name ยง0 for the function you have just defined. Thus ยง1 will also solve this level. This function has been added to the library."
msgstr ""

#. ยง0: `A ร B โ A`
#. ยง1: `A ร B โ B`
#. ยง2: `p : A ร B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `p : A ร B`
#. ยง6: `p.1 : A`
#. ยง7: `p.2 : B`
#. ยง8: `p.fst : A`
#. ยง9: `p.snd : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "The elimination rules for product types can be understood as defining *projection functions* of type ยง0 and ยง1 which take an element ยง2 and return the corresponding components from ยง3 and ยง4 respectively.\n"
"\n"
"In Lean, the elements defined by projecting from ยง5 are denoted ยง6 and ยง7 or ยง8 and ยง9.\n"
"\n"
"Your task in this level is to define the second projection function."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "Numerals"
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `(A โ C) ร (B โ C)`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "We will see later that functions of type ยง0 are uniquely determined by their component functions ยง1."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `โจa, bโฉ : A ร B`
#. ยง3: `a : A`
#. ยง4: `b : B`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "If ยง0 and ยง1 then the projections of ยง2 are definitionally equal to ยง3 and ยง4, respectively."
msgstr ""

#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Introducing Existence"
msgstr ""

#. ยง0: `Q`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "It is possible to prove any proposition ยง0 from the hypothesis that both ยง1 and ยง2 are true."
msgstr ""

#. ยง0: `P`
#. ยง1: `Classical.byContradiction : ยฌ ยฌ P โ P`
#. ยง2: `P`
#. ยง3: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "For any proposition ยง0, ยง1 proves that if ยง2 is not false, then ยง3 is true."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Have a look at the library of definitions for a function whose domain is the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Logical Equivalence"
msgstr ""

#. ยง0: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "The elements of the type ยง0 of types are types at the lowest universe level."
msgstr ""

#. ยง0: `m n`
#. ยง1: `m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "For all natural numbers ยง0, ยง1."
msgstr ""

#. ยง0: `Unit`
#. ยง1: `โจโฉ`
#. ยง2: `\\<`
#. ยง3: `\\>`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type ยง0 has a single canonical element ยง1, which may be typed using ยง2 and ยง3."
msgstr ""

#. ยง0: `ยซ{p}ยป`
#. ยง1: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "How can you use ยง0 and ยง1 to get a contradiction?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A ร B`
#. ยง3: `A`
#. ยง4: `A ร Empty`
#. ยง5: `A ร Empty`
#. ยง6: `A ร Empty`
#. ยง7: `Empty โ A ร Empty`
#. ยง8: `A ร Empty โ Empty`
#. ยง9: `A ร Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Recall that for any types ยง0 and ยง1, there is a *product type* denoted ยง2.\n"
"\n"
"In particular, for any type ยง3, we may form the product ยง4 with the empty type.\n"
"\n"
"Elements of product types are pairs of elements, one from the first type and one from the second type.\n"
"\n"
"But the empty type does not have any elements! So this means the product ยง5 cannot have any elements either.\n"
"\n"
"More precisely, the type ยง6 is *equivalent* to the empty type in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions ยง7 and ยง8, which as discussed in a previous level, indicates that ยง9 cannot have any elements either.\n"
"\n"
"Your task in this level is to define these functions."
msgstr ""

#. ยง0: `(P โ Q) โ R`
#. ยง1: `P โ (Q โ R)`
#. ยง2: `P โ Q โ R`
#. ยง3: `P โ (Q โ R)`
#. ยง4: `P โ (Q โ R)`
#. ยง5: `P โง Q โ R`
#. ยง6: `(P โง Q) โ R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Recall that implication is *NOT* associative: the propositions ยง0 and ยง1 are not logically equivalent.\n"
"\n"
"The shorthand ยง2 is an abbreviation for ยง3.\n"
"\n"
"One reason that mathematical statements of the form ยง4 are more prevalent is that this is implied by ยง5, which is implicitly parenthesized as ยง6.\n"
"\n"
"Your task in this level is to prove this implication."
msgstr ""

#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "In the next level, we will prove that the empty type is also a proposition."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `f a : B`
#. ยง3: `f`
#. ยง4: `a`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Given a function ยง0 and an element ยง1, there is an element ยง2 obtained by evaluating the function ยง3 at ยง4."
msgstr ""

#. ยง0: `false = true`
#. ยง1: `ยฌ (false = true) := Bool.noConfusion`
#. ยง2: `ยฌ (true = false) := Bool.noConfusion`
#. ยง3: `false = true`
#. ยง4: `exfalso`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This case is considerably more difficult than the previous one because your goal is to prove that ยง0. But you may recall from Boolean world that we can prove ยง1 and ยง2. This suggests that the only way we will be able to prove ยง3 is by finding a contradition among our hypothesis. To set up this proof strategy, use the tactic ยง4."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Recursion"
msgstr ""

#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Universal property"
msgstr ""

#. ยง0: `Type`
#. ยง1: `Type u`
#. ยง2: `u`
#. ยง3: `Type`
#. ยง4: `Type 0`
#. ยง5: `Type`
#. ยง6: `exact Type`
#. ยง7: `Type`
#. ยง8: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "Lean also has a built in type of types denoted ยง0, which can be found in your library of definitions.\n"
"\n"
"More precisely &mdash; to avoid a contradiction known as *Russell's paradox* &mdash; Lean has a hierarchy of built in types of types denoted ยง1 parametrized by *universe levels* ยง2.\n"
"\n"
"Here ยง3 is a synonym for ยง4, which is the type of types at the smallest universe level.\n"
"\n"
"The goal in this level is to define an element of the type ยง5 of types.\n"
"\n"
"Note ยง6 will not work, because the type ยง7 belongs to the type of types in a larger universe. Try this and see what happens.\n"
"\n"
"However, we have introduced a type that is small enough to define an element of ยง8. Use this to solve this level."
msgstr ""

#. ยง0: `B ร D โ M`
#. ยง1: `E โ Y ร N`
#. ยง2: `A โ M โ X`
#. ยง3: `C โ N โ Z`
#. ยง4: `A ร B ร C ร D ร E`
#. ยง5: `X ร Y ร Z`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Given functions of types ยง0, ยง1, ยง2, and ยง3, there is a function from the product type ยง4 to the product type ยง5."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `x : A`
#. ยง3: `y z : B`
#. ยง4: `B`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "Under the hypothesis that we have types ยง0 and ยง1 and elements ยง2 and ยง3, we may define an element of type ยง4."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Normal Forms"
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "Now we are ready for the Boss Level."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Prod.snd : A ร B โ B`
#. ยง3: `p : A ร B`
#. ยง4: `p.2 : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "For any types ยง0 and ยง1, ยง2 is the function that sends ยง3 to its second coordinate ยง4."
msgstr ""

#. ยง0: `Empty`
#. ยง1: `x y : Empty`
#. ยง2: `x = y`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Recall from Empty World, that Lean has a built in empty type ยง0 which has no elements.\n"
"\n"
"The empty type is also a proposition: if ยง1, then ยง2. Can you prove this?"
msgstr ""

#. ยง0: `a : A`
#. ยง1: `f : A โ B`
#. ยง2: `f a : B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "Define the *evaluation* function that takes ยง0 and ยง1 to ยง2."
msgstr ""

#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "Negating Universality"
msgstr ""

#. ยง0: `assumption`
#. ยง1: `P`
#. ยง2: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "Type ยง0 to tell Lean to use the assumption that ยง1 is true to conclude that ยง2 is true."
msgstr ""

#. ยง0: `P`
#. ยง1: `R โ S โง T`
#. ยง2: `U โ P โ R`
#. ยง3: `(U โ Y) โ Z`
#. ยง4: `W โง T โง V โ X โง Y`
#. ยง5: `S โ V โง W`
#. ยง6: `Z`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "If ยง0, ยง1, ยง2, ยง3, ยง4, and ยง5 are true, then ยง6 is true."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `f`
#. ยง2: `g : B โ A`
#. ยง3: `f`
#. ยง4: `f`
#. ยง5: `โ g : B โ A, (โ a : A, g (f a) = a) โง (โ b : B, f (g b) = b)`
#. ยง6: `f`
#. ยง7: `g`
#. ยง8: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "Consider a function ยง0.\n"
"\n"
"We say that ยง1 is *invertible* if there exists a function ยง2 that &ldquo;un-does&rdquo; the action of ยง3 on both pre- and post-composition.\n"
"\n"
"More formally, ยง4 is invertible if\n"
"\n"
"ยง5.\n"
"\n"
"When ยง6 is invertible, the function ยง7 is called its *inverse*.\n"
"\n"
"As a first example, prove that the function ยง8 is invertible."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `ยฌ ยฌ ยฌ P โ ยฌ P`
#. ยง4: `P`
#. ยง5: `ยฌ P`
#. ยง6: `ยฌ ยฌ ยฌ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "This level contains another tautology whose proof you have seen before.\n"
"\n"
"We will show that for any proposition ยง0, if ยง1 is not not false, then ยง2 is false.\n"
"\n"
"That is, we will prove ยง3.\n"
"\n"
"In fact, for any proposition ยง4, its negation ยง5 and its triple negation ยง6 are logically equivalent.\n"
"\n"
"So we will prove this too."
msgstr ""

#. ยง0: `have lemP : P โจ ยฌ P := em P`
#. ยง1: `have lemP := em P`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Type ยง0 or ยง1 to appeal to the law of excluded middle for ยง2. Alternatively, you can appeal to the law of excluded middle for ยง3 or for any other proposition."
msgstr ""

#. ยง0: `P true โ P false`
#. ยง1: `let tr : P true โ P false := by intro x ; rw [p] ; exact x
#. `
#. ยง2: `let tr : P true โ P false := by`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Define a function ยง0 by ยง1. In editor mode, start with ยง2 then continue with each of the three tactics on three subsequent lines. This way you can see how the goal evolves with each step in the construction."
msgstr ""

#. ยง0: `f`
#. ยง1: `f`
#. ยง2: `f`
#. ยง3: `f`
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "In the proof that ยง0 is injective, you used only one half of the invertibility condition. Can you use this observation to state a theorem that proves that ยง1 is injective under a weaker hypothesis? Similarly, in the proof that ยง2 is surjective, you used only the other half of the invertibility condition. Can you use this observation to state a theorem that proves that ยง3 is surjective under a weaker hypothesis?"
msgstr ""

#. ยง0: `f : X โ A ร B`
#. ยง1: `fun x โฆ (f x).1 : X โ A`
#. ยง2: `fun x โฆ (f x).2 : X โ B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that functions ยง0 into product types can be decomposed into component functions ยง1 and ยง2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions."
msgstr ""

#. ยง0: `apply`
#. ยง1: `Q`
#. ยง2: `h : P โ Q`
#. ยง3: `apply h`
#. ยง4: `P`
#. ยง5: `T`
#. ยง6: `e : R โ S โ T`
#. ยง7: `apply e`
#. ยง8: `R`
#. ยง9: `S`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "The ยง0 tactic can be used when the goal matches the conclusion of an implication or the output type of a function. For example if the goal is ยง1 and there is a hypothesis ยง2, then ยง3 updates the goal to ยง4. If the goal is ยง5 and there is a hypothesis ยง6, then ยง7 produces two subgoals, one each for ยง8 and ยง9."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `x y : A`
#. ยง2: `p : x = y`
#. ยง3: `congrArg f p : f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "For a function ยง0 between types, elements ยง1, and a proof ยง2, then ยง3. This theorem has been added to the library."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A ร B) ร C`
#. ยง4: `A ร (B ร C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Product types are associative: for types ยง0, ยง1, and ยง2, there are canonical functions in each direction between the types ยง3 and ยง4."
msgstr ""

#. ยง0: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "Now the goal is to prove ยง0 using *any* of our given hypotheses. Which tactic can be used to supply this proof?"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ x : A, P x`
#. ยง2: `P a`
#. ยง3: `a : A`
#. ยง4: `h : โ x : A, P x`
#. ยง5: `a : A`
#. ยง6: `h a`
#. ยง7: `P a`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "For a family of propositions ยง0, ยง1 is the proposition that asserts that ยง2 is true for\n"
"every element ยง3. Elements ยง4 can be thought of as *dependent functions* that carry an arbitrary element ยง5 to a proof ยง6 of the proposition ยง7."
msgstr ""

#. ยง0: `P โ ยฌ ยฌ P`
#. ยง1: `(P โ Q) โ (ยฌ Q โ ยฌ P)`
#. ยง2: `ยฌ P โจ ยฌ Q โ ยฌ (P โง Q)`
#. ยง3: `(P โง ยฌ Q) โ ยฌ (P โ Q)`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โจ Q`
#. ยง7: `P`
#. ยง8: `Q`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: `A โ (A โ Empty) โ Empty`
#. ยง12: `(A โ B) โ (B โ Empty) โ (A โ Empty)`
#. ยง13: `(A โ Empty) โ (B โ Empty) โ (A ร B โ Empty)`
#. ยง14: `A ร (B โ Empty) โ (A โ B) โ Empty`
#. ยง15: `P`
#. ยง16: `P โจ ยฌ P`
#. ยง17: `P โจ ยฌ P`
#. ยง18: `P`
#. ยง19: `P`
#. ยง20: `P`
#. ยง21: `ยฌ ยฌ P โ P`
#. ยง22: `P`
#. ยง23: `ยฌ ยฌ P โ P`
#. ยง24: `P`
#. ยง25: `ยฌ P`
#. ยง26: `ยฌ P`
#. ยง27: `ยฌ ยฌ P`
#. ยง28: `ยฌ ยฌ P โ P`
#. ยง29: `ยฌ ยฌ P`
#. ยง30: `P`
#: Game.Levels.ClassicalWorld
msgid "In Negation World, we proved various tautologies involving negation such as\n"
"\n"
"* ยง0\n"
"* ยง1\n"
"* ยง2\n"
"* ยง3\n"
"\n"
"for arbitrary propositions ยง4 and ยง5.\n"
"\n"
"But we were not able to prove the converses of any of these implications. Why not?\n"
"\n"
"The reason is that all of the proofs we have given thusfar involve explicit constructive arguments. For example, whenever we proved that a disjunction ยง6 held under certain hypotheses, our proof gave the information of *which* of the propositions ยง7 and ยง8 is true.\n"
"\n"
"One way to identify a constructive proof of implication is to think about whether there is a corresponding function between types. For arbitrary types ยง9 and ยง10 it is possible to define functions of type\n"
"\n"
"* ยง11\n"
"* ยง12\n"
"* ยง13\n"
"* ยง14\n"
"\n"
"using analogous constructions to the proofs of the constructive implications.\n"
"\n"
"In this world, we study *classical mathematics*, which assumes two additional axioms, each of which permits new proof techniques.\n"
"\n"
"The first axiom, called the *law of excluded middle*, asserts that for any proposition ยง15, ยง16 is true.\n"
"\n"
"This permits the strategy of proof by cases. Under the assumption that ยง17 is true, you can split the argument into two cases, one assuming ยง18 is true and the other assuming ยง19 is false.\n"
"\n"
"The other axiom, called *double negation elimination*, asserts that for any proposition ยง20, ยง21 is true.\n"
"\n"
"This permits a proof strategy called *proof by contradiction*. If the goal is to prove ยง22 we can use the assumption ยง23 to reason as follows:\n"
"\n"
"* First assume that ยง24 is false, so ยง25 is true.\n"
"* Then use the assumption ยง26 to derive a contradiction, thus constructing a proof of ยง27.\n"
"* Finally, apply the implication ยง28 to convert the proof of ยง29 into a proof of ยง30.\n"
"\n"
"In fact, as statements concerning arbitrary propositions, the law of exluded middle and double negation elimination are equivalent &mdash; even constructively &mdash; as we will show in the Boss Level of this world."
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "The goal is a function type. What tactic can be used to define an element?"
msgstr ""

#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "Disjunction Symmetry"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `x y : A`
#. ยง2: `x = y`
#. ยง3: `f x = f y`
#. ยง4: `f : A โ B`
#. ยง5: `a : A`
#. ยง6: `b : B`
#. ยง7: `f a`
#. ยง8: `b`
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "Recall from Equality World that a function ยง0 must be *well-defined*.\n"
"\n"
"That is if ยง1 and ยง2, then ยง3.\n"
"\n"
"In this level, we will state and prove a second defining property of functions.\n"
"\n"
"A function ยง4 must necessarily be &ldquo;total&rdquo;, rather than &ldquo;partially-defined&rdquo;.\n"
"\n"
"To say a function is *total* means that for each ยง5 there is some ยง6 so that ยง7 equals ยง8.\n"
"\n"
"Your task this level is to prove this."
msgstr ""

#. ยง0: `(P โง R) โจ ((P โง S) โจ ((Q โง R) โจ (Q โง S)))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "The implicit parentheses in the goal are to the right ยง0."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `f a`
#. ยง3: `exact f a`
#. ยง4: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The syntax for the application of the function ยง0 to an element ยง1 is just ยง2. So to solve this level, type ยง3 to obtain an element of type ยง4."
msgstr ""

#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "Disjunction"
msgstr ""

#. ยง0: `Retry`
#. ยง1: `exact x`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "After solving this level, use the ยง0 button to solve it again. What happens if you try ยง1?"
msgstr ""

#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "Type of Propositions"
msgstr ""

#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Which function might be useful to apply here?"
msgstr ""

#. ยง0: `ยซ{pnq}ยป`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What can we prove with the hypothesis ยง0?"
msgstr ""

#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Coproduct Symmetry"
msgstr ""

#. ยง0: `P : Bool โ Prop`
#. ยง1: `tr : P true โ P false`
#. ยง2: `tr : True โ False`
#. ยง3: `tr`
#. ยง4: `True`
#. ยง5: `False`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "By the definition of the family of propositions ยง0, the function ยง1 is a function ยง2. In particular, if we apply ยง3 to an element of ยง4, we get an element of ยง5, which is what we want."
msgstr ""

#. ยง0: `ยซ{andn}ยป`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What proofs can you extract from the hypothesis ยง0?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `f : A โ B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `A ร B`
#. ยง9: `p : A ร B`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `A ร B`
#. ยง13: `A ร B`
#: Game.Levels.ProductWorld
msgid "In Function World, we learned that for any types ยง0 and ยง1 there is a new type ยง2 whose elements ยง3 are *functions* from ยง4 to ยง5.\n"
"\n"
"In this world, we'll meet another binary type forming operation.\n"
"\n"
"Given two types ยง6 and ยง7, there is a type ยง8 called the *product type* whose elements ยง9 should be thought of as encoding ordered pairs of elements, one from ยง10 and one from ยง11.\n"
"\n"
"To understand how products work in type theory we must learn:\n"
"\n"
"* How to construct elements of type ยง12.\n"
"* How to use elements of type ยง13 to construct elements of other types.\n"
"\n"
"Like all type forming operations, the product type is characterized by these introduction and elimination rules."
msgstr ""

#. ยง0: `Type`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type can be found in the library of definitions in the folder ยง0."
msgstr ""

#: Game.Levels.TypeWorld.L02_Proofs
msgid "Proofs"
msgstr ""

#. ยง0: `pred : โ โ โ`
#. ยง1: `0`
#. ยง2: `0`
#. ยง3: `succ n`
#. ยง4: `n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "There is a function ยง0 that sends ยง1 to ยง2 and ยง3 to ยง4."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `a = a`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "For all ยง0, ยง1 holds."
msgstr ""

#. ยง0: `swap`
#. ยง1: `f : A โ B โ C`
#. ยง2: `swap f : B โ A โ C`
#. ยง3: `b : B`
#. ยง4: `a : A`
#. ยง5: `f a b : C`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "The ยง0 function exchanges the inputs of a function of two variables. For a function with two variables ยง1, ยง2 is the function that sends ยง3 and ยง4 to ยง5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "In the next level, we will practice using function extensionality to demonstrate an equality between functions."
msgstr ""

#. ยง0: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Now that you are stuck, it is a good time to try classical reasoning. Try ยง0 and see how this transforms the goal."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `ยฌ (โ x : A, P x)`
#. ยง2: `โ x : A, ยฌ (P x)`
#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "Given a family of propositions ยง0, using classical logic, ยง1 implies ยง2."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "A bijective function is invertible."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "For any proposition ยง0, ยง1 implies ยง2 is true."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "If this is not the term you want, how can you use it to define the correct term?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "Using our newly understood notion of bijective function, or invertible function, or isomorphism, we can now study what it means for a pair of types to be *equivalent*. Move on to Equivalence World next."
msgstr ""

#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Contrapositive"
msgstr ""

#. ยง0: `ยฌ (P โจ Q)`
#. ยง1: `P โจ Q`
#. ยง2: `P โจ Q`
#. ยง3: `P`
#. ยง4: `P โจ Q`
#. ยง5: `Q`
#. ยง6: `P โจ Q`
#. ยง7: `P โจ Q`
#. ยง8: `P`
#. ยง9: `Q`
#. ยง10: `ยฌ (P โจ Q)`
#. ยง11: `ยฌ P โง ยฌ Q`
#. ยง12: `โ`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"Recall, if ยง3 is true, then we can prove ยง4. Similarly, if ยง5 is true, we can prove ยง6.\n"
"\n"
"So if ยง7 is false, then both ยง8 and ยง9 must be false.\n"
"\n"
"In this level, we will show that ยง10 is logically equivalent to ยง11.\n"
"\n"
"If you have forgotten the meaning of logical equivalence, denoted ยง12, you can look it up in the library."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ x y : A, x = y โ f x = f y`
#. ยง2: `f : A โ B`
#. ยง3: `x y : A`
#. ยง4: `f x = f y`
#. ยง5: `x = y`
#. ยง6: `f`
#. ยง7: `B`
#. ยง8: `A`
#. ยง9: `โ x y : A, f x = f y โ x = y`
#. ยง10: `f`
#. ยง11: `not : Bool โ Bool`
#. ยง12: `b : Bool`
#. ยง13: `! b`
#. ยง14: `not b`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Recall that every function is *well-defined*. For any function ยง0, we have proven that ยง1.\n"
"\n"
"A function ยง2 is *injective* if for every ยง3, ยง4 implies ยง5.\n"
"\n"
"This condition says that any output element of ยง6 has a unique corresponding input. Note it is not necessary that any element of ยง7 is an output of an injective function. Instead, injectivity asserts that if two elements of ยง8 have the same output, then those elements must be equal.\n"
"\n"
"Unlike well-definedness, the statement ยง9 is true for some functions ยง10 but false for others.\n"
"\n"
"In this level, we will show that the function ยง11 is injective.\n"
"\n"
"Recall that when ยง12, Lean writes ยง13 for ยง14."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `a : A`
#. ยง4: `A โ B`
#. ยง5: `Sum.inl : A โ A โ B`
#. ยง6: `A โ B`
#. ยง7: `apply Sum.inl`
#. ยง8: `A`
#. ยง9: `left`
#. ยง10: `A โ B`
#. ยง11: `left`
#. ยง12: `A`
#. ยง13: `A โ B`
#. ยง14: `Sum.inl : A โ A โ B`
#. ยง15: `left`
#. ยง16: `A`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "For types ยง0 and ยง1, the coproduct type ยง2 has two kinds of elements. The first kind can be thought of as copies of elements ยง3 included into the coproduct ยง4 *on the left*.\n"
"\n"
"Lean has a built in function called ยง5, which can now be found in your library.\n"
"\n"
"If the goal is to produce an element of ยง6, typing ยง7 will convert this to a goal of producing an element of ยง8.\n"
"\n"
"The tactic ยง9 has the same effect. When the goal is a coproduct type ยง10, using the tactic ยง11 tells Lean that you plan to provide an element of type ยง12, which should then be converted to an element of type ยง13 by applying the function ยง14. Thus, typing ยง15 will update the goal to type ยง16."
msgstr ""

#. ยง0: `ยซ{p}ยป : A โ B`
#. ยง1: `rfl`
#. ยง2: `ยซ{p}ยป`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "The functions you have just defined are not definitionally inverses on all elements ยง0. This is why ยง1 fails. Try splitting ยง2 into cases first."
msgstr ""

#. ยง0: `Prod.snd : A ร B โ B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Lean uses the name ยง0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"In the next level, we'll use the projection functions to prove symmetry of product types."
msgstr ""

#. ยง0: `ยฌ P โจ ยฌ Q`
#. ยง1: `ยฌ (P โง Q)`
#. ยง2: `ยฌ (P โง Q)`
#. ยง3: `ยฌ P โจ ยฌ Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โจ ยฌ P`
#. ยง7: `have := em P`
#. ยง8: `P โจ ยฌ P`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "We have seen that ยง0 implies ยง1.\n"
"\n"
"But we were not able to prove constructively that ยง2 implies ยง3, since we cannot tell whether ยง4 or ยง5 is the false proposition.\n"
"\n"
"However, we can prove this using classical logic.\n"
"\n"
"Recall that in classical logic, we may assume the *law of excluded middle*, i.e., that ยง6 is true for any proposition.\n"
"\n"
"In particular, in the middle of your proof, you can type ยง7 to introduce ยง8 as a hypothesis.\n"
"\n"
"Can you use this to prove the desired implication?"
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What is the logical form of the goal?"
msgstr ""

#. ยง0: `rw`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "We will now explore other applications of the tactic ยง0."
msgstr ""

#. ยง0: `x : Bool`
#. ยง1: `not x = ยซ{b}ยป`
#. ยง2: `ยซ{b}ยป`
#. ยง3: `cases ยซ{b}ยป`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Now you must give an explicit element ยง0, so that ยง1. To do this, you need to know which boolean ยง2 is! Use ยง3 for this."
msgstr ""

#. ยง0: `f : A ร B โ C`
#. ยง1: `Function.curry f : A โ B โ C`
#. ยง2: `f : X โ A ร B`
#. ยง3: `X`
#. ยง4: `A ร B`
#. ยง5: `X โ A`
#. ยง6: `X โ B`
#. ยง7: `x : X`
#. ยง8: `(f x).1 : A`
#. ยง9: `(f x).2 : B`
#. ยง10: `f x : A ร B`
#. ยง11: `f : X โ A ร B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that a function ยง0 out of a product can be regarded as a function of two variables ยง1.\n"
"\n"
"How should we think about a function into a product?\n"
"\n"
"Consider a function ยง2 from a type ยง3 into a product type ยง4.\n"
"\n"
"From this data, one can define a pair of functions with types ยง5 and ยง6 that map an element ยง7 to the values ยง8 and ยง9 defined by projecting the pair ยง10 to its components.\n"
"\n"
"These functions are called the *component functions* associated to ยง11.\n"
"\n"
"Your task in this level is to define a function that extracts the component functions associated to a function into a product type."
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `(P โง Q) โจ (P โง R)`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Conjunction distributes over disjunction: ยง0 and ยง1 are logically equivalent."
msgstr ""

#. ยง0: `โ`
#. ยง1: `Bool`
#. ยง2: `17 : โ`
#. ยง3: `true : Bool`
#: Game
msgid "Mathematicians from all over &mdash; most of whom have never met one another &mdash; nevertheless agree to an incredible extent about the nature of the mathematical universe. How did this degree of consensus come about?\n"
"\n"
"Firstly mathematicians have developed a precise formal language which allows them to define new abstract concepts and state their properties in an unambiguous way. A mathematical *proposition* is a well-formed mathematical statement that is either true or false, for instance:\n"
"\n"
"* &ldquo;There are infinitely many prime numbers.&rdquo;\n"
"* &ldquo;Every prime number is odd.&rdquo;\n"
"* &ldquo;There are infinitely many prime numbers that are two less than another prime.&rdquo;\n"
"\n"
"Mathematicians distinguish between the true propositions, the false ones, and the ones whose truth value is not yet known through *proofs* made precise in the formal language of mathematical logic.\n"
"\n"
"While the idea of a mathematical proof is over 2000 years old, the practice of proof writing continues to evolve. Today mathematicians may elect to use a tool called a computer proof assistant that can provide real-time feedback to a theorem prover about the status of a logical argument that is currently under development.\n"
"\n"
"The aim of this game will be to introduce proof writing in a computer proof assistant while developing skils that can be used to develop proofs in other contexts: on paper, in conversation with a friend, or in your head.\n"
"\n"
"There is one caveat to this introduction to proof writing, which we now address explicitly. The formal vocabulary we will introduce to discuss mathematical proofs is somewhat different from the one that most mathematicians learn. The mathematics we will be developing is essentially unchanged but the formal language introduced here will make it easier to be fully precise about every step in a proof, as is required to convince a computer that a logical argument in sound.\n"
"\n"
"In particular, we will explore an analogy between mathematical *propositions* and another form of primitive mathematical structure called *types*. Examples of types include:\n"
"\n"
"* The type ยง0 of natural numbers.\n"
"* The type ยง1 of booleans.\n"
"\n"
"Each type comes with its *elements* such as ยง2 or ยง3 governed by rules which explain the requirements for constructing an element and how previously-constructed elements can be used. We will see that these rules closely parallel the logical rules which dictate the requirements for proving a proposition and explain how a previously-proven proposition can be used to prove other theorems.\n"
"\n"
"This formal vocabulary for mathematics is called *dependent type theory*, with the adjective &ldquo;dependent&rdquo; referring to the fact that all of the rules just mentioned apply in any *context* of previously-constructed elements of types and previously-proven propositions.\n"
"\n"
"In Type World, we will introduce types and their elements and propositions and their proofs. We will explore these notions interactively with the computer proof assistant Lean.\n"
"\n"
"Later worlds will reveal that more complicated types can be built from simpler types, like more complicated mathematical statements can be built from simpler propositions.\n"
"\n"
"Let's begin!"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Sum.swap : A โ B โ B โ A`
#. ยง3: `Sum.inl a`
#. ยง4: `Sum.inr a`
#. ยง5: `Sum.inr b`
#. ยง6: `Sum.inl b`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For types ยง0 and ยง1, the function ยง2 is defined to send elements of the form ยง3 to ยง4 and elements of the form ยง5 to ยง6."
msgstr ""

#. ยง0: `left`
#. ยง1: `right`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Use the tactic ยง0 to indicate that you'd like to prove the left-hand statement or ยง1 to indicate that you'd like to prove the right-hand statement."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `f : A โ B`
#. ยง3: `a : A`
#. ยง4: `B`
#. ยง5: `apply`
#. ยง6: `f : A โ B`
#. ยง7: `B`
#. ยง8: `apply f`
#. ยง9: `A`
#. ยง10: `f`
#. ยง11: `apply`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "The context and goal for this level is identical to the previous level. We are given types ยง0 and ยง1, a function ยง2 and an element ยง3. The goal is to define an element of type ยง4.\n"
"\n"
"Lean has another tactic called ยง5, which can be used in the presence of a function to transform the goal. If ยง6 is part of the context and the goal is to define an element of type ยง7 then ยง8 will update the goal to ask instead for an element of type ยง9.\n"
"\n"
"This proof strategy asks Lean to solve the initial goal by applying the function ยง10 to the element you provide next.\n"
"\n"
"Try using the ยง11 tactic to solve this level."
msgstr ""

#. ยง0: `let`
#. ยง1: `p : A ร B ร C ร D ร E`
#. ยง2: `let โจa, b, c, d, eโฉ := p`
#. ยง3: `a : A`
#. ยง4: `b : B`
#. ยง5: `c : C`
#. ยง6: `d : D`
#. ยง7: `e : E`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The ยง0 tactic can also be used to decompose an element of a product type into its components. For example, using an element ยง1, typing ยง2 will add elements ยง3, ยง4, ยง5, ยง6, and ยง7 to your context.\n"
"\n"
"Move on to Conjunction World to learn about the logical operation that is analogous to product types."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โง Q`
#. ยง3: `P โง ยฌ Q`
#. ยง4: `ยฌ P โง Q`
#. ยง5: `ยฌ P and ยฌ Q`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "In classical logic, for any propositions ยง0 and ยง1, ยง2 is true or ยง3 is true or ยง4 is true or ยง5 is true."
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "In the next level, we will introduce another tactic that can be used to solve this goal."
msgstr ""

#. ยง0: `Prod.swap`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Lean calls the function you have just defined ยง0. It is now part of your library of definitions. Are function types symmetric? Why or why not?"
msgstr ""

#. ยง0: `P`
#. ยง1: `P โจ ยฌ P`
#. ยง2: `ยฌ ยฌ P โ P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The law of excluded middle implies double negation elimination: for any proposition ยง0, ยง1 implies ยง2."
msgstr ""

#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Reflexivity"
msgstr ""

#: Game.Levels.FunctionWorld
msgid "Function World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Can we apply our hypothesis now?"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L09_Evaluation
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "When in doubt, start defining a function by using the tactic ยง0 followed by your preferred variable name."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Next move on to Disjunction World to study the logical operation that is analogous to coproduct types."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Compound Implication"
msgstr ""

#. ยง0: `ext x`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Type ยง0 to apply function extensionality and see how the goal state transforms."
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "Introducing Or"
msgstr ""

#. ยง0: `ยซ{nnnp}ยป`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What can you do with hypothesis ยง0?"
msgstr ""

#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Identity Function"
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "As the goal is to prove an implication, the tactic ยง0 can be used to introduce a hypothesis and update the goal. Before using this tactic, try to figure out which hypothesis will be assumed and what the goal will be, using the discussion about the implicit parenthesization above."
msgstr ""

#. ยง0: `โจ`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P โจ Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P โจ Q`
#. ยง7: `P โจ Q`
#. ยง8: `P โจ Q`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `P`
#. ยง12: `Q`
#. ยง13: `P โจ Q`
#. ยง14: `P โจ Q`
#. ยง15: `P`
#. ยง16: `Q`
#. ยง17: `h : P โจ Q`
#. ยง18: `h : P โจ Q`
#: Game.Levels.DisjunctionWorld
msgid "The logical connective of *disjunction*, denoted by ยง0, is the mathematical version of *or*.\n"
"\n"
"For arbitrary propositions ยง1 and ยง2, ยง3 is a new proposition asserting that at least one of ยง4 *or* ยง5 *are true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form ยง6.\n"
"* How to use a hypothesis of the form ยง7 to prove something else.\n"
"\n"
"There are two strategies to prove ยง8. It suffices to supply a proof of ยง9 and it also suffices to supply a proof of ยง10.\n"
"\n"
"Note that the mathematical &ldquo;or&rdquo; is *inclusive*, meaning that if ยง11 and ยง12 are both true, then ยง13 is true.\n"
"\n"
"Together these strategies define the two introduction rules for disjunctions. Note that a proof that employs either of these strategies carries extra information. In addition to concluding that ยง14 is true, a proof using the first strategy will prove along the way that ยง15 is true (perhaps subject to certain hypotheses) while a proof using the second strategy will prove along the way that ยง16 is true (perhaps subject to other hypotheses).\n"
"\n"
"Similarly, the construction of an element of a coproduct type via either of the introduction rules will carry the information of whether the element comes from the left-hand type or the right-hand type.\n"
"\n"
"The elimination rule for disjunctions explains how to use a hypothesis ยง17 to prove something else.\n"
"\n"
"Using a hypothesis ยง18 leads to a proof strategy of arguing &ldquo;by cases&rdquo; as we will soon discover.\n"
"\n"
"Like the analogy between function types and implication, and product types and conjunction, there is a close analogy between coproduct types and the logical operation of disjunction.\n"
"\n"
"In particular, we will use similar notations and the same tactics introduced in Coproduct World."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does this goal seem familiar? If not, it's okay to just follow your nose and let the logical structure guide you."
msgstr ""

#. ยง0: `Retry`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "You can click on ยง0 to attempt a different proof."
msgstr ""

#. ยง0: `ยซ{hk}ยป`
#. ยง1: `0 + ยซ{k}ยป`
#. ยง2: `ยซ{k}ยป`
#. ยง3: `0 + succ ยซ{k}ยป`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "It would be nice if we could use the hypothesis ยง0 to replace the ยง1 in the goal with the element ยง2, but the parentheses in the left-hand side of the goal equation are not a match for this. Lean thinks that the left hand side is of the form ยง3. Do we have any theorems that can be used to rewrite this into something else?"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ x y : A, x = y โ f x = f y`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "A function ยง0 is *injective* if ยง1."
msgstr ""

#. ยง0: `(p || !q || r) && (q || !r) && (!p || r)`
#. ยง1: `p q r : Bool`
#. ยง2: `(!p || q) && (!q || p) && (!p || !r) && (!q || !r) && (p || q)`
#. ยง3: `p q r`
#. ยง4: `true`
#. ยง5: `p`
#. ยง6: `q`
#. ยง7: `r`
#. ยง8: `exact p`
#. ยง9: `exact q`
#. ยง10: `exact r`
#. ยง11: `true`
#. ยง12: `false`
#. ยง13: `rfl`
#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "An expression involving booleans is in *conjuctive normal form* if it expressed as a conjunction (possibly involving many formulas) of disjunctions (possibly involving many formulas) of either booleans or their negations.\n"
"\n"
"Using Lean's alternate notation for conjunction, disjunction, and negation, conjunctive normal form statements look like\n"
"\n"
"ยง0\n"
"\n"
"For the Boss Level, you are asked to find booleans ยง1 so that\n"
"\n"
"ยง2\n"
"\n"
"is satisfiable, meaning that the after substituting appropriate elements for ยง3, this conjunctive normal form formula is equal to ยง4.\n"
"\n"
"You can see this expression in the fourth goal, with ยง5, ยง6, and ยง7 standing in for the yet-to-be-determined boolean variables.\n"
"\n"
"Solve the first three goals by ยง8, ยง9, and ยง10 &mdash; replacing the boolean variables by explicit booleans ยง11 or ยง12 as appropriate. If you have found the right solution, the final goal should be solvable with ยง13."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ A`
#. ยง2: `f`
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "Suppose ยง0 is an invertible function, with an inverse function ยง1.\n"
"\n"
"Then it follows that ยง2 is bijective, both injective and surjective.\n"
"\n"
"Your objective this level is to prove this."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `absurd`
#. ยง3: `P โ ยฌ P โ Q`
#. ยง4: `p : P`
#. ยง5: `np : ยฌ P`
#. ยง6: `absurd p np`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "For any propositions ยง0 and ยง1, ยง2 proves that ยง3. So if ยง4 and ยง5,\n"
"then ยง6 supplies a proof of any proposition."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "There is one remaining level in our game. Move on to Dependent World to encounter type forming operations that take as input families of types, the *dependent types* of dependent type theory."
msgstr ""

#. ยง0: `ยซ{h}ยป : ยซ{P}ยป โจ ยซ{Q}ยป`
#. ยง1: `cases h`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "After introducing the hypothesis ยง0, type ยง1 to ask Lean to consider both cases: the first being that ยง2 is true and the second being that ยง3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way."
msgstr ""

#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "The next level will give more practice with the existential quantifier."
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `n`
#. ยง2: `induction n with d hd`
#. ยง3: `n`
#. ยง4: `d`
#. ยง5: `hd`
#. ยง6: ```
#. 0 + n = n
#. ```
#. ยง7: `induction n with d hd`
#. ยง8: `0 + 0 = 0`
#. ยง9: `hd : 0 + d = d`
#. ยง10: `0 + succ d = succ d`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "## Summary\n"
"\n"
"If ยง0 is an object, and the goal mentions ยง1, then ยง2\n"
"attempts to prove the goal by induction on ยง3, with the inductive\n"
"variable in the successor case being ยง4, and the inductive hypothesis being ยง5.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"ยง6\n"
"\n"
"then\n"
"\n"
"ยง7\n"
"\n"
"will turn it into two goals. The first is ยง8;\n"
"the second has an assumption ยง9 and goal\n"
"ยง10.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Triple Negation"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "In the next level, we will prove that surjective functions compose."
msgstr ""

#. ยง0: `0 : โ`
#. ยง1: `zero : โ `
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "An introduction rule for the type of natural numbers defines an element which may be written in Lean ยง0 or ยง1."
msgstr ""

#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "Type of Types"
msgstr ""

#. ยง0: `g (f ยซ{x}ยป) = g (f ยซ{y}ยป)`
#. ยง1: `(g โ f) ยซ{x}ยป = (g โ f) ยซ{y}ยป`
#. ยง2: `exact ยซ{p}ยป`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Your goal ยง0 is very similar to one of your assumptions ยง1. Try ยง2."
msgstr ""

#: Game.Levels.NaturalNumbersWorld
msgid "Natural Numbers World"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "Type ยง0 to split the goal up into the four proof obligations."
msgstr ""

#. ยง0: `Unit`
#. ยง1: `() : Unit`
#. ยง2: `Bool`
#. ยง3: `false true : Bool`
#. ยง4: `Unit โ Unit โ Bool`
#. ยง5: `Bool โ Unit โ Unit`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "For the Boss Level of Equivalence World you are asked to establish an equivalence between a priori unrelated types.\n"
"\n"
"One of these is the coproduct of the unit type ยง0 with itself. Recall the unit type has a canonical element ยง1.\n"
"\n"
"The other is the type of booleans ยง2 which has two canonical elements ยง3.\n"
"\n"
"Be careful how you define the functions ยง4 and ยง5. If you make a wrong choice, you will not be able to solve the rest of this level."
msgstr ""

#. ยง0: `ยซ{A}ยป`
#. ยง1: `ยซ{x}ยป : ยซ{A}ยป`
#. ยง2: `ยซ{x}ยป : ยซ{A}ยป`
#. ยง3: `exact ยซ{x}ยป`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Now the goal is an element of type ยง0, which should be thought of as result of applying the function to the element ยง1. In the case of the identity function, we want to return ยง2 again which is done by typing ยง3."
msgstr ""

#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "In the next level, we will establish another equivalence involving function types."
msgstr ""

#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "In the next level, we will see that the equality type is itself a proposition."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Coproduct With Empty"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `a : A`
#. ยง2: `f`
#. ยง3: `a`
#. ยง4: `f a : B`
#. ยง5: `B`
#. ยง6: `f a`
#. ยง7: `B`
#. ยง8: `f`
#. ยง9: `a`
#. ยง10: `a : A`
#. ยง11: `f : A โ B`
#. ยง12: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The *elimination rule* for function types explains how functions can be used to define elements of other types.\n"
"\n"
"Given a function ยง0 and any element ยง1. You can apply the function ยง2 to ยง3 to obtain an element ยง4 of type ยง5.\n"
"\n"
"Like many programming languages, Lean uses juxtaposition, with a space in between, to denote function application. So ยง6 is the Lean notation  for the element of ยง7 obtained by applying the function ยง8 to the element ยง9.\n"
"\n"
"In this level, the context contains the elements ยง10 and ยง11 and the goal is to define an element of type ยง12."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Projected Pairs"
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Symmetry"
msgstr ""

#. ยง0: `Empty`
#. ยง1: `Empty.elim : Empty โ A`
#. ยง2: `A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The empty type ยง0 has no introduction rules. It is an inductive type, meaning that it is in some sense *freely generated* by the elements provided by its introduction rules. In this case, this means that the elimination rule provides a canonical function ยง1 valued in any type ยง2."
msgstr ""

#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Negating Conjunction"
msgstr ""

#. ยง0: `P : A โ B โ Prop`
#. ยง1: `โ x : A, โ y : B, P x y`
#. ยง2: `โ z : B, โ w : A, P w z`
#. ยง3: `h : โ z : B, โ w : A, P w z`
#. ยง4: `h`
#. ยง5: `b : B`
#. ยง6: `hb : โ w : A, P w b`
#. ยง7: `b`
#. ยง8: `z`
#. ยง9: `โ w : A, P w z`
#. ยง10: `h`
#. ยง11: `โจb, hbโฉ : โ z : B, โ w : A, P w z`
#. ยง12: `h = โจb, hbโฉ`
#. ยง13: `h`
#. ยง14: `rcases h with โจb, hbโฉ`
#. ยง15: `h`
#. ยง16: `b : B`
#. ยง17: `hb : โ w : A, P w b`
#. ยง18: `let โจb, hbโฉ := h`
#. ยง19: `b : B`
#. ยง20: `hb : โ w : A, P w b`
#. ยง21: `h`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Consider a family of propositions that depends on elements drawn from two separate types:\n"
"\n"
"ยง0\n"
"\n"
"In this level, we will compare the two statements\n"
"\n"
"ยง1 and\n"
"ยง2.\n"
"\n"
"We will see that the second statement implies the first.\n"
"\n"
"The converse implication is not true in general. Can you see why?\n"
"\n"
"To solve this level, you will need to use a hypothesis involving an existential quantifier,\n"
"which in this case will have the form:\n"
"\n"
"ยง3\n"
"\n"
"We would like to decompose the hypothesis ยง4 into a pair of elements: firstly an element ยง5\n"
"and secondly a proof ยง6. Note that the element ยง7 gets substituted for the variable ยง8 in the family of propositions ยง9.\n"
"\n"
"We can think of the proof ยง10 as being given by this pair of data ยง11. Indeed ยง12.\n"
"\n"
"To extract this data from the proof ยง13, type ยง14 to replace ยง15 by the pair of assumptions ยง16 and ยง17.\n"
"\n"
"Alternatively, type ยง18 to extract the elements ยง19 and ยง20 from ยง21."
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Now the goal is an element of a product type. How can such elements be defined?"
msgstr ""

#. ยง0: `f g : A โ B`
#: Game.Levels.AdvancedFunctionWorld
msgid "In this world, we will return to our study of functions.\n"
"\n"
"Using the universal and existential quantifiers, we will state important properties of functions\n"
"and prove the interrelationships between these notions.\n"
"\n"
"We will also answer the question of what it means for two functions ยง0 to be equal.\n"
"\n"
"These results will be used in Equivalence World to answer what it means for two types to be the same."
msgstr ""

#. ยง0: `exact ยซ{a}ยป`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Now finish the definition of the inverse function with ยง0."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The goal asks you to prove two theorems, so start with ยง0."
msgstr ""

#. ยง0: `A`
#. ยง1: `a : A`
#. ยง2: `A`
#: Game.Levels.TypeWorld.L01_Elements
msgid "Under the hypothesis that we have a type ยง0 and an element ยง1, we may define an element of ยง2."
msgstr ""

#. ยง0: `g`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Try applying the hypothesis that ยง0 is injective."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `Q โ P`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "If ยง0 is true, then for any proposition ยง1, ยง2 is always true."
msgstr ""

#. ยง0: `f g : A โ B`
#. ยง1: `rfl : f = fun x โฆ f x`
#. ยง2: `f`
#. ยง3: `x โฆ f x`
#. ยง4: `ฮท-rule`
#. ยง5: `rfl : g = fun x โฆ g x`
#. ยง6: `f = g`
#. ยง7: `fun f โฆ f x`
#. ยง8: `fun x โฆ g x`
#. ยง9: `p x : f x = g x`
#. ยง10: `x : A`
#. ยง11: `f = g`
#. ยง12: `f x = g x`
#. ยง13: `x : A`
#. ยง14: `ext`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Suppose that ยง0 are functions. What does it mean for these functions to be equal?\n"
"\n"
"There is an idea that a function is determined by its values. In fact, we have ยง1, meaning that the function ยง2 is definitionally equal to the function defined by the formula ยง3. This is sometimes called the ยง4 for functions.\n"
"\n"
"Similarly of course ยง5. So when does ยง6?\n"
"\n"
"By transitivity of equality, it suffices for ยง7 and ยง8 to be equal.\n"
"\n"
"This suggests that it suffices to have a proof ยง9 for all elements ยง10.\n"
"\n"
"To reduce the question of proving an equality ยง11 to the question of proving that ยง12 for all ยง13, we must appeal to an axiom called *function extensionality*.\n"
"\n"
"Function extensionality is an instance of a general ยง14 tactic that can be used to prove equality in many types."
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Product Symmetry"
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `Nat.add_zero n`
#. ยง2: `n + 0 = n`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "For ยง0, ยง1 is the proof that ยง2."
msgstr ""

#. ยง0: `ยซ{h}ยป : P โ Q โง R`
#. ยง1: `ยซ{p}ยป: P`
#. ยง2: `ยซ{h}ยป ยซ{p}ยป : Q โง R`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "We can apply the proof ยง0 to the proof ยง1 to obtain ยง2. How can these be used to prove the goal?"
msgstr ""

#. ยง0: `intro n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Use ยง0 to start your definition."
msgstr ""

#. ยง0: `succ : โ โ โ`
#. ยง1: `pred : โ โ โ`
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "The composite of ยง0 followed by ยง1 is the identity function."
msgstr ""

#. ยง0: `(P โ Q) โง (P โ R)`
#. ยง1: `P โ Q โง R`
#. ยง2: `P โ (Q โง R)`
#. ยง3: `S`
#. ยง4: `T`
#. ยง5: `S โ (S โ T) โ T`
#. ยง6: `s : S`
#. ยง7: `h : S โ T`
#. ยง8: `T`
#. ยง9: `h`
#. ยง10: `S`
#. ยง11: `s`
#. ยง12: `h s : T`
#. ยง13: `h`
#. ยง14: `s`
#. ยง15: `h : S โ T`
#. ยง16: `h`
#. ยง17: `s : S`
#. ยง18: `h s : T`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "The task in this level is to show another logical equivalence,\n"
"this time between the conjoined implications ยง0 and the implication ยง1, which is implicitly parenthesized as ยง2.\n"
"\n"
"The proof will require an idea that we have not used for a while. We've seen that for propositions ยง3 and ยง4,\n"
"ยง5 can be proven by introducing hypotheses ยง6 and ยง7, at which point the goal is to prove ยง8.\n"
"Then applying the hypothesis ยง9 reduces the goal to proving ยง10 which we know is true by ยง11.\n"
"\n"
"Recall there is special notation ยง12 for the proof constructed by applying the hypothesis ยง13 to the hypothesis ยง14.\n"
"\n"
"This notation is justified by the analogy between proofs of implications like ยง15 and functions. The proof ยง16 can be thought of as a function that takes a proof ยง17 and returns a proof ยง18."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `B`
#. ยง2: `B โ A`
#. ยง3: `a : A`
#. ยง4: `x : B`
#. ยง5: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "Given a term ยง0 and any type ยง1, there is a function of type ยง2 which is *constant* at ยง3.\n"
"\n"
"This means that for any input ยง4 the output is always the element ยง5.\n"
"\n"
"Can you figure out how to define this function?"
msgstr ""

#. ยง0: `Unit โ Unit`
#. ยง1: `Bool`
#. ยง2: `โ`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "The equivalence between the types ยง0 and ยง1 has to do with the fact that both are examples of *inductive types*. In Natural Numbers World, we will finally properly introduce another inductive type, namely the type ยง2 of natural numbers. Go there next."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ P`
#. ยง2: `P`
#. ยง3: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "For any proposition ยง0, if ยง1 and ยง2 are both true, then we obtain a proof of ยง3."
msgstr ""

#. ยง0: `Or.inl`
#. ยง1: `Or.inr`
#. ยง2: `S โจ T`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Recall ยง0 and ยง1 refer to the left and right propositions in a disjunction ยง2."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "For the Boss Level, your task is to:\n"
"\n"
"* break apart a function from a coproduct type into a product type into four separate component functions and\n"
"\n"
"* then reassemble four component functions to a single function from a coproduct type into a product type.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "If ยง0 and ยง1 are both surjective then ยง2 is also surjective."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.BooleanWorld.L02_DoubleNegation
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Double Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "What tactics can be used to break a goal involving conjunction into subgoals?"
msgstr ""

#. ยง0: `ยซ{p}ยป : not false = not true`
#. ยง1: `not false = true`
#. ยง2: `not true = false`
#. ยง3: `ยซ{p}ยป`
#. ยง4: `true = false`
#. ยง5: `have eq : true = false := p`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Now where does the contradiction come from? We have exactly one hypothesis, namely ยง0. Recall that ยง1 and ยง2, with both of these equalities by definition. Thus ยง3 is also a proof of ยง4. You can add this to your context by ยง5."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a function type, so start with ยง0."
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `x : A`
#. ยง2: `a : A`
#. ยง3: `P a`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Suppose the predicate ยง0 holds for all ยง1. Then for any particular element ยง2, ยง3 is true."
msgstr ""

#. ยง0: `intro n`
#. ยง1: `n`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The goal is a universally quantified statement. Start with ยง0 to consider an arbitrary natural number ยง1."
msgstr ""

#. ยง0: `P โ Q โ R โ S โ T`
#. ยง1: `intro p q r s`
#. ยง2: `p : P`
#. ยง3: `q : Q`
#. ยง4: `r : R`
#. ยง5: `s : S`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "For compound implications &mdash; statements of the form ยง0 &mdash; you can type ยง1 to introduce hypothesis ยง2, ยง3, ยง4, and ยง5 all at once."
msgstr ""

#. ยง0: `have eq1 : (g โ f) ยซ{x}ยป = g (f ยซ{x}ยป) := rfl`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Use ยง0 and a similar lemma to give yourself more equalities to rewrite along."
msgstr ""

#. ยง0: `exact fun _ โฆ p
#. `
#. ยง1: `\\mapsto`
#. ยง2: `โฆ`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "The proof of an implication constructs a function which converts a proof of the first proposition into a proof of the second function. Try solving this level again by typing ยง0, using ยง1 to type the ยง2 symbol."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `A`
#. ยง4: `A โ Empty`
#. ยง5: `A โ Empty`
#. ยง6: `Sum.inl a`
#. ยง7: `a : A`
#. ยง8: `Sum.inr x`
#. ยง9: `x : Empty`
#. ยง10: `A โ Empty`
#. ยง11: `A`
#. ยง12: `A โ A โ Empty`
#. ยง13: `A โ Empty โ A`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall that for any types ยง0 and ยง1, there is a *coproduct type* denoted ยง2.\n"
"\n"
"In particular, for any type ยง3, we may form the product ยง4 with the empty type.\n"
"\n"
"In general, coproduct types like ยง5 have two types of elements: those of the form ยง6 for some ยง7 and those of the form ยง8 for ยง9.\n"
"\n"
"But the empty type does not have any elements. So this second case does not exist.\n"
"\n"
"It follows that the type ยง10 is *equivalent* to the type ยง11 in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions ยง12 and ยง13.\n"
"\n"
"Your task in this level is to define these functions."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P โจ Q`
#. ยง2: `P โง Q โ P โจ Q`
#. ยง3: `P โจ Q โ P โง Q`
#. ยง4: `P โง Q โ P โจ Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โจ Q`
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "The proposition ยง0 is *stronger* than the proposition ยง1 because ยง2 is true in general, but the implication ยง3 does not necessarily hold.\n"
"\n"
"Note the implication ยง4 holds because the mathematical or is *inclusive*, meaning that if ยง5 and ยง6 are both true, then ยง7 is true, and in fact can be proven in two different ways."
msgstr ""

#. ยง0: `cases ยซ{gc}ยป`
#. ยง1: `rcases ยซ{gc}ยป with โจb, hbโฉ`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Try ยง0 or ยง1."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โจ Q`
#. ยง3: `Q โจ P`
#. ยง4: `Or.symm`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "We can improve our understanding of the symmetry of disjunction as follows.\n"
"\n"
"For propositions ยง0 and ยง1, ยง2 is true if and only if ยง3 is true.\n"
"\n"
"To prove this you might find it useful to use the theorem ยง4 proven in the previous level. This is now in your library."
msgstr ""

#. ยง0: `ยฌ (false = true)`
#. ยง1: `p : false = true`
#. ยง2: `False`
#. ยง3: `P : Bool โ Prop`
#. ยง4: `false`
#. ยง5: `False`
#. ยง6: `true`
#. ยง7: `True`
#. ยง8: `True โ False`
#. ยง9: `P true โ P false`
#. ยง10: `x : P true`
#. ยง11: `p`
#. ยง12: `P false`
#. ยง13: `P true`
#. ยง14: `x : P true`
#. ยง15: `โจโฉ : True`
#. ยง16: `False`
#. ยง17: `exact Bool.noConfusion`
#. ยง18: `ยฌ (false = true)`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "We will now finally prove an example that two elements of a type are distinct, demonstrating that\n"
"the two booleans are not equal:\n"
"\n"
"ยง0.\n"
"\n"
"The proof is quite delicate, so let us explain how it works.\n"
"\n"
"We are asked to prove a negation so suppose we have ยง1. We would like to derive a contradiction, that is an element of ยง2.\n"
"\n"
"The key ingredient is to use a function ยง3 defined to send the boolean ยง4 to the proposition ยง5 and the boolean ยง6 to the proposition ยง7.\n"
"\n"
"Using this we can define a function ยง8, i.e., a function ยง9 by introduction a hypothesis ยง10 then rewriting along the equality ยง11 to change the goal from ยง12 to ยง13, then returning ยง14.\n"
"\n"
"Applying this function to the element ยง15 returns an element of ยง16, a contradiction.\n"
"\n"
"Use the hints to step through this proof.\n"
"\n"
"Alternatively, type ยง17 to solve this level with Lean's built in proof that ยง18."
msgstr ""

#. ยง0: `A`
#. ยง1: `id : A โ A`
#. ยง2: `a : A`
#. ยง3: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type ยง0, ยง1 is the function defined by sending ยง2 to ยง3."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ x : A, โ y : B, f x = y`
#. ยง2: `f : A โ B`
#. ยง3: `y : B`
#. ยง4: `x : A`
#. ยง5: `f x = y`
#. ยง6: `B`
#. ยง7: `f`
#. ยง8: `A`
#. ยง9: `y : B`
#. ยง10: `x : A`
#. ยง11: `f x = y`
#. ยง12: `โ y : B, โ x : A, f x = y`
#. ยง13: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Recall that every function is *total*. For any function ยง0, we have proven that\n"
"ยง1.\n"
"\n"
"A function ยง2 is *surjective* if for every ยง3 there exists some ยง4 so that ยง5.\n"
"\n"
"The condition asserts that every element of ยง6 is an output of the function ยง7 for some element of ยง8. For each ยง9 there is some ยง10 so that ยง11.\n"
"\n"
"Unlike totality, the statement ยง12 is true for some functions but false for others.\n"
"\n"
"In this level, we will show that the function ยง13 is surjective."
msgstr ""

#. ยง0: `X โ A ร B`
#. ยง1: `(X โ A) ร (X โ B)`
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "Another equivalence of types captures the full universal property of product types.\n"
"\n"
"Namely the type of functions ยง0 into a product type is equivalent to the type of functions\n"
"\n"
"ยง1\n"
"\n"
"defined by taking the product of two function types."
msgstr ""

#. ยง0: `pred : Nat โ Nat`
#. ยง1: `match n with | zero => exact ? | succ k => exact ?`
#. ยง2: `?`
#. ยง3: `pred zero`
#. ยง4: `?`
#. ยง5: `pred (succ k)`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "To define the function ยง0 by recursion type ยง1 replacing the first ยง2 with the value of ยง3 and the second ยง4 with the value of ยง5."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P โจ Q`
#. ยง6: `p : P`
#. ยง7: `q : Q`
#. ยง8: `exact p`
#. ยง9: `exact q`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `left`
#. ยง13: `right`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "To prove a disjunction ยง0 it suffices to supply a proof of either ยง1 or of ยง2.\n"
"\n"
"Thus under the hypothesis that ยง3 and ยง4 are both true, there are two ways to prove ยง5: one using ยง6 and one using ยง7.\n"
"\n"
"Note ยง8 or ยง9 won't work as these are proofs of different propositions, namely the proposition ยง10 or the proposition ยง11.\n"
"\n"
"To give a proof you have two choices: to reduce to the case of proving the left proposition or to reduce to the case of proving the right proposition.\n"
"\n"
"Type ยง12 to tell Lean you'd like to prove the left proposition or type ยง13 to tell Lean you'd like to prove the right proposition."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "The upshot of this level and the previous one is that in classical logic at least, a function is bijective if and only if it is invertible."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a product type, so ยง0 can be used to break the goal into pieces."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `And.curry`
#. ยง4: `P โง Q โ R`
#. ยง5: `P โ Q โ R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "For propositions ยง0, ยง1, and ยง2, ยง3 is a proof that ยง4 implies ยง5."
msgstr ""

#. ยง0: `ext`
#. ยง1: `ext b`
#. ยง2: `b : Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Type ยง0 to apply function extensionality or ยง1 to apply function extensionality with ยง2 the chosen variable."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `y : B`
#. ยง3: `z : B`
#. ยง4: `B`
#. ยง5: `B`
#. ยง6: `assumption`
#. ยง7: `exact`
#. ยง8: `E`
#. ยง9: `e : E`
#. ยง10: `exact e`
#. ยง11: `e`
#. ยง12: `exact`
#. ยง13: `P`
#. ยง14: `p : P`
#. ยง15: `exact p`
#. ยง16: `exact`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "A more elaborate context may contain multiple types and multiple elements, or a mix of types, elements, propositions, and proofs.\n"
"\n"
"Thus, we may require a more precise way to tell Lean which data or hypothesis from our context should be used.\n"
"\n"
"In this level, our context includes two types ยง0 and ยง1 with three elements between them. Note the use of a space rather than a list to indicate that ยง2 and ยง3 each define elements of type ยง4.\n"
"\n"
"Our goal is to define an element of type ยง5 and the tactic ยง6 will solve this goal. But this tactic does not convey to the reader which assumption was used.\n"
"\n"
"In this sort of setting, it is better practice to use the tactic ยง7. If the goal has type ยง8 and there is an element ยง9 in the context, then ยง10 uses the element ยง11 to close the goal.\n"
"\n"
"The ยง12 tactic can also be used when the goal is a proposition ยง13 and the context includes a proof ยง14. Then ยง15 will solve the goal.\n"
"\n"
"The tactic ยง16 can now be found in the library."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `x : A`
#. ยง3: `y : B`
#. ยง4: `โ`
#. ยง5: `โค`
#. ยง6: `โ`
#. ยง7: `โ`
#. ยง8: `โ`
#. ยง9: `โ`
#. ยง10: `0 : โ`
#. ยง11: `1 : โ`
#. ยง12: `57`
#. ยง13: `57`
#. ยง14: `P`
#. ยง15: `Q`
#. ยง16: `p : P`
#. ยง17: `q : Q`
#. ยง18: `P`
#. ยง19: `x`
#. ยง20: `y`
#. ยง21: `P`
#. ยง22: `x`
#. ยง23: `y`
#: Game.Levels.TypeWorld
msgid "In this world, we introduce two primitives:\n"
"\n"
"* *types* denoted with capital variables like ยง0 and ยง1 and\n"
"* *elements* written ยง2 or ยง3.\n"
"\n"
"For example, there are types ยง4 of\n"
"natural numbers, ยง5 of integers, ยง6 of rational numbers, ยง7 of real numbers, ยง8 of natural\n"
"numbers, and so on. There are also types of more sophisticated mathematical structures, like vector spaces or groups.\n"
"\n"
"Types can have more than one element. The elements of the type ยง9 are the familiar natural numbers:  ยง10, ยง11 and so on.\n"
"\n"
"By contrast, elements belong to unique types. The integer ยง12 is distinct from the natural number ยง13. This is one of the reasons why type theory is useful for precise mathematical communication: an element always carries the information of the type that it belongs to.\n"
"\n"
"Mathematical *propositions* can be thought of as a special case of types. For propositions ยง14 and ยง15, we think of\n"
"elements ยง16 and ยง17 as *proofs* that these propositions are true.\n"
"\n"
"By contrast, false propositions will not have any elements. In Negation World, we will learn how to prove that a proposition ยง18 is false.\n"
"\n"
"What distinguishes propositions from types is the fact that the elements do not contain any information beyond witnessing the truth of the proposition. If ยง19 and ยง20 are two proofs of a proposition ยง21, then ยง22 and ยง23 are equal in a sense that will be introduced in Equality World."
msgstr ""

#. ยง0: `Active Goal`
#. ยง1: `objects`
#. ยง2: `assumptions`
#. ยง3: `goal`
#. ยง4: `A`
#. ยง5: `a : A`
#. ยง6: `A`
#. ยง7: `A`
#. ยง8: `assumption`
#. ยง9: `enter`
#. ยง10: `Execute`
#. ยง11: `assumption`
#: Game.Levels.TypeWorld.L01_Elements
msgid "An interative theorem prover &mdash; in this case Lean &mdash; helps the user &mdash; this means you &mdash; keep track of the state of a proof or a mathematical construction.\n"
"\n"
"In the ยง0 window, Lean keeps track of the ยง1 and ยง2 &mdash; which together define the hypotheses of a mathematical statement &mdash; as well as the ยง3 &mdash; meaning the thing we are trying to prove.\n"
"\n"
"The objects and assumptions together define the mathematical *context* for a given theorem or construction.\n"
"\n"
"Here our context is given by a single type ยง4 with a hypothesized element ยง5.\n"
"\n"
"On the right-hand side we see the name of a type, which is the *goal* for this level. Here that type is ยง6, which means that our goal is to define an element of type ยง7.\n"
"\n"
"We have such an element by assumption, and you can type ยง8 to tell Lean this. Then type ยง9 or click the button ยง10 to ask Lean to check your work.\n"
"\n"
"Here ยง11 is an example of a *tactic*, which is built into Lean. You can find this in the tactic library on the upper right."
msgstr ""

#. ยง0: `((((V โ F) โ F) โ F) โ F)`
#. ยง1: `(V โ F) โ F`
#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "Given a function of type ยง0 there is a canonically defined function of type ยง1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
msgid "Are function types associative? Why or why not?"
msgstr ""

#. ยง0: `have np : ยฌ P := by`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "If you used editor mode to prove some lemmas in the middle of this proof, it is good practice to indent the lines that form the proof of the lemma following the ยง0. This makes it more clear which steps are used to prove the lemma and which are used to prove the main goal. Go next to Equality World where we will finally introduce the slippery notion of mathematical equality."
msgstr ""

#. ยง0: `Unit`
#. ยง1: `โจโฉ : Unit`
#. ยง2: `Unit`
#. ยง3: `assumption`
#. ยง4: `exact`
#. ยง5: `\\<`
#. ยง6: `\\>`
#. ยง7: `โจโฉ`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The previous levels involved type variables or proposition variables.\n"
"\n"
"But there are other specific types or propositions that exist in the empty context. In other words, these types are globally defined.\n"
"\n"
"One example is the unit type ยง0 which has a canonical element ยง1.\n"
"\n"
"Here our goal has type ยง2. We cannot solve this goal with the tactic ยง3 because we have not made an assumptions!\n"
"\n"
"But we can solve this level with the tactic ยง4 by typing the name of the canonical element.\n"
"\n"
"Use ยง5 and ยง6 to type the angle brackets ยง7."
msgstr ""

#: Game.Levels.ImplicationWorld
msgid "Implication World"
msgstr ""

#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "What can you do with these assumptions?"
msgstr ""

#. ยง0: `m`
#. ยง1: `n`
#. ยง2: `n + 0 = n`
#. ยง3: `m + (succ n) = succ (m + n)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "For all natural numbers ยง0 and ยง1, ยง2 and ยง3."
msgstr ""

#. ยง0: `match`
#. ยง1: `_`
#. ยง2: `and`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Was it necessary to consider all four cases of two boolean elements or can you define this function by considering fewer cases? If using the tactic ยง0, try replacement one of the input booleans with ยง1 to indicate that the value does not matter. The function ยง2 is now in your library."
msgstr ""

#. ยง0: `A ร B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `a : A`
#. ยง4: `b : B`
#. ยง5: `A ร B`
#. ยง6: `โจa , bโฉ : A ร B`
#. ยง7: `a : A`
#. ยง8: `b : B`
#. ยง9: `exact โจa,bโฉ`
#. ยง10: `\\<`
#. ยง11: `\\>`
#. ยง12: `constructor`
#. ยง13: `A ร B`
#. ยง14: `constructor`
#. ยง15: `A`
#. ยง16: `B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "The introduction rule for product types tells us that elements of a product type ยง0 are formed by *pairing* elements of type ยง1 with elements of type ยง2.\n"
"\n"
"Given an element ยง3 and an element ยง4 there is a corresponding element of the product type ยง5 that is denoted by ยง6.\n"
"\n"
"This element should be thought of as an *ordered pair* whose first component is the element ยง7 and whose second element is the element ยง8.\n"
"\n"
"This can be input directly by typing ยง9 using ยง10 and ยง11 to type the angle brackets; note the spacing around the angle brackets and the commas is not important.\n"
"\n"
"Alternatively, you can apply the ยง12 tactic which allows you to first input the first component and then input the second component.\n"
"\n"
"When the goal is a product type ยง13, typing ยง14 will produce two goals, the first of which has type ยง15 and the second of which has type ยง16."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `p.1 : A`
#. ยง2: `p.2 : B`
#. ยง3: `โจp.1, p.2โฉ : A ร B`
#. ยง4: `p`
#. ยง5: `โจp.1, p.2โฉ`
#. ยง6: `A ร B`
#. ยง7: `p = โจp.1, p.2โฉ`
#. ยง8: `x = y`
#. ยง9: `x`
#. ยง10: `y`
#. ยง11: `p = โจp.1, p.2โฉ`
#. ยง12: `rfl : p = โจp.1, p.2โฉ`
#. ยง13: `p.fst`
#. ยง14: `p.snd`
#. ยง15: `p.1`
#. ยง16: `p.2`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "The introduction rule for equality types is surprisingly weak, telling us only that proofs of equality can be defined by reflexivity.\n"
"\n"
"This tactic is stronger than it initially appears on account of the *computation rules* for elements of certain types.\n"
"\n"
"To illustrate, consider an element in a product type ยง0. Using the projections, we obtain terms\n"
"ยง1 and ยง2. These can then be paired back to form an element ยง3 in the product type.\n"
"\n"
"What is the relationship between ยง4 and ยง5?\n"
"\n"
"Firstly, both of these are elements of the same type, namely ยง6. Thus, there is a mathematically meaningful proposition\n"
"ยง7 because in general it makes mathematical sense to ask whether ยง8 whenever ยง9 and ยง10 are both terms belonging to the same type.\n"
"\n"
"In this case one of the *computation rules* for product types tells us that the proposition\n"
" ยง11 is true, essentially by definition of the projection and pairing functions associated to products. Thus the proof is again by reflexivity and we have ยง12.\n"
"\n"
"Note Lean uses ยง13 and ยง14 as synonyms for ยง15 and ยง16 respectively."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `P โ Q`
#. ยง4: `p : P`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โ Q`
#. ยง8: `intro p`
#. ยง9: `p : P`
#. ยง10: `Q`
#. ยง11: `Q`
#. ยง12: `P`
#. ยง13: `intro`
#. ยง14: `P`
#. ยง15: `P`
#. ยง16: `P โ P`
#. ยง17: `P`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "To prove an implication ยง0 one needs to give a construction of a proof of ยง1 from a hypothesized proof of ยง2.\n"
"\n"
"In particular, to prove that ยง3 it suffices to assume that we have a proof ยง4 &mdash; even if ยง5 is false and such a proof does not exist &mdash; in which case the new goal is to find a proof of ยง6.\n"
"\n"
"When the goal has the form ยง7, type ยง8 to introduce an assumption ยง9 and update the goal to proving ยง10 &mdash; asking for a proof that ยง11 is true under the assumption that ยง12 is true.  It is also possible to type simply ยง13 in which case Lean will automatically generate a name for the proof of ยง14.\n"
"\n"
"In this level, we will see that for any proposition ยง15, ยง16 is true. Indeed, this is the case even if ยง17 itself is false!"
msgstr ""

#. ยง0: `not : Bool โ Bool`
#. ยง1: `Bool โ Bool โ Bool`
#. ยง2: `Bool โ Bool โ Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "We have seen that the logical operation of negation can be encoded as a function ยง0.\n"
"\n"
"We can similarly define a function ยง1 that encodes the logical operation of conjunction.\n"
"\n"
"Again, this level comes with two pre-defined goals: the first is to define the conjunction function ยง2 and the second is to check that your definition is correct by calculating the values of the function you defined on explicit pairs of booleans."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "We are now ready for the Boss Level of Equivalence World."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "When in doubt, start the proof of an implication with the ยง0 tactic."
msgstr ""

#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "This logical equivalence captures the *universal property* of disjunction, explaining how the mathematical or is used in a proof."
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `flip f : B โ A โ C`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Note that for a particular multvariable function ยง0, its type dictates that the variable of type ยง1 must be supplied before the variable of type ยง2. But as observed in this level, we can then define a corresponding function ยง3 which encodes the same information."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `(A โ B) โ (B โ Empty) โ (A โ Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types ยง0 and ยง1, there is a function ยง2 defined by composition."
msgstr ""

#. ยง0: `S โ T`
#. ยง1: `(S โ T) โง (T โ S)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Recall that ยง0 is an abbreviation for ยง1. What is the outermost connective here? Which tactic can be used to break this into subgoals?"
msgstr ""

#. ยง0: `ยซ{na}ยป`
#. ยง1: `A`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "To apply the hypothesis ยง0 it would help to have a specific element of ยง1 to apply it to. Can you see where this might come from?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Can we apply our hypothesis yet or must we act on the goal first?"
msgstr ""

#. ยง0: `A โ Empty`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "This level illustrates another strange construction that can be made from an element of type ยง0."
msgstr ""

#. ยง0: `x y : Unit`
#. ยง1: `x = y`
#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "The unit type is a proposition: for ยง0, ยง1."
msgstr ""

#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "Currying / Uncurrying"
msgstr ""

#. ยง0: `P โง Q โ R`
#. ยง1: `P โ Q โ R`
#. ยง2: `P โ Q โ R`
#. ยง3: `P โง Q โ R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "In the previous level we proved that ยง0 implies ยง1.\n"
"\n"
"We now show that ยง2 implies ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty.elim : Empty โ A`
#. ยง2: `f : A โ Empty`
#. ยง3: `A`
#. ยง4: `Empty`
#. ยง5: `A`
#. ยง6: `A`
#. ยง7: `f : A โ Empty`
#. ยง8: `a : A`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have seen that any type ยง0 has a function from the empty type ยง1.\n"
"\n"
"By contrast, if there is a function ยง2 from ยง3 to the empty type ยง4 then ยง5 must be very special: this is only possible if ยง6 is *equivalent* to the empty type.\n"
"\n"
"We do not have all the tools needed to define equivalence of types just yet, so in this level we observe something else.\n"
"\n"
"We will see that if there is a function ยง7 and if there is an element ยง8, then we get an element of the empty type, which is very strange indeed!\n"
"\n"
"Can you construct this element?"
msgstr ""

#. ยง0: `Nat.pred : โ โ โ`
#. ยง1: `Nat.pred_succ n : Nat.pred (succ n) = n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "The function ยง0 that you have just defined is now in your library as well as the theorem ยง1."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "The next topic in our study of propositional logic is *negation*, which is used to assert that a proposition is false rather than true. But to help us understand it, move on to Empty World to learn about the empty type."
msgstr ""

#. ยง0: `cases ยซ{x}ยป`
#. ยง1: `ยซ{x}ยป`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall you can type ยง0 to ask Lean to consider which cases are actually possible for the hypothetical element ยง1."
msgstr ""

#: Game.Levels.TypeWorld.L02_Proofs
msgid "In the next level, we will learn a new tactic, which allows us to be more precise about which assumption is being used."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `Or.inl`
#. ยง3: `P โ (P โจ Q)`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "For propositions ยง0 and ยง1, ยง2 is a proof that ยง3."
msgstr ""

#. ยง0: `P`
#. ยง1: `False โ P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition ยง0, the implication ยง1 is true."
msgstr ""

#. ยง0: `False`
#. ยง1: `P`
#. ยง2: `False โ P`
#. ยง3: `False`
#. ยง4: `Empty`
#. ยง5: `False`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The proposition ยง0 has no elements &mdash; there are no proofs of &ldquo;false.&rdquo;\n"
"\n"
"Consequently, for any other proposition ยง1, the implication ยง2 is true.\n"
"\n"
"The task in this level is to prove this.\n"
"\n"
"The proposition ยง3 is really just another name for the empty type ยง4, so the constructions explored in Empty World can be used analogously to prove propositions involving ยง5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Now you are ready for the Boss Level."
msgstr ""

#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Applying Functions"
msgstr ""

#. ยง0: `cases ยซ{p}ยป`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Type ยง0 to ask Lean to consider all possible cases involving an element of the empty type. As there are no cases, this will complete the proof."
msgstr ""

#. ยง0: `not (and x y) = or (not x) (not y)`
#. ยง1: `not (or x y) = and (not x) (not y)`
#. ยง2: `x y : Bool`
#. ยง3: `!(x && y) = !x || !y`
#. ยง4: `!(x || y) = !x && !y`
#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "The DeMorgan laws for booleans take the form of equalities\n"
"\n"
"ยง0 and\n"
"\n"
"ยง1\n"
"\n"
"for all booleans ยง2.\n"
"\n"
"In Lean's alternate notation the first equality is\n"
"\n"
"ยง3\n"
"\n"
"while the second equality is\n"
"\n"
"ยง4.\n"
"\n"
"The objective of this level is to prove these equalities."
msgstr ""

#. ยง0: `A โ B โ C`
#. ยง1: `(A โ C) ร (B โ C)`
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "Another equivalence of types captures the full universal property of coproduct types.\n"
"\n"
"Namely the type of functions ยง0 out of a coproduct type is equivalent to the type of functions\n"
"\n"
"ยง1\n"
"\n"
"defined by taking the product of two function types."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P โ Q`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "If ยง0 is true, then ยง1 is true."
msgstr ""

#. ยง0: `Bool`
#. ยง1: `false : Bool`
#. ยง2: `true : Bool`
#. ยง3: `Bool`
#. ยง4: `true : Bool`
#. ยง5: `false : Bool`
#. ยง6: `ยฌ(true = false)`
#: Game.Levels.BooleanWorld
msgid "In this world, we'll meet the type ยง0 of *booleans*.\n"
"\n"
"This type has two elements: ยง1 and ยง2.\n"
"\n"
"Formally these elements are just two elements with distinct names.\n"
"\n"
"But the terminology suggests that we can think of ยง3 as the type of truth values, with ยง4 representing the true proposition and ยง5 representing the false proposition.\n"
"\n"
"In this world, we will define various functions involving the type of booleans.\n"
"\n"
"We will also show that the type of booleans is *not* a proposition by proving that ยง6."
msgstr ""

#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Multivariable Functions"
msgstr ""

#. ยง0: `ยซ{k}ยป`
#. ยง1: `ยซ{k}ยป`
#. ยง2: `ยซ{hk}ยป : (โ m, ยซ{k}ยป = 2 * m) โจ โ m, ยซ{k}ยป = 2 * m + 1`
#. ยง3: `ยซ{k}ยป + 1`
#. ยง4: `k`
#. ยง5: `rcases ยซ{hk}ยป with even | odd`
#. ยง6: `ยซ{k}ยป`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Now that you have completed the base case, the next goal is to prove the inductive step. Here ยง0 is an arbitrary natural number and you are given a hypothesis that the predicate is true for ยง1, i.e., that ยง2. Your goal is to prove that the analogous result holds for ยง3, aka, the successor of ยง4. Type ยง5 to split into cases depending on whether or not ยง6 is even or odd."
msgstr ""

#. ยง0: `Unit`
#. ยง1: `Type`
#. ยง2: `exact Unit`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "In the previous level, we introduced the type ยง0. This is an element of the type ยง1, so you can solve this level by typing ยง2."
msgstr ""

#. ยง0: `ยซ{c}ยป.2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "What is the logical structure of the type that ยง0 belongs to?"
msgstr ""

#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "The following expression in conjunctive normal form is satisfiable."
msgstr ""

#. ยง0: `Prop`
#. ยง1: `P : A โ B โ C โ Prop`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "In general families of propositions indexed by multiple variables are just functions with multiple input types valued in ยง0, such as ยง1."
msgstr ""

#. ยง0: `And.uncurry : (P โ Q โ R) โ (P โง Q โ R)`
#. ยง1: `P โง Q โ R`
#. ยง2: `P โ Q โ R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "This proves the theorem ยง0. In the next level, we will combine these results to show that ยง1 and ยง2 are logically equivalent."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B โ B โ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For any types ยง0 and ยง1, there is a canonical function of type ยง2."
msgstr ""

#. ยง0: `0 : โ`
#. ยง1: `succ : โ โ โ`
#. ยง2: `0`
#. ยง3: `1 = succ 0`
#. ยง4: `2 = succ (succ 0)`
#. ยง5: `3 = succ (succ (succ 0))`
#. ยง6: `4 = succ (succ (succ (succ 0)))`
#. ยง7: `rfl`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "How do we construct examples of natural numbers?\n"
"\n"
"By the introduction rules:\n"
"\n"
"* There is a natural number ยง0.\n"
"* There are natural numbers obtained by applying the function ยง1.\n"
"\n"
"Familiar *numerals* are defined by repeated applications of the successor function to the natural number ยง2. For example:\n"
"* ยง3\n"
"* ยง4\n"
"* ยง5\n"
"* ยง6\n"
"and so on.\n"
"\n"
"As all of these are definitions, the equalities in this level can be proven with ยง7."
msgstr ""

#. ยง0: `rcases ยซ{h}ยป with โจb, hbโฉ`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `b : B`
#. ยง3: `hb : โ w : A, P w b`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Type ยง0 to replace ยง1 by the pair of assumptions ยง2 and\n"
"ยง3."
msgstr ""

#. ยง0: `โ`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Recall the meaning of ยง0. What tactic breaks this goal into its components?"
msgstr ""

#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Distributivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What is the logical structure of this type?"
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "This might be a useful time to apply one of the theorems proven earlier in Negation World."
msgstr ""

#. ยง0: `Or.symm`
#. ยง1: `exact Or.symm`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? If your proof does not make use of the name ยง0 that Lean has assigned to the proof given in the previous level, try typing ยง1 at an appropriate place in your proof."
msgstr ""

#. ยง0: `ยซ{ne}ยป`
#. ยง1: `(โ x, P x) โ False`
#. ยง2: `apply ยซ{ne}ยป`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "The hypothesis ยง0 is a proof that ยง1. So try ยง2."
msgstr ""

#. ยง0: `f g : A โ B`
#. ยง1: `โ x : A, f x = g x`
#. ยง2: `f = g`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "For functions ยง0 if ยง1 then ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A โ B) โ C`
#. ยง4: `A โ (B โ C)`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "For types ยง0, ยง1, and ยง2, there are canonical functions between the types ยง3 and ยง4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "More Compound Implication"
msgstr ""

#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "Next move on to Product World to meet a second type forming operation, which will again have a corresponding logical connective."
msgstr ""

#. ยง0: `match`
#. ยง1: `b : Bool`
#. ยง2: `match b with | false => ? | true => ?`
#. ยง3: `b`
#. ยง4: `b`
#. ยง5: `?`
#. ยง6: `x y : Bool`
#. ยง7: `match x y with | false, false => ? | false, true => ? | true, false => ? | true, true => ?`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The tactic ยง0 can be used to define a function by cases. For example, in the context of an\n"
"element ยง1, ยง2 splits the construction into the case where ยง3 is false followed by the case where ยง4 is true. Here both ยง5 should be replaced by the appropriate sequence of tactics for each case, using semicolons if more than one tactic is needed. In the context of ยง6,\n"
"ยง7 splits into the four possible cases."
msgstr ""

#. ยง0: `B`
#. ยง1: `Empty.elim : Empty โ B`
#. ยง2: `Empty`
#. ยง3: `B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Recall that for any type ยง0, there is a function ยง1. Using this and your element of ยง2 can you define an element of type ยง3?"
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "The ยง0 tactic can be used when the goal is a conjunction (among other settings) to split the goal into cases."
msgstr ""

#. ยง0: `h`
#. ยง1: `P`
#. ยง2: `Q`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Since ยง0 is a compound implication, we have multiple hypothesis to satisfy. We must prove that ยง1 is true and also prove that ยง2 is true. Fortunately, our assumptions cover both cases."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `p`
#. ยง4: `P`
#. ยง5: `h1`
#. ยง6: `P โ Q`
#. ยง7: `h2`
#. ยง8: `Q โ R`
#. ยง9: `R`
#. ยง10: `apply`
#. ยง11: `have`
#. ยง12: `have`
#. ยง13: `p : P`
#. ยง14: `h1 : P โ Q`
#. ยง15: `have q : Q := h1 p`
#. ยง16: `q : Q`
#. ยง17: `h1 p`
#. ยง18: `have`
#. ยง19: `R`
#. ยง20: `have r : R := h2 q`
#. ยง21: `r : R`
#. ยง22: `h2 q`
#. ยง23: `have`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "Now we are in the setting of three proposition variables ยง0, ยง1, and ยง2 with several hypotheses.\n"
"\n"
"The first assumption provides a proof ยง3 that the proposition ยง4 is true.\n"
"\n"
"The second provides a proof ยง5 that the implication ยง6 is true.\n"
"\n"
"The final hypothesis provides a proof ยง7 that ยง8 is true. Our goal is to conclude that ยง9 is true.\n"
"\n"
"This can be proven either backwards &mdash; by using the ยง10 tactic &mdash; or forwards &mdash; by directly constructing proofs out of our hypothesis.\n"
"\n"
"But it is also possible to work forwards with the ยง11 tactic, which is now in your library.\n"
"\n"
"The ยง12 tactic can be used to add new hypotheses provided you can supply a proof.\n"
"\n"
"For example, given assumptions ยง13 and ยง14, type ยง15 to add a proof ยง16 defined by ยง17.\n"
"\n"
"If you like, you can use the ยง18 tactic again to add a proof of ยง19 to the assumptions, by typing ยง20 to add a proof ยง21 defined by ยง22.\n"
"\n"
"The ยง23 tactic often makes proofs longer but it also makes them easier to read and easier to find.\n"
"\n"
"Practice using both forwards and backwards reasoning to solve this level."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "There are various ways to solve this level. You might enjoy searching for a shorter proof. For instance, there is a proof that takes just line and involves eight characters."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `ยฌ (P โ Q)`
#. ยง3: `P โง ยฌ Q`
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "In classical logic, for any propositions ยง0 and ยง1, ยง2 implies ยง3."
msgstr ""

#. ยง0: `have : (g โ f) ยซ{a}ยป = ?? := rfl`
#. ยง1: `??`
#. ยง2: `rw [โ ??]`
#. ยง3: `\\l`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "You can either prove a lemma ยง0 by replacing the ยง1 with the definition of the composition function. Or you can try ยง2 using ยง3 to type the left arrow."
msgstr ""

#. ยง0: `Prop`
#. ยง1: `True`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The type of propositions ยง0 contains propositions like ยง1."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "Zero is not the successor of any natural number."
msgstr ""

#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Empty Proposition"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Does this proof of modus ponens feel familiar?"
msgstr ""

#. ยง0: `Classical.byContradiction : ยฌ ยฌ P โ P`
#. ยง1: `Classical`
#. ยง2: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Lean has a built-in name ยง0 for this implication, which is also called *double negation elimination*. In the source files for Classical World, we have told that we want to use classical reasoning (by opening the ยง1 namespace), which is why typing ยง2 suffices to solve this level."
msgstr ""

#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Negating Existence"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `x = y`
#. ยง2: `x`
#. ยง3: `y`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Once more, ยง0 can also be used to prove propositions of the form ยง1 when ยง2 and ยง3 are equal *by definition* (rather than by a more complicated chain of reasoning)."
msgstr ""

#. ยง0: `Bool`
#. ยง1: `Bool.false`
#: Game.Levels.BooleanWorld.L01_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "There is an element of type ยง0 called ยง1."
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "In the next level, we will see that coproduct types are similarly symmetric."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Composition"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `A`
#. ยง3: `C`
#. ยง4: `g โ f : A โ C`
#. ยง5: `\\circ`
#. ยง6: `โ`
#. ยง7: `g โ f`
#. ยง8: `a : A`
#. ยง9: `f a : B`
#. ยง10: `g (f a) : C`
#. ยง11: `comp : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง12: `g : B โ C`
#. ยง13: `f : A โ B`
#. ยง14: `comp g f : A โ C`
#. ยง15: `g`
#. ยง16: `f`
#. ยง17: `a : A`
#. ยง18: `g (f a) : C`
#. ยง19: `comp`
#. ยง20: `โ`
#. ยง21: `comp g f`
#. ยง22: `g โ f`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Recall that given functions ยง0 and ยง1 there is a *composite function* from ยง2 to\n"
"ยง3 denoted ยง4, using ยง5 to type ยง6.\n"
"\n"
"The function ยง7 is defined to be the function that sends ยง8 first to the element ยง9 and then\n"
"to the element ยง10.\n"
"\n"
"The goal in this level is to define composition as a multivariable function between function types ยง11.\n"
"\n"
"We think often think of composition as the function that takes ยง12 and ยง13 to the composite function ยง14.\n"
"\n"
"But it can also be thought of a function that takes ยง15, ยง16, and ยง17 to the element ยง18.\n"
"\n"
"Aside: Lean treats the functions ยง19 and ยง20 slightly differently because the former uses the usual notation for multivariable functions (where the arguments are provided afterwards as ยง21) while the latter uses infix notation (where the function name appears inbetween the two arguments as ยง22)."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `Sum.inl a : A โ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For any ยง0, there is an element ยง1."
msgstr ""

#. ยง0: `A ร B โ C`
#. ยง1: `A โ B โ C`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `C`
#. ยง5: `f : A ร B โ C`
#. ยง6: `โจa, bโฉ : A ร B`
#. ยง7: `C`
#. ยง8: `g : A โ B โ C`
#. ยง9: `a : A`
#. ยง10: `g a : B โ C`
#. ยง11: `b : B`
#. ยง12: `C`
#. ยง13: `A โ B โ C`
#. ยง14: `A ร B โ C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "We have seen that the types ยง0 and ยง1 both provide a notion of function of two variables, with inputs from the types ยง2 and ยง3 and output in the type ยง4. The difference is that ยง5 is thought of as a function that takes a pair ยง6 to an element of type ยง7, while ยง8 is thought of as a function that takes ยง9 to a function ยง10 (which then takes ยง11 to an element of type ยง12).\n"
"\n"
"The process of converting a function of type  ยง13 to one of type ยง14 is called *uncurrying*. Your task in this level is to define the uncurrying function."
msgstr ""

#. ยง0: `0`
#. ยง1: `0`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Here you are asked to show that the value of the function you have just defined at ยง0 equals ยง1."
msgstr ""

#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "The converse implication is classical but not constructive as you will show in the Boss Level."
msgstr ""

#: Game.Levels.TypeWorld.L03_ExactElements
msgid "Exact Elements"
msgstr ""

#. ยง0: `absurd`
#. ยง1: `exact absurd`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "Lean has a built in name ยง0 for the theorem you have just proven, so this level may be solved with ยง1. This has been added to the theorem library."
msgstr ""

#. ยง0: `b : Bool`
#. ยง1: `b = not (not b)`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "For any ยง0, ยง1."
msgstr ""

#. ยง0: `ยซ{A}ยป โ ยซ{A}ยป`
#. ยง1: `x : ยซ{A}ยป`
#. ยง2: `ยซ{A}ยป`
#. ยง3: `intro x`
#. ยง4: `ยซ{A}ยป`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "To define a function, in this case an element of type ยง0, one must define a rule to convert an arbitrary element ยง1 to some element of type ยง2. Start by typing ยง3 to add an arbitrary element of type ยง4 to the context."
msgstr ""

#: Game.Levels.NegationWorld.L11_BossLevel
msgid "Move on to Classical World to better understand the statements involving negation that we have not been able to prove thus far."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Prod.swap : A ร B โ B ร A`
#. ยง3: `โจa, bโฉ`
#. ยง4: `โจb, aโฉ`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "For types ยง0 and ยง1, the function ยง2 can be thought of as the function that sends a pair ยง3 to the pair ยง4."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `x = y`
#. ยง2: `x`
#. ยง3: `y`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "In summary, ยง0 can also be used to prove propositions of the form ยง1 when ยง2 and ยง3 are equal *by definition*, rather than by a more complicated chain of reasoning."
msgstr ""

#: Game.Levels.EqualityWorld
msgid "Equality World"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Where have you seen this construction before? Can you solve this level in a different way?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A ร B`
#. ยง3: `B ร A`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "For any types ยง0 and ยง1, the product types ยง2 and ยง3 are equivalent."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Negation"
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P`
#. ยง2: `P โ ยฌ ยฌ P`
#. ยง3: `P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The *double negation* of a proposition ยง0 is the proposition ยง1.\n"
"\n"
"In this level, we reinterpret the construction from the previous level as a proof that the implication ยง2 is always true, no matter whether or not ยง3 is true."
msgstr ""

#. ยง0: `ยซ{h}ยป.1 : ยซ{P}ยป`
#. ยง1: `ยซ{h}ยป.2 : ยซ{Q}ยป โจ ยซ{R}ยป`
#. ยง2: `have p := ยซ{h}ยป.1`
#. ยง3: `have qr := ยซ{h}ยป.2`
#. ยง4: `p`
#. ยง5: `qr`
#. ยง6: `cases ยซ{h}ยป.2`
#. ยง7: `rcases`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Recall that ยง0 and ยง1. We can introduce these as named variables in the context by typing ยง2 and ยง3 where ยง4 and ยง5 are variable names you get to pick. This allows you to case split on an explicitly named variable. Alternatively, type ยง6, or use ยง7 to name your own variables."
msgstr ""

#. ยง0: `โ m n : โ, succ m = succ n โ m = n`
#. ยง1: `pred : โ โ โ`
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "In this level, we will prove the third Peano axiom using the introduction and elimination rules for the type of natural numbers.\n"
"\n"
"Your objective is to show that the successor function is injective: ยง0.\n"
"\n"
"There are several ways to make use of the function ยง1 to prove this, either by applying results from the library or by stating and proving helpful lemmas."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `ยซ{A}ยป โ ยซ{C}ยป`
#. ยง2: `ยซ{B}ยป โ ยซ{C}ยป`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Now the goal is a product type. The ยง0 tactic will split into two subgoals, defining the functions ยง1 and ยง2 respectively."
msgstr ""

#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Next we will study the relationship between products and coproducts."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f : A โ C`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "If ยง0 and ยง1 are both injective functions, then ยง2 is also injective."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `constructor`
#. ยง2: `fun s โฆ t`
#. ยง3: `S โ T`
#. ยง4: `\\mapsto`
#. ยง5: `โฆ`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "To practice using the syntax for elements of conjunctions, try to solve this level with fewer uses of the ยง0 tactic. In fact, the ยง1 tactic can be avoided entirely by using expressions like ยง2 to prove implications like ยง3, writing ยง4 to type ยง5."
msgstr ""

#. ยง0: `โ x : A, P x`
#. ยง1: `intro x`
#. ยง2: `P x`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "To prove a statement of the form ยง0 start with ยง1. Your goal is then to prove the proposition ยง2."
msgstr ""

#. ยง0: `ยซ{f}ยป : A โ Empty`
#. ยง1: `ยซ{a}ยป : A`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "We have assumptions ยง0 and ยง1? What can you construct using this?"
msgstr ""

#. ยง0: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "The composite of the function ยง0 with itself equals the identity function"
msgstr ""

#. ยง0: `A ร B`
#. ยง1: `B ร A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Product types are symmetric: an element of type ยง0 has a corresponding element of type ยง1 with components swapped."
msgstr ""

#. ยง0: `A`
#. ยง1: `x y : A`
#. ยง2: `x = y`
#. ยง3: `p q : x = y`
#. ยง4: `x`
#. ยง5: `y`
#. ยง6: `p = q`
#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "Given any type ยง0 and any elements ยง1, the *equality type* defines a type ยง2.\n"
"\n"
"This type is also a proposition, meaning that it has at most one element.\n"
"\n"
"Put more precisely, if ยง3 are two proofs that ยง4 equals ยง5, then definitionally we have that ยง6."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty โ A`
#. ยง2: `A โ Empty`
#. ยง3: `A โ B โ C`
#. ยง4: `B โ A โ C`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "Function types are *not* symmetric: when ยง0 is non-empty, the types ยง1 and ยง2 are not equivalent.\n"
"\n"
"However in the case of functions with multiple variables, the input variables can be exchanged.\n"
"\n"
"In this level, you will show that the types ยง3 and ยง4 are equivalent."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `</>`
#. ยง2: `editor mode`
#. ยง3: `>_`
#. ยง4: `typewriter mode`
#. ยง5: `typewriter mode`
#. ยง6: `retry`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "There are two ways to prove that ยง0 under the assumption given below. Can you find them both?\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled ยง1 in the upper right hand corner to enter ยง2. Then delete all the lines of your first proof (or proof attempt). Clicking on ยง3 takes you back to ยง4.\n"
"\n"
"You can also delete a proof attempt in line by line in ยง5 using the ยง6 button to the right of that line."
msgstr ""

#: Game.Levels.QuantifierWorld
msgid "Quantifier World"
msgstr ""

#. ยง0: `exact fun x โฆ x`
#. ยง1: `\\mapsto`
#. ยง2: `โฆ`
#. ยง3: `fun x โฆ x : A โ A`
#. ยง4: `x`
#. ยง5: `x`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "You can solve this level in one line by just giving the entire formula for the function as\n"
"ยง0, using ยง1 to type ยง2. Here ยง3 is Lean syntax for the identity function. This tells Lean that the answer is the function defined on an input element ยง4 to have an output value ยง5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Function Extensionality"
msgstr ""

#. ยง0: `indunction n with k hk`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "To use the principle of mathematical induction, type ยง0."
msgstr ""

#. ยง0: `P`
#. ยง1: `Classical.em P : P โจ ยฌ P `
#. ยง2: `P`
#. ยง3: `ยฌ P`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "For any proposition ยง0, ยง1 proves that ยง2 or ยง3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "This proves the that conjunction distributes over disjunction. A more involved form of distributivity appears in the next level."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "What can you conclude from the hypothesis ยง0?"
msgstr ""

#. ยง0: `rcases`
#. ยง1: `cases`
#. ยง2: `h : P โจ Q`
#. ยง3: `rcases h with p | q`
#. ยง4: `cases h`
#. ยง5: `p : P`
#. ยง6: `q : Q`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "ยง0 is a tactic that will perform ยง1 recursively, according to a pattern. One use is to provide explicit names for variables in each subgoal. For example, given a hypothesis ยง2, ยง3 can be used in place of ยง4 to give hypotheses ยง5 in the first case and ยง6."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `Function.comp : (B โ C) โ (A โ B) โ (A โ C)`
#. ยง4: `C`
#. ยง5: `Function.comp : (B โ Empty) โ (A โ B) โ (A โ Empty)`
#. ยง6: `(A โ B) โ (B โ Empty) โ (A โ Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "In this level, we will revisit the composition function in the presence of the empty type.\n"
"\n"
"Recall that for any types ยง0, ยง1, and ยง2, composition defines a function:\n"
"\n"
"ยง3.\n"
"\n"
"In particular, if ยง4 is the empty type, composition defines a function:\n"
"\n"
"ยง5.\n"
"\n"
"Your task in this level is to define the closely related variant of the composition function which has type:\n"
"\n"
"ยง6\n"
"\n"
"This construction will be analogous to something we will encounter in Negation World."
msgstr ""

#. ยง0: `g : B โ A`
#. ยง1: `g (f ยซ{x}ยป) = ยซ{x}ยป`
#. ยง2: `ยซ{x}ยป : A`
#. ยง3: `apply inj`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "If ยง0 is the name of the inverse function you defined using the axiom of choice, you are now meant to show that ยง1 for an arbitrary element ยง2. Here you can apply the injectivity hypothesis by typing ยง3."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "We've now reached the Boss Level in the Disjunction World.\n"
"\n"
"This level illustrates that proofs by cases can be somewhat delicate.\n"
"\n"
"Have fun!"
msgstr ""

#. ยง0: `A โ (B โ C)`
#. ยง1: `A โ B โ C`
#. ยง2: `(A โ B) โ C`
#. ยง3: `f : A โ B`
#. ยง4: `C`
#. ยง5: `a : A`
#. ยง6: `(A โ B) โ B`
#. ยง7: `a : A`
#. ยง8: `f : A โ B`
#. ยง9: `f a : B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "While an element of type ยง0, more commonly written as ยง1, is a function of two variables, an element of type ยง2 is instead a function that takes a function ยง3 as input and returns an element of type ยง4.\n"
"\n"
"For example, if we are given ยง5, then it is possible to define a function of type ยง6 which is called *evaluation* at ยง7. Given ยง8, we return ยง9.\n"
"\n"
"Your task in this level is to define the evaluation function."
msgstr ""

#. ยง0: `constructor`
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "The goal is a product of function types, so to define an element you need to define two different functions. Each will take some work, so start with the ยง0 tactic to split one goal into two goals."
msgstr ""

#. ยง0: `Empty โ (Empty โ Empty)`
#. ยง1: `(Empty โ Empty) ร (Empty โ Empty)`
#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "There are functions in both directions between the types ยง0 and ยง1."
msgstr ""

#. ยง0: `have : (g โ f) ยซ{a}ยป = ? := rfl`
#. ยง1: `?`
#. ยง2: `rw [โ ?]`
#. ยง3: `\\l`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "You can either prove a lemma ยง0 by replacing the ยง1 with the definition of the composition function. Or you can try ยง2 for an appropriate proof of equality using ยง3 to type the left arrow."
msgstr ""

#. ยง0: `g : X โ A`
#. ยง1: `h : X โ A`
#. ยง2: `X`
#. ยง3: `A ร B`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "A pair of functions ยง0 and ยง1 may be combined into a single function from ยง2 to the product type ยง3."
msgstr ""

#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "If this was too easy, you might find it interesting to learn that the general problem of identifying whether a formula in conjunctive normal form is satisfiable is NP complete! Move on to Quantifier World to meet the universal and existential quantifiers."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Try applying the hypothesis ยง0."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `x : A`
#. ยง3: `B`
#. ยง4: `A โ B`
#. ยง5: `intro x`
#. ยง6: `x : A`
#. ยง7: `B`
#. ยง8: `A โ B`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: `intro`
#. ยง12: `A`
#. ยง13: `id : A โ A`
#. ยง14: `a : A`
#. ยง15: `Show more help!`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The *introduction rule* for function types explains how functions may be constructed.\n"
"\n"
"To define a function from a type ยง0 to a type ยง1 one has the following obligation: for an arbitrary element ยง2 of the first type &mdash; a potential *input* to the function &mdash; one must specify an element of type ยง3 &mdash; the corresponding *output*.\n"
"\n"
"When the goal is a function type ยง4, start by typing ยง5 to add an arbitrary element ยง6 to the context and update the goal to a term of type ยง7.\n"
"\n"
"In other words, one specifies a function of type ยง8 by giving a formula that converts an arbitrary input element of type ยง9 into its corresponding output element of type ยง10.\n"
"\n"
"Using the ยง11 tactic &mdash; which is now in the tactic library &mdash; plus the tactics introduced in Type World, you should be able to define your first function.\n"
"\n"
"The identity function is a simple but important example of a function that may be defined for any type ยง12. The identity function, denoted ยง13, is defined to carry any element ยง14 to itself.\n"
"\n"
"The goal in this level is to define this function.\n"
"\n"
"If you need help, click the button ยง15 for reminders/hints."
msgstr ""

#. ยง0: `f : A ร B โ C`
#. ยง1: `a : A`
#. ยง2: `b : B`
#. ยง3: `C`
#. ยง4: `f โจa,bโฉ`
#. ยง5: `g : A โ B โ C`
#. ยง6: `g`
#. ยง7: `a : A`
#. ยง8: `b : B`
#. ยง9: `C`
#. ยง10: `g a b : C`
#. ยง11: `A ร B โ C`
#. ยง12: `A โ B โ C`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `C`
#. ยง16: `f : A ร B โ C`
#. ยง17: `โจa, bโฉ : A ร B`
#. ยง18: `C`
#. ยง19: `g : A โ B โ C`
#. ยง20: `a : A`
#. ยง21: `g a : B โ C`
#. ยง22: `b : B`
#. ยง23: `C`
#. ยง24: `A ร B โ C`
#. ยง25: `A โ B โ C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Consider a function ยง0 mapping out of a product type.\n"
"\n"
"This function takes an ordered pair of elements &mdash; defined from ยง1 and ยง2 &mdash; and returns an element of type ยง3 denoted by ยง4. Does this sound familiar?\n"
"\n"
"Recall that terms of type ยง5 are functions of two variables.\n"
"\n"
"The function ยง6 takes a list of two elements ยง7 and ยง8 and returns an element of type ยง9 denoted by ยง10.\n"
"\n"
"In summary, the types ยง11 and ยง12 both provide a notion of function of two variables, with inputs from the types ยง13 and ยง14 and output in the type ยง15.\n"
"\n"
"The difference is that ยง16 is thought of as a function that takes a pair ยง17 to an element of type ยง18, while ยง19 is thought of as a function that takes ยง20 to a function ยง21 (which then takes ยง22 to an element of type ยง23).\n"
"\n"
"The process of converting a function of type ยง24 to one of type ยง25 is called *currying*. Your task in this level is to define the currying function."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `Q โง P`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "ยง0 is true if and only if ยง1 is true."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ A`
#. ยง2: `(โ a : A, g (f a) = a) โง (โ b : B, f (g b) = b)`
#. ยง3: `g : B โ A`
#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "Suppose ยง0 is an invertible function.\n"
"\n"
"This means that there exists a function ยง1 so that ยง2.\n"
"\n"
"In this level, we will see that the inverse function ยง3 is itself invertible."
msgstr ""

#. ยง0: `1 + 5 = 2 * 3`
#. ยง1: `succ (succ (succ (succ (succ (succ 0))))`
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "More complicated arithmetic equations involving numerals also hold by definition: for example ยง0\n"
"\n"
"This is because these elements on both the left-hand and right-hand sides reduce to a common *normal form*, an explicit numeral of the form ยง1."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty.elim : Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type ยง0, there is a function ยง1 expressing the elimination rule of the empty type."
msgstr ""

#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "To Empty"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โจ Q) โจ R`
#. ยง4: `P โจ (Q โจ R)`
#. ยง5: `P โจ Q โจ R`
#. ยง6: `P โจ (Q โจ R)`
#. ยง7: `hโ : (P โจ Q) โจ R`
#. ยง8: `cases hโ`
#. ยง9: `P โจ Q`
#. ยง10: `R`
#. ยง11: `hโ : P โจ Q โจ R`
#. ยง12: `cases hโ`
#. ยง13: `P`
#. ยง14: `Q โจ R`
#. ยง15: `rcases`
#. ยง16: `hโ : (P โจ Q) โจ R`
#. ยง17: `rcases hโ with (p | q) | r`
#. ยง18: `hโ : P โจ Q โจ R`
#. ยง19: `rcases hโ with p | q | r`
#. ยง20: `\\7`
#. ยง21: `โ`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Similarly, for propositions ยง0, ยง1, and ยง2, ยง3 holds if and only if ยง4 holds.\n"
"\n"
"Similarly to the conventions used for products, conjunctions, and coproducts, Lean uses ยง5 as an abbreviation for ยง6.\n"
"\n"
"Given a hypothesis ยง7, ยง8 will split the hypothesis into two cases: one assuming that ยง9 is true and the other assuming ยง10 is true.\n"
"\n"
"Similarly given a hypothesis ยง11, ยง12 the hypothesis into two cases: one assuming that ยง13 is true and the other assuming ยง14 is true.\n"
"\n"
"Note the ยง15 tactic allows more general patterns of disjunctions. Given ยง16 try ยง17. Similarly, given ยง18, try ยง19.\n"
"\n"
"Aside: Typing ยง20 using any single digit number produces a subscript with that number, like ยง21. You can use this if you'd like to use numerical subscripts in your variable names."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Define the uncurrying function, convering a function of two variables into a function out of a product type."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "Invertible Implies Bijective"
msgstr ""

#. ยง0: `use ??`
#. ยง1: `??`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Type ยง0 with a well-chosen element in place of the ยง1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Associativity"
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "Pairing"
msgstr ""

#. ยง0: `False`
#. ยง1: `p : P`
#. ยง2: `P`
#. ยง3: `False`
#. ยง4: `P`
#. ยง5: `P โ False`
#. ยง6: `P`
#. ยง7: `ยฌ P`
#. ยง8: `ยฌ P`
#. ยง9: `P`
#. ยง10: `p : P`
#. ยง11: `False`
#. ยง12: `False`
#. ยง13: `P`
#: Game.Levels.NegationWorld
msgid "In this world, we will study the proposition ยง0 and the logical operation of *negation*.\n"
"\n"
"Recall that an element ยง1 of a proposition ยง2 may be thought of as a proof that the proposition is true. We do not have any proofs of the proposition ยง3, so it does not contain any elements.\n"
"\n"
"For any proposition ยง4, we define its *negation* to be the proposition ยง5, pronounced &ldquo;ยง6 implies false&rdquo;. This is commonly abbreviated with the shorthand ยง7, pronounced &ldquo;not P&rdquo;.\n"
"\n"
"A *proof of negation* means a proof of a proposition of the form ยง8 for some proposition ยง9.\n"
"\n"
"Using the introduction rule for implications, such a proof starts by assuming ยง10 and then deriving an element of ยง11.\n"
"\n"
"Since ยง12 has no elements, we think of this process as deriving a contradiction.\n"
"\n"
"There is a related technique called *proof by contradiction* for proving that ยง13 is true that will be discussed in Classical World, as one of the proof strategies that is available when reasoning non-constructively.\n"
"\n"
"By contrast, a proof of negation is constructive, as it is analogous to the construction of a function between types, as we saw in Empty World."
msgstr ""

#. ยง0: `h`
#. ยง1: `a`
#. ยง2: `exact h a`
#. ยง3: `apply h`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "To apply the proof ยง0 at the specific element ยง1, type ยง2. Alternatively, you can start with ยง3."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#. ยง1: `false`
#. ยง2: `true`
#. ยง3: `true`
#. ยง4: `false`
#. ยง5: `b : Bool`
#. ยง6: `b = not (not b)`
#. ยง7: `not b`
#. ยง8: `b`
#. ยง9: `false`
#. ยง10: `true`
#. ยง11: `! b`
#. ยง12: `not b`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "In the last level, we defined the negation function\n"
"ยง0 which sends the element ยง1 to ยง2 and ยง3 to ยง4.\n"
"\n"
"The negation has the property that for any boolean ยง5, ยง6.\n"
"\n"
"Interestingly the proof is not by reflexivity! This is because we only defined ยง7 to have a particular value when ยง8 is one of the elements ยง9 or ยง10.\n"
"\n"
"See if this is enough of a hint to solve this level.\n"
"\n"
"Note Lean has an alternate notation ยง11 for ยง12."
msgstr ""

#. ยง0: `A โ B โ B โ A`
#. ยง1: `cases`
#. ยง2: `rcases`
#. ยง3: `A โ B`
#. ยง4: `left`
#. ยง5: `right`
#. ยง6: `B โ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The coproduct type, like the product type, is *symmetric*, and in particular has a canonical map of type ยง0. Your task in this level is to define it.\n"
"\n"
"Use the elimination rule for coproduct types and the associated tactics ยง1 or ยง2 to map out of the type ยง3.\n"
"\n"
"Then use the introduction rules for coproduct types and the associated tactics ยง4 and ยง5 to map into the type ยง6."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `(A โ B) โ C`
#. ยง4: `A โ (B โ C)`
#. ยง5: `(A โ B) โ C`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `C`
#. ยง9: `A โ (B โ C)`
#. ยง10: `A โ B โ C`
#. ยง11: `A โ (B โ C)`
#. ยง12: `f : A โ B โ C`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `C`
#. ยง16: `f`
#. ยง17: `A`
#. ยง18: `B โ C`
#. ยง19: `f : A โ B โ C`
#. ยง20: `a : A`
#. ยง21: `f a : B โ C`
#. ยง22: `B`
#. ยง23: `C`
#. ยง24: `b : B`
#. ยง25: `f a`
#. ยง26: `f a b : C`
#. ยง27: `exact`
#. ยง28: `apply`
#. ยง29: `intro`
#. ยง30: `intro`
#. ยง31: `exact`
#. ยง32: `apply`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Function types can be iterated.\n"
"\n"
"In particular, given types ยง0, ยง1, and ยง2, we may form the function types ยง3 and ยง4. These types are not the same!\n"
"\n"
"Elements of the type ยง5 are functions that take a function from ยง6 to ยง7 as input and return an element of type ยง8 as output. Functions of this form exist but they are relatively obscure.\n"
"\n"
"By contrast, elements of the type ยง9 are *multivariable functions*, which take more than one input before returning an output. As these are relatively common, the simplified notation ยง10 is used as an abbreviation for the type ยง11.\n"
"\n"
"A multivariable function ยง12 takes a first input from type ยง13 and a second input from type ยง14 before returning an output of type ยง15.\n"
"\n"
"The element ยง16 may also be thought of as a function that takes an element of type ยง17 and returns a of type ยง18.\n"
"\n"
"Given ยง19 and ยง20, then ยง21 is a function from ยง22 to ยง23.\n"
"\n"
"Then given ยง24 we can apply the function ยง25 to get an element ยง26.\n"
"\n"
"In this level, you are given a multivariable function together with an element from its first input type. You are asked to define a function of the appropriate function type.\n"
"\n"
"This level can be solved by starting with ยง27, starting with ยง28, or starting with ยง29. If you start with ยง30, then you can continue with ยง31 or with ยง32. If this is your first time solving this level, try to find a different solution."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "If this is your first time solving this level, go back and solve it another way."
msgstr ""

#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "Multiple Quantifiers"
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "Defining Addition"
msgstr ""

#. ยง0: `intro g f`
#. ยง1: `intro g f a`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "To define a function with multiple variables you can apply the intro tactic twice, for instance by typing ยง0 or even ยง1."
msgstr ""

#. ยง0: `Sum.inl`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "If your answer does not use the function ยง0, you might have fun trying to solve this level again using it in an appropriate place."
msgstr ""

#. ยง0: `have lemP : P โจ ยฌ P := em P`
#. ยง1: `P โจ ยฌ P`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "To use the law of excluded middle in your proof, type ยง0 to add an assumption that ยง1 is true."
msgstr ""

#. ยง0: `ยซ{Q}ยป โจ ยซ{P}ยป`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that Lean provides two goals, both of which are to prove that ยง0 is true, under two different hypothesies. Your first task is to prove the theorem in the first case."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Universal Property"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Injectivity"
msgstr ""

#. ยง0: `ยซ{eq}ยป`
#. ยง1: `have neq : ยฌ (true = false) := Bool.noConfusion`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "To get the contradiction, you should now add a proof of the negation of ยง0. You can do this with ยง1."
msgstr ""

#. ยง0: `P`
#. ยง1: `A`
#. ยง2: `P : A โ Prop`
#. ยง3: `A`
#. ยง4: `P`
#. ยง5: `x : A`
#. ยง6: `P x : Prop`
#. ยง7: `Prime : โ โ Prop`
#. ยง8: `n : โ`
#. ยง9: `n`
#. ยง10: `n`
#. ยง11: `n`
#. ยง12: `A`
#. ยง13: `= : A โ A โ Prop`
#. ยง14: `x y : A`
#. ยง15: `x = y`
#. ยง16: `x`
#. ยง17: `y`
#. ยง18: `P : A โ Prop`
#. ยง19: `A`
#. ยง20: `โ`
#. ยง21: `โ x : A, P x`
#. ยง22: `P a`
#. ยง23: `a : A`
#. ยง24: `โ`
#. ยง25: `โ x : A, P x`
#. ยง26: `a : A`
#. ยง27: `P a`
#. ยง28: `โ`
#. ยง29: `โ`
#: Game.Levels.QuantifierWorld
msgid "The statements of many mathematical propositions require the use of *variables* drawn from previously-defined types.\n"
"\n"
"A *predicate* ยง0 on a type ยง1 is a function ยง2 from ยง3 to the type of propositions.\n"
"\n"
"We also refer to a predicate ยง4 as a *family of propositions* or an *indexed family of propositions* because for each element ยง5, we have a proposition ยง6.\n"
"\n"
"For example, ยง7 is a predicate that sends ยง8 to the statement &ldquo;ยง9 is prime&rdquo;. For certain values of ยง10 this is a true predicate while for other values of ยง11 this is a false predicate.\n"
"\n"
"Predicates may also depend on multiple variables. For example the equality type on ยง12 defines a function ยง13 sending ยง14 to the proposition ยง15. For certain values of ยง16 and ยง17 this is a true proposition, while for other values it may be a false proposition.\n"
"\n"
"There are two general ways to turn an arbitrary predicate ยง18 into a proposition which no longer depends on the value of a variable of type ยง19.\n"
"\n"
"The first method uses the *universal quantifier* ยง20:\n"
"ยง21 is the proposition that asserts that ยง22 is true for every ยง23\n"
"\n"
"The second method uses the *existential quantifier* ยง24:\n"
"ยง25 is the proposition that asserts that there is some ยง26 so that ยง27 is true.\n"
"\n"
"In this world, we will learn how to prove propositions and use hypotheses involving the *universal quantifier* ยง28 and *existential quantifier* ยง29."
msgstr ""

#: Game.Levels.TypeWorld.L01_Elements
msgid "Elements"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `x y : A`
#. ยง2: `p : x = y`
#. ยง3: `f`
#. ยง4: `f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Suppose ยง0 is a function.\n"
"\n"
"Let ยง1 be elements and suppose ยง2.\n"
"\n"
"Then part of what it means for the function ยง3 to be *well-defined* is that ยง4.\n"
"\n"
"Can you prove this?"
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `โ y : B, โ x : A, f x = y`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "A function ยง0 is *surjective* if ยง1."
msgstr ""

#. ยง0: `A ร B โ B ร A`
#. ยง1: `A ร B`
#. ยง2: `B ร A`
#. ยง3: `p : A ร B`
#. ยง4: `p.1 : A`
#. ยง5: `p.2 : B`
#. ยง6: `B ร A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The product type comes with function of type ยง0 which swaps the elements of an ordered pair.\n"
"\n"
"This function can be defined by using the elimination rule for product types to map out of ยง1 followed by the introduction rule for product types to map into ยง2.\n"
"\n"
"The swap function can be defined by introducing a variable ยง3, projecting to its components ยง4 and ยง5, then reassembling these to give an element of type ยง6.\n"
"\n"
"Can you define this function?"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Prod.fst : A ร B โ A`
#. ยง3: `p : A ร B`
#. ยง4: `p.1 : A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "For any types ยง0 and ยง1, ยง2 is the function that sends ยง3 to its first coordinate ยง4."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q โ R`
#. ยง3: `R`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "If ยง0 is true, ยง1 is true, and ยง2 is true, then ยง3 is true."
msgstr ""

#. ยง0: `ยซ{P}ยป โจ (ยซ{Q}ยป โจ ยซ{R}ยป)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Here the goal is parenthesized as ยง0. Using your hypothesis, are you trying to prove the left-hand proposition or the right-hand one?"
msgstr ""

#. ยง0: `False`
#. ยง1: `have := ยซ{np}ยป ยซ{p}ยป`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If you like, you can add a proof of ยง0 to your assumption list by ยง1."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `g : B โ C`
#. ยง2: `g โ f`
#. ยง3: `g`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "For functions ยง0 and ยง1 if ยง2 is surjective, then so is ยง3."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `f : A โ B โ C`
#. ยง2: `B โ C`
#. ยง3: `f`
#. ยง4: `a`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Given an element ยง0 and a function of two variables ยง1, define a function from ยง2 by evaluating the first variable of ยง3 at the element ยง4."
msgstr ""

#. ยง0: `ยซ{hyp}ยป`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What proof technique is available when you have a hypothesis like ยง0?"
msgstr ""

#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "By Contradiction"
msgstr ""

#. ยง0: `ยฌ Q โ ยฌ P`
#. ยง1: `P โ Q`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "In classical logic, ยง0 implies ยง1."
msgstr ""

#. ยง0: `p : A ร B`
#. ยง1: `intro p`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Now Lean wants you to check that the second function followed by the first function yields the identity function at every element ยง0. Start with ยง1."
msgstr ""

#. ยง0: `assumption`
#. ยง1: `A`
#. ยง2: `A`
#: Game.Levels.TypeWorld.L01_Elements
msgid "Type ยง0 to tell Lean to use the assumed element of ยง1 to define an element of ยง2."
msgstr ""

#. ยง0: `exact fun f โฆ โจf โ Sum.inl, f โ Sum.inrโฉ`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "This level can be solved in one line with ยง0. Can you make sense of this construction?"
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "A function into a product type has a pair of component functions."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "In summary, a basic axiom of equality is *reflexivity*:\n"
"for any ยง0, ยง1 is always true."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If this is your first time solving this level, delete your proof, and try to find another solution."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "We will now study properties that hold of some functions, but not all functions."
msgstr ""

#. ยง0: `P`
#. ยง1: `P โ Q`
#. ยง2: `Q`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "If ยง0 is true and ยง1 is true, then ยง2 is true."
msgstr ""

#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Transitivity"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Composing Injectivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Product With Empty"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Recall arithmetical equations involving numerals can be proven with ยง0."
msgstr ""

#. ยง0: `exact`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "The goal is an implication you've already proven. You can use ยง0 together with the name of that result, to solve this goal in one line. Alternatively, you can just prove it again."
msgstr ""

#. ยง0: `apply f`
#. ยง1: `f`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Start with ยง0 to apply the function ยง1 to transform your goal."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "The overall objective here is to prove a conjunction. Which tactic can help break this up into simpler statements?"
msgstr ""

#. ยง0: `exact ยซ{p}ยป`
#. ยง1: `ยซ{p}ยป`
#. ยง2: `ยซ{P}ยป`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Type ยง0 to tell Lean that ยง1 is a proof of ยง2."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A ร B`
#. ยง3: `A ร B โ B ร A`
#. ยง4: `B ร A โ A ร B`
#. ยง5: `A ร B`
#. ยง6: `B ร A`
#. ยง7: `constructor`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Recall that for any types ยง0 and ยง1, we may form their *product type* ยง2.\n"
"\n"
"We proved that there are canonical functions ยง3 and ยง4.\n"
"\n"
"In this level, we will see that these functions define an equivalence between the type ยง5 and the type ยง6. This gives a more complete account of the symmetry of the product.\n"
"\n"
"To define this equivalence, we need four pieces of data. Start by typing ยง7 to tell Lean to ask you to supply each piece of data one at a time."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The goal is to prove an implication. What tactic can be used to get started?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "An invertible function is bijective."
msgstr ""

#. ยง0: `Or`
#. ยง1: `P`
#. ยง2: `P โจ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Look at the theorems about ยง0 if you have forgotten how to tell Lean about the relationship between ยง1 and ยง2."
msgstr ""

#. ยง0: `intro`
#. ยง1: `P โ Q`
#. ยง2: `intro p`
#. ยง3: `p : P`
#. ยง4: `Q`
#. ยง5: `P โ Q โ R`
#. ยง6: `intro p q`
#. ยง7: `p : P`
#. ยง8: `q : Q`
#. ยง9: `R`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The ยง0 tactic, short for *introduction*, is used to introduce one or more hypotheses when the goal is a function type or an implication. It can be used by itself or followed by names for those hypotheses. For example, when the goal is ยง1, type ยง2 to add an assumption ยง3 and update the goal to ยง4. When the goal is ยง5, type ยง6 to add assumptions ยง7 and ยง8 and update the goal to ยง9."
msgstr ""

#. ยง0: `Nat.add_zero : โ n : โ, n + 0 = n`
#. ยง1: `Nat.add_succ : โ m n : โ, m + succ n = succ (m + n)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The theorems ยง0 and ยง1 are now in your library for later use."
msgstr ""

#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Through Empty"
msgstr ""

#. ยง0: `x y : A`
#. ยง1: `p q : x = y`
#. ยง2: `p = q`
#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "The equality type is a proposition: for ยง0 if ยง1 then ยง2"
msgstr ""

#. ยง0: `ยซ{hc}ยป`
#. ยง1: `cases ยซ{hc}ยป`
#. ยง2: `rcases ยซ{hc}ยป with โจa, haโฉ`
#. ยง3: `let โจa, haโฉ = ยซ{hc}ยป`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "To break down the hypothesis ยง0 try ยง1 or ยง2 or ยง3."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#. ยง3: `P โ False`
#. ยง4: `ยฌ P`
#. ยง5: `P`
#. ยง6: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "Given a proposition ยง0, the *negation* of ยง1 &mdash; abbreviated ยง2 &mdash; is defined to be the proposition ยง3.\n"
"\n"
"If we have a proof of ยง4 and also a proof of ยง5 then we get something very strange: a proof of ยง6!\n"
"\n"
"This can be expressed in various different ways, as we shall see over the next few levels.\n"
"\n"
"In this level, we encode this statement in the way that allows for the simplest proof.\n"
"\n"
"In subsequent levels, we shall express this tautology in several logically equivalent forms."
msgstr ""

#. ยง0: `12 + 23 = 5 * (4 + 3)`
#. ยง1: `rfl`
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Arithmetic equations involving explicit numerals such as ยง0 hold by ยง1."
msgstr ""

#. ยง0: `ยซ{f}ยป`
#: Game.Levels.ProductWorld.L06_Currying
msgid "What sort of inputs does the function ยง0 require?"
msgstr ""

#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "As an extra challenge, can you solve this level by appealing to the law of excluded middle only once? Alternatively, move on to the Boss Level of Classical World."
msgstr ""

#. ยง0: `b`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Now you are asked to prove a special case of the indexed family of propositions, where the indexing element ยง0 is specialized to the element you provided."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Canceling Injectivity"
msgstr ""

#. ยง0: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "How can we apply the hypothesis ยง0?"
msgstr ""

#. ยง0: `ยซ{np}ยป : P โ False`
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "We have an assumption ยง0. What can be done with a proof of implication?"
msgstr ""

#. ยง0: `ยฌ (P โ Q)`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `P`
#. ยง6: `Q`
#. ยง7: `P โง ยฌ Q`
#. ยง8: `ยฌ (P โ Q)`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `P โ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "In this level, we will study the proposition ยง0.\n"
"\n"
"How would we disprove the implication ยง1?\n"
"\n"
"What does it mean for ยง2 to be false?\n"
"\n"
"The implication asserts that if ยง3 is true then ยง4 must be true as well.\n"
"\n"
"So if we show that ยง5 is true but ยง6 is false, this would disprove the implication.\n"
"\n"
"In this level, we will prove that ยง7 implies ยง8. That is, if ยง9 is true and ยง10 is false, then ยง11 is not true."
msgstr ""

#. ยง0: `P`
#. ยง1: `False.elim : False โ P`
#. ยง2: `False`
#. ยง3: `P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition ยง0, ยง1 proves that ยง2 implies ยง3."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "The tactic ยง0 tries to solve a goal whose type is an equality where the left hand side and right hand side are equal by definition."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "Total Functions"
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Define the canonical function projecting from a product type to its second argument."
msgstr ""

#. ยง0: `f : A โ B`
#. ยง1: `x y : A`
#. ยง2: `f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Functions are well-defined: if ยง0 and ยง1 are equal, then ยง2."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#. ยง1: `false`
#. ยง2: `true`
#. ยง3: `true`
#. ยง4: `false`
#. ยง5: `b = not (not b)`
#. ยง6: `b : Bool`
#. ยง7: `id = not โ not`
#. ยง8: `Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Recall the function ยง0 that is defined to send the boolean ยง1 to ยง2 and to send the boolean ยง3 to ยง4.\n"
"\n"
"In Boolean World, we proved that ยง5 for any boolean ยง6.\n"
"\n"
"In this level, we will apply that result to prove that ยง7 as functions ยง8."
msgstr ""

#. ยง0: `have pq : P โจ Q := ยซ{h}ยป.1`
#. ยง1: `ยซ{h}ยป`
#. ยง2: `rcases ยซ{h}ยป with โจp | q, r | sโฉ`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Try ยง0 to start to break apart the hypothesis ยง1. Alternatively, ยง2 will break out both the components and the cases associated to this hypothesis."
msgstr ""

#. ยง0: `ยซ{np}ยป`
#: Game.Levels.NegationWorld.L05_Absurd
#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What is the logical structure of the type of ยง0?"
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Induction"
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `ยฌ P`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In classical logic, for any proposition ยง0, ยง1 is true or ยง2 is true."
msgstr ""

#: Game.Levels.EquivalenceWorld
msgid "Equivalence World"
msgstr ""

#. ยง0: `P : A โ Prop`
#. ยง1: `โ x : A, P x`
#. ยง2: `a : A`
#. ยง3: `P a`
#. ยง4: `โ x : A, P x`
#. ยง5: `โจa, p_aโฉ`
#. ยง6: `a : A`
#. ยง7: `p_a : P a`
#. ยง8: `P a`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "For a family of propositions ยง0, ยง1 is the proposition that asserts that there is some element ยง2 so that ยง3 is true. An element of ยง4 may be thought of as a *dependent pair* ยง5 where the first component specifies an element ยง6 while the second component specifies a proof ยง7 of the corresponding proposition ยง8."
msgstr ""

#. ยง0: `A`
#. ยง1: `A โ A โ Prop`
#. ยง2: `x y : A`
#. ยง3: `x = y`
#. ยง4: `โ x`
#. ยง5: `โ x`
#. ยง6: `โ y`
#. ยง7: `โ y`
#. ยง8: `x`
#. ยง9: `y`
#. ยง10: `โ x, โ y, x = y โ โ y, โ x, x = y`
#. ยง11: `โ x, โ y, x = y โ โ x, โ y, x = y`
#. ยง12: `x = y โ y = x`
#. ยง13: `โ x, โ y, x = y โ โ y, โ x, x = y`
#. ยง14: `โ x, โ y, x = y โ โ y, โ x, x = y`
#. ยง15: `โ x : A, โ y : A, x = y`
#. ยง16: `โ x : A, โ y : A, x = y`
#. ยง17: `โ x : A, โ y : A, x = y`
#. ยง18: `โ x : A, โ y : A, x = y`
#. ยง19: `โ x : A, โ y : A, x = y`
#. ยง20: `A`
#. ยง21: `a : A`
#. ยง22: `โ x : A, โ y : A, x = y`
#. ยง23: `A`
#. ยง24: `A`
#. ยง25: `A`
#. ยง26: `x y : A`
#. ยง27: `โ x : A, โ y : A, x = y`
#. ยง28: `A`
#. ยง29: `A`
#. ยง30: `A`
#. ยง31: `A`
#. ยง32: `x : A`
#. ยง33: `y : A`
#. ยง34: `x`
#. ยง35: `โ x : A, โ y : A, x = y`
#. ยง36: `A`
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "Any type ยง0 has a family of propositions ยง1 given by the equality types.\n"
"\n"
"For ยง2, we have the proposition ยง3.\n"
"\n"
"Using the universal and existential quantifiers we can form eight different propositions:\n"
"\n"
"* We can choose either ยง4 or ยง5.\n"
"* We can choose either ยง6 or ยง7.\n"
"* We can put the quantifier involving ยง8 before or after the quantifier involving ยง9.\n"
"\n"
"When we have two existential quantifiers or two universal quantifiers, the order doesn't matter, so we have logical equivalences\n"
"\n"
"* ยง10\n"
"* ยง11\n"
"\n"
"In this case, since ยง12, we have further logical equivalences\n"
"\n"
"* ยง13\n"
"* ยง14\n"
"\n"
"The four statements\n"
"* ยง15\n"
"* ยง16\n"
"* ยง17\n"
"* ยง18\n"
"have very different meanings.\n"
"\n"
"The statement ยง19 asserts that the type ยง20 is *inhabited* meaning has an element ยง21.\n"
"Whenever such an element exists, this statement is true, but for the empty type, this statement is false.\n"
"\n"
"The statement ยง22 asserts that the type ยง23 is a *proposition*. When ยง24 is empty this is true (as there is nothing to prove). When ยง25 is a true proposition, it is also true, because any two proofs ยง26 are equal.\n"
"\n"
"The statement ยง27 asserts that the type ยง28 is a true proposition, or equivalently, that the type ยง29 is *contractible*. When ยง30 is empty, this statement is false, but when ยง31 is a true proposition, it has some proof ยง32 and any other proof ยง33 is equal to ยง34.\n"
"\n"
"The final statement ยง35 is just true for any type ยง36. Your objective in this level is to prove this."
msgstr ""

#. ยง0: `cases ยซ{x}ยป`
#. ยง1: `rcases ยซ{x}ยป with a | b`
#. ยง2: `ยซ{x}ยป : A โ B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use either ยง0 or ยง1 to consider the possible cases for the variable ยง2."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `p`
#. ยง3: `P`
#. ยง4: `h`
#. ยง5: `P โ Q`
#. ยง6: `Q`
#. ยง7: `h`
#. ยง8: `p`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now we are in the setting of two proposition variables ยง0 and ยง1 with two hypotheses. The first assumption provides a proof ยง2 that the proposition ยง3 is true. The second provides a proof ยง4 that the implication ยง5 is true.\n"
"\n"
"It follows from both of these facts that ยง6 is also true and we can construct a proof by applying the hypothesis ยง7 to the proof ยง8.\n"
"\n"
"This line of reasoning has the Latin name *modus ponens*."
msgstr ""

#. ยง0: `intro p`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Start with ยง0."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Proving Implication"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P`
#. ยง3: `Q`
#. ยง4: `P โ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "For any propositions ยง0 and ยง1, if ยง2 is true and ยง3 is false, then ยง4 is not true."
msgstr ""

#. ยง0: `m`
#. ยง1: `n`
#. ยง2: `m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "Using the theorems we have proven so far, we can now prove a serious theorem about the natural numbers, namely the commutativity of addition.\n"
"\n"
"That is, we will show that for all natural numbers ยง0 and ยง1, ยง2.\n"
"\n"
"This can be proven by induction on either variable, though you may find one variable easier than the other.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `cases ยซ{x}ยป`
#. ยง1: `cases ยซ{y}ยป`
#. ยง2: `cases ยซ{x}ยป <;> cases ยซ{y}ยป`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This result can be proven in cases. Try ยง0 followed by ยง1. You can pass to both cases at once by typing ยง2"
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `f : A โ B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A โ B`
#. ยง7: `A โ B`
#. ยง8: `A โ B`
#. ยง9: `A โ B`
#: Game.Levels.FunctionWorld
msgid "More complicated types can be constructed from previously-defined types by iteratively applying *type forming operations*.\n"
"\n"
"The first and arguably most important of these is the type ยง0 of functions from ยง1 to ยง2. An element ยง3 defines a *function* from ยง4 to ยง5.\n"
"\n"
"In this level, we will explain how to define and use functions. Specifically, we will learn rules that describe:\n"
"\n"
"* How to construct elements of type ยง6.\n"
"* How to use elements of type ยง7 to construct elements of other types.\n"
"\n"
"The rule for defining elements of type ยง8 is called the *introduction rule* for function types. It provides a strategy that can be used when the goal is a function type.\n"
"\n"
"The rule for using elements of type ยง9 is called the *elimination rule* for function types. It provides a strategy that can be used when the context involves an element of a function type."
msgstr ""

#. ยง0: `h : โ x : A, P x`
#. ยง1: `a : A`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "This explains the *elimination rule* for universally quantified statements. Like the elimination for function types, it corresponds to evaluating the proof ยง0 at a specific element ยง1."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Uncurrying"
msgstr ""

#. ยง0: `not`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Lean has a built in name ยง0 for this function. It is now in your library."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "Proving Assumed Implication"
msgstr ""

#. ยง0: `exact`
#. ยง1: `ยซ{f}ยป`
#. ยง2: `apply`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "You can use the tactic ยง0 by supplying ยง1 with two arguments, in the correct order, with spaces in between (but no parentheses). Alternatively you can use the tactic ยง2."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "Canceling Surjectivity"
msgstr ""

#. ยง0: `intro`
#. ยง1: `Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "To prove a universally quantified statement, start with ยง0 to introduce an arbitrary element of type ยง1. "
msgstr ""

#. ยง0: `x y : Bool`
#. ยง1: `or x y = or y x`
#. ยง2: `x || y`
#. ยง3: `or x y`
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "For any booleans ยง0, ยง1, capturing the symmetry of disjunction.\n"
"\n"
"Note Lean has an alternate notation ยง2 for ยง3."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `b : A`
#. ยง4: `A โ B`
#. ยง5: `Sum.inr : B โ A โ B`
#. ยง6: `A โ B`
#. ยง7: `apply Sum.inr`
#. ยง8: `B`
#. ยง9: `right`
#. ยง10: `A โ B`
#. ยง11: `right`
#. ยง12: `B`
#. ยง13: `A โ B`
#. ยง14: `Sum.inr : B โ A โ B`
#. ยง15: `right`
#. ยง16: `B`
#. ยง17: `Sum.inl, Sum.inr : A โ A โ A`
#. ยง18: `A`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types ยง0 and ยง1, the coproduct type ยง2 has two kinds of elements. The second kind can be thought of as copies of elements ยง3 included into the coproduct ยง4 *on the right*.\n"
"\n"
"Lean has a built in function called ยง5, which can now be found in your library.\n"
"\n"
"If the goal is to produce an element of ยง6, typing ยง7 will convert this to a goal of producing an element of ยง8.\n"
"\n"
"The tactic ยง9 has the same effect. When the goal is a coproduct type ยง10, using the tactic ยง11 tells Lean that you plan to provide an element of type ยง12, which should then be converted to an element of type ยง13 by applying the function ยง14. Thus, typing ยง15 will update the goal to type ยง16.\n"
"\n"
"Note that ยง17 are *different functions* (as long as the type ยง18 has at least one element) in a way we will be able to make more precise later."
msgstr ""

#. ยง0: `+ : โ โ โ โ โ`
#. ยง1: `โ`
#. ยง2: `m`
#. ยง3: `m + : โ โ โ`
#. ยง4: `m + 0`
#. ยง5: `m + succ k`
#. ยง6: `k`
#. ยง7: `m + 0 = m`
#. ยง8: `rfl : m + 0 = m`
#. ยง9: `m + succ k`
#. ยง10: `m`
#. ยง11: `k`
#. ยง12: `m + : โ โ โ`
#. ยง13: `m + succ k`
#. ยง14: `m + k`
#. ยง15: `m + succ k = succ (m + k)`
#. ยง16: `rfl : m + succ k = succ (m + k)`
#. ยง17: `k.succ`
#. ยง18: `succ k`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "Addition is a binary function on natural numbers, meaning it has type ยง0.\n"
"\n"
"In Lean, the addition function is defined *by recursion* &mdash; i.e., by the elimination rule for ยง1 or by the constructive form of induction &mdash; on its second variable.\n"
"\n"
"This means that for an arbitrary natural number ยง2 &mdash; the first variable &mdash; we define a function ยง3 by cases, that is by specifying values for\n"
"\n"
"* ยง4 and\n"
"* ยง5 for an arbitrary natural number ยง6.\n"
"\n"
"For the first equation, we define ยง7. Since this is part of the definition of what it means to add zero on the right, we have ยง8.\n"
"\n"
"For the second equation, we must find a formula for ยง9 using ยง10, ยง11, the successor function, and previously defined values of the function ยง12.\n"
"\n"
"In particular, by the time we are looking to calculate ยง13 we have already defined ยง14. So we can use this to give the definition ยง15. Since this is part of the definition of what it means to add zero on the right, we have ยง16.\n"
"\n"
"In this level you are asked to verify the defining equations for the addition function, which is now in your library. Note Lean likes to write ยง17 for ยง18."
msgstr ""

#: Game.Levels.CoproductWorld
msgid "Coproduct World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "Next move on to Coproduct World to learn about another type forming operation, which is in some sense &ldquo;dual&rdquo; to product types."
msgstr ""

#. ยง0: `X โ A ร B`
#. ยง1: `(X โ A) ร (X โ B)`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The *universal property* of the product is the correspondence between functions ยง0 into a product and pairs of functions ยง1.\n"
"\n"
"We are now ready for the Boss Level of Product World."
msgstr ""

#. ยง0: `exact ยซ{p}ยป.1`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Now type ยง0 to return the first projection."
msgstr ""

#. ยง0: `intro`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a still function type, so continue with ยง0."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Have another look at Level 5 of Disjunction World, discussing the universal property of disjunction. How are these statements related?"
msgstr ""

#. ยง0: `h : โ a : A, P a`
#. ยง1: `P : A โ Prop`
#. ยง2: `h.choose : A`
#. ยง3: `h.choose_spec`
#. ยง4: `P (h.choose)`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Given a proof ยง0 for some ยง1, the axiom of choice selects an element\n"
"ยง2. The theorem ยง3 then proves the proposition ยง4."
msgstr ""

#. ยง0: `P`
#. ยง1: `P`
#. ยง2: `P`
#. ยง3: `P`
#. ยง4: `P โจ ยฌ P`
#. ยง5: `Classical.em P  : P โจ ยฌ P`
#. ยง6: `P`
#. ยง7: `em P : P โจ ยฌ P`
#. ยง8: `byContradiction : ยฌ ยฌ P โ P`
#. ยง9: `P`
#. ยง10: `em`
#. ยง11: `em`
#. ยง12: `P`
#. ยง13: `P`
#. ยง14: `Q`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "The *law of excluded middle* asserts that for any proposition ยง0, either ยง1 is true or ยง2 is false.\n"
"\n"
"In other words, for any proposition ยง3, ยง4 is always true.\n"
"\n"
"Lean has a built-in name ยง5 for *the law of excluded middle* at the proposition ยง6. In Classical World, classical reasoning techniques are open, so you can refer to this proof by typing ยง7.\n"
"\n"
"Note that in contrast to ยง8, the proposition ยง9 is an *explicit argument* of the function ยง10. So if you type just ยง11, Lean will ask which proposition you have in mind.\n"
"\n"
"This is because when you are applying proof by contradiction, it is usually clear from context which proposition ยง12 is involved, whereas when you are appealing to the law of excluded middle, this is often not so clear.\n"
"\n"
"See if you can use the law of excluded middle to prove that for any propositions ยง13 and ยง14 one\n"
"of the following four conjunctions holds."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "DeMorgan"
msgstr ""

#. ยง0: `pred : โ โ โ`
#. ยง1: `pred 0 = 0`
#. ยง2: `โ n : โ, pred (succ n) = n`
#. ยง3: `pred โ succ = id`
#. ยง4: `โ`
#. ยง5: `โ`
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "In the previous level you defined the function ยง0 by recursion and proved that it satisfies the properties:\n"
"\n"
"* ยง1 and\n"
"* ยง2.\n"
"\n"
"In this level you are asked to check a closely related property: namely that\n"
"ยง3 as functions from ยง4 to ยง5.\n"
"\n"
"Can you recall how to establish an equality between functions? Revisit the Function Extensionality level of Advanced Function World if you need a reminder."
msgstr ""

#. ยง0: `ext`
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "This is not a definitional equality, so requires the use of function extensionality. Use the tactic ยง0 to reduce this to proving the componentwise equality of functions."
msgstr ""

#. ยง0: `(P โง Q) โง R`
#. ยง1: `P โง (Q โง R)`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Conjunction is associative: ยง0 is true if and only if ยง1 is true."
msgstr ""

#. ยง0: `โง`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the ยง0 is the outermost logical connective. How do you prove conjunctions?"
msgstr ""

#. ยง0: `x = y`
#. ยง1: `y = z`
#. ยง2: `x = z`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Equality is transitive: if ยง0 and ยง1 then ยง2."
msgstr ""

#. ยง0: `ยซ{f}ยป ยซ{x}ยป`
#. ยง1: `exact ยซ{f}ยป ยซ{x}ยป`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "What is the type of the term ยง0? If you're not sure, you can type ยง1 and read the error message to find out."
msgstr ""

#. ยง0: `Prop`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The type ยง0 is the type of propositions."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "Adding Zero"
msgstr ""

#. ยง0: `P`
#. ยง1: `exact ยซ{p}ยป`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now the goal is just to prove ยง0. Type ยง1 to supply this proof."
msgstr ""

#. ยง0: `S โ T`
#. ยง1: `T`
#. ยง2: `S`
#. ยง3: `S`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `P`
#. ยง7: `Q โ P`
#. ยง8: `Q`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "To prove an implication ยง0 one needs to give a construction of a proof of ยง1 from a proof of ยง2. As we will see in the following example, it is not necessary to actually *use* the assumption that ยง3 is true after introducing it.\n"
"\n"
"In this level we will consider two propositions ยง4 and ยง5 and assume that the proposition ยง6 is true.\n"
"\n"
"It follows that ยง7 is true, no matter whether ยง8 is true or false. Can you prove this?"
msgstr ""

#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Conjunction"
msgstr ""

#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "In the next level, we will establish the first of several equivalences involving function types."
msgstr ""

#. ยง0: `apply`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "You have two similar hypothesis. Only one of them applies. Which one is it? Try using the tactic ยง0"
msgstr ""

#. ยง0: `have โจp, nqโฉ := ยซ{pnq}ยป`
#. ยง1: `p`
#. ยง2: `P`
#. ยง3: `nq`
#. ยง4: `ยฌ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "You can use ยง0 to apply the elimination rule for conjunctions to obtain a proof ยง1 of ยง2 and a proof ยง3 of ยง4."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "In the next level, we will introduce another property that holds for some, but not all, functions."
msgstr ""

#. ยง0: `g : B โ C`
#. ยง1: `f : A โ B`
#. ยง2: `g โ f : A โ C`
#. ยง3: `x : A`
#. ยง4: `g (f x)`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions ยง0 and ยง1, define the composite function ยง2 that sends ยง3 to ยง4."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now the goal is a function type. What tactic is used to define functions?"
msgstr ""

#. ยง0: `succ : โ โ โ`
#. ยง1: `n`
#. ยง2: `n + 1`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "An introduction rule for the type of natural numbers defines the *successor function* ยง0, which sends each natural number ยง1 to ยง2. Note,\n"
"however, that formally speaking, addition is defined in terms of the successor and not the other way around."
msgstr ""

#: Game.Levels.TypeWorld.L04_UnitType
msgid "Unit Type"
msgstr ""

#. ยง0: `h : S โ T`
#. ยง1: `apply h`
#. ยง2: `T`
#. ยง3: `S`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "In the presence of a hypothesis ยง0, the tactic ยง1 reduces the problem of proving ยง2 to the problem of proving ยง3. Can this be used here?"
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Define the canonical function projecting from a product type to its first argument."
msgstr ""

#. ยง0: `S โ X`
#. ยง1: `T โ W`
#. ยง2: `R โ Y`
#. ยง3: `W โ Q`
#. ยง4: `U โ S`
#. ยง5: `Y โ T`
#. ยง6: `X โ V`
#. ยง7: `Q โ U`
#. ยง8: `V โ Z`
#. ยง9: `P โ R`
#. ยง10: `P`
#. ยง11: `Z`
#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "If ยง0, ยง1, ยง2, ยง3, ยง4, ยง5, ยง6, ยง7, ยง8 and ยง9 are true then ยง10 implies ยง11."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Every natural number is even or odd."
msgstr ""

#. ยง0: `P`
#. ยง1: `exfalso`
#. ยง2: `False.elim : False โ P`
#. ยง3: `False`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If the goal is to prove a proposition ยง0, then the tactic ยง1 applies the implication ยง2 to reduce to the goal of proving ยง3."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Can you solve this level in one line?"
msgstr ""

#. ยง0: `f : A โ B โ C`
#. ยง1: `A โ C`
#. ยง2: `B โ C`
#. ยง3: `g : A โ C`
#. ยง4: `h : B โ C`
#. ยง5: `A โ B โ C`
#. ยง6: `x : A โ B`
#. ยง7: `x`
#. ยง8: `Sum.inl a`
#. ยง9: `a : A`
#. ยง10: `x`
#. ยง11: `Sum.inr b`
#. ยง12: `b : B`
#. ยง13: `g`
#. ยง14: `g a : C`
#. ยง15: `h`
#. ยง16: `h b : C`
#. ยง17: `x : A โ B`
#. ยง18: `cases x`
#. ยง19: `x`
#. ยง20: `Sum.inl a`
#. ยง21: `a : A`
#. ยง22: `x`
#. ยง23: `Sum.inr b`
#. ยง24: `b : B`
#. ยง25: `cases`
#. ยง26: `x : A โ B`
#. ยง27: `rcases x with a | b`
#. ยง28: `cases x`
#. ยง29: `a : A`
#. ยง30: `b : B`
#. ยง31: `a`
#. ยง32: `b`
#. ยง33: `cases x`
#. ยง34: `rcases x with a | b`
#. ยง35: `a : A`
#. ยง36: `b : B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "A function ยง0 mapping out of a coproduct type may be *broken apart* into component functions of types ยง1 and ยง2.\n"
"\n"
"Conversely, given an arbitrary pair of functions ยง3 and ยง4, one can build a function of type ยง5.\n"
"\n"
"This function is defined by introducing a variable element ยง6 and then splitting into two cases: the case where ยง7 is of the form ยง8 for some ยง9 and the case where ยง10 is of the form ยง11 for some ยง12.\n"
"\n"
"In the first case, the function ยง13 can be used to define an element ยง14, while in the second case the function ยง15 can be used to define an element ยง16.\n"
"\n"
"Given an element ยง17, type ยง18 to ask Lean to consider both cases arising from the introduction rules for coproduct types: the first being that ยง19 is of the form ยง20 for some ยง21 and the second being that ยง22 is of the form ยง23 for some ยง24.\n"
"\n"
"There is another tactic, similar to ยง25, which allows you to give explicit names for the elements appearing in each case.\n"
"\n"
"Given an element ยง26, then ยง27 can be used in place of ยง28 to provide an element ยง29 in the first case and an element ยง30 in the second. (Here you can choose any variable names for ยง31 and ยง32.)\n"
"\n"
"Either ยง33 or ยง34 can be used to split into the two cases mentioned above.\n"
"\n"
"Both cases will have the same goal type but will have a different context of objects, one of which contains the element ยง35 and the other of which contains the element ยง36."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `b : B`
#. ยง2: `โจa ,bโฉ : A ร B`
#. ยง3: `โจa, bโฉ.fst : A`
#. ยง4: `โจa , bโฉ.snd : B`
#. ยง5: `a`
#. ยง6: `b`
#. ยง7: `โจa, bโฉ.fst = a`
#. ยง8: `โจa, bโฉ.snd = b`
#. ยง9: `rfl`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Now consider elements ยง0 and ยง1.\n"
"\n"
"There is a corresponding pair ยง2 that we can project back to define terms\n"
"ยง3 and ยง4. How do these relate to the original terms ยง5 and ยง6?\n"
"\n"
"Another *computation rule* for product types tells us ยง7 and ยง8 by definition, meaning that ยง9 can provide proofs."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โ B`
#. ยง3: `A โ B โ B โ A`
#. ยง4: `B โ A โ A โ B`
#. ยง5: `A โ B`
#. ยง6: `B โ A`
#. ยง7: `constructor`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Recall that for any types ยง0 and ยง1, we may form their *coproduct type* ยง2.\n"
"\n"
"We proved that there are canonical functions ยง3 and ยง4.\n"
"\n"
"In this level, we will see that these functions define an equivalence between the type ยง5 and the type ยง6. This gives a more complete account of the symmetry of the coproduct.\n"
"\n"
"To define this equivalence, we need four pieces of data. Start by typing ยง7 to tell Lean to ask you to supply each piece of data one at a time."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "Component Functions"
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty`
#. ยง2: `A ร Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "For any type ยง0, there are functions in both directions between the types ยง1 and ยง2."
msgstr ""

#. ยง0: `not : Bool โ Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "The function ยง0 is surjective."
msgstr ""

#. ยง0: `A`
#. ยง1: `Empty โ A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type ยง0, there is a function ยง1 encoding the elimination rule of the empty type."
msgstr ""

#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "We are now ready for the Boss Level of Equality World."
msgstr ""

#. ยง0: `V`
#. ยง1: `F`
#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "We have now reached the Boss Level of Function World, which is considerably more challenging than the Boss Level of Type World. Have fun with this.\n"
"\n"
"We consider an arbitrary pair of types, which we call ยง0 and ยง1 &mdash; for *vector space* and *field* respectively &mdash; because the function to be defined below has a connection to linear algebra that is not explained here.\n"
"\n"
"Can you define it?"
msgstr ""

#. ยง0: `โ x : A, P x`
#. ยง1: `a : A`
#. ยง2: `P a`
#. ยง3: `โ x : A, ยฌ (P x)`
#. ยง4: `โ x : A, ยฌ (P x)`
#. ยง5: `ยฌ (โ x : A, P x)`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "How would you disprove a statement of the form\n"
"\n"
"ยง0?\n"
"\n"
"To do this, it would suffice to find a single ยง1 so that ยง2 is not true.\n"
"\n"
"That is, it would suffice to prove\n"
"\n"
"ยง3.\n"
"\n"
"In this level we will prove ยง4 implies\n"
"ยง5."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Negating Disjunction"
msgstr ""

#. ยง0: `A ร B โ B ร A`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Now Lean wants you to define a function ยง0. You can either define this again or find this function in your library."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Boss level"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `(P โ Q) โ R`
#. ยง4: `P โ (Q โ R)`
#. ยง5: `R`
#. ยง6: `P โ Q`
#. ยง7: `Q โ R`
#. ยง8: `P`
#. ยง9: `R`
#. ยง10: `P`
#. ยง11: `Q`
#. ยง12: `P โ (Q โ R)`
#. ยง13: `P โ Q โ R`
#. ยง14: `P โ (Q โ R)`
#. ยง15: `P โ Q โ R โ S โ T`
#. ยง16: `P โ (Q โ (R โ (S โ T)))`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "For propositions ยง0, ยง1, and ยง2, the propositions ยง3 and ยง4 are not the same.\n"
"\n"
"The first asserts that ยง5 is true assuming ยง6. The second asserts that ยง7 is true assuming ยง8, or equivalently, that ยง9 is true assuming ยง10 and also assuming ยง11.\n"
"\n"
"Mathematical statements of this second form ยง12 are much more common. Thus the shorthand ยง13 implicitly refers to ยง14, not to the other parenthesization.\n"
"\n"
"More generally, ยง15 refers to ยง16.\n"
"\n"
"Explicit parentheses must be used to express statements with any other parenthesizations.\n"
"\n"
"Your objective in this level is to prove the transitivity of implication."
msgstr ""

#. ยง0: `ยฌ (P โง Q)`
#. ยง1: `ยฌ P โง ยฌ Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Combined with what we know already, we have established a logical equivalence between  ยง0 and ยง1 in classical logic."
msgstr ""

#. ยง0: `(P โจ Q) โง (R โจ S)`
#. ยง1: `(P โง R) โจ (P โง S) โจ (Q โง R) โจ (Q โง S)`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "ยง0 holds if and only if ยง1 holds."
msgstr ""

#. ยง0: `a : A`
#. ยง1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For any element ยง0, ยง1 is true by reflexivity."
msgstr ""

#: Game
#: Game
msgid "Reintroduction to Proofs"
msgstr ""

#. ยง0: `Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving`
#: Game
msgid "This was created using the GameSkeleton Github Repo from the Lean Games Server hosted by ADAM: Anticipating the Digital Age of Mathematics at Heinrich Heine University Dรผsseldorf. It was originally designed for a first year seminar course taught at Johns Hopkins University in Fall 2025 with the title ยง0."
msgstr ""

#. ยง0: `โ n : โ, P n`
#. ยง1: `P : โ โ Prop`
#. ยง2: `โ P : โ โ Prop, P 0 โ (โ k : โ, P k โ P (succ k)) โ (โ n : โ, P n)`
#. ยง3: `P`
#. ยง4: `P 0`
#. ยง5: `P k`
#. ยง6: `P (succ k)`
#. ยง7: `k`
#. ยง8: `โ n : โ, P n`
#. ยง9: `โ n : โ, P n`
#. ยง10: `P 0`
#. ยง11: `k : โ`
#. ยง12: `P k`
#. ยง13: `P (succ k)`
#. ยง14: `P 0`
#. ยง15: `P 0 โ P 1`
#. ยง16: `P 1`
#. ยง17: `P 1 โ P 2`
#. ยง18: `P 2`
#. ยง19: `P 2 โ P 3`
#. ยง20: `P 3`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The *principal of mathematical induction* &mdash; also known as the elimination rule for the type of natural numbers &mdash; is a strategy for proving statements of the form\n"
"\n"
"ยง0\n"
"\n"
"where ยง1 is a predicate on the natural numbers &mdash; also known as a family of propositions.\n"
"\n"
"The formal statement of this principle is given by the axiom:\n"
"\n"
"ยง2\n"
"\n"
"In plain language it says\n"
"\n"
"&ldquo;for any predicate ยง3 on the natural numbers, if ยง4 is true, and if ยง5 implies ยง6 for all natural numbers ยง7, then ยง8 is true.&rdquo;\n"
"\n"
"That is, we can prove ยง9 after verifying two things:\n"
"\n"
"* the *base case*: proving that ยง10 is true\n"
"* the *inductive step*: proving that for any ยง11, ยง12 implies ยง13.\n"
"\n"
"By combining these hypothesis, from the fact that ยง14 is true and ยง15 is true, we can conclude that ยง16 is true. Then from the fact that ยง17 is true, we can conclude that ยง18 is true. Then from the fact that ยง19 is true, we can conclude that ยง20 is true. And so on.\n"
"\n"
"In this level, we will use induction to prove that every natural number is even or odd."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌ ยฌ P`
#. ยง2: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "In classical logic, for any proposition ยง0, ยง1 implies ยง2."
msgstr ""

#: Game.Levels.EmptyWorld
msgid "Empty World"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โง ยฌ Q โ ยฌ (P โ Q)`
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "In Negation World, we proved that for any propositions ยง0 and ยง1:\n"
"\n"
"ยง2.\n"
"\n"
"Our aim in this level is to prove the converse implication using classical reasoning.\n"
"\n"
"Good luck!"
msgstr ""

#. ยง0: `let`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The objective of this Boss Level is to define a function that takes five variables as inputs and has three\n"
"variables as outputs by combining the data of four simpler functions.\n"
"\n"
"This function is defined as a composite &mdash; in a much more complicated sense than we have seen thusfar &mdash; of the given functions.\n"
"\n"
"Can you do it?\n"
"\n"
"The ยง0 tactic, which is now in your library, may be helpful for making partial progress."
msgstr ""

#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Now we are ready for the Boss Level!"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Modus Tollens"
msgstr ""
