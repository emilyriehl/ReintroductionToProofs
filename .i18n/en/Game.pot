msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-21\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "In the next level, we will meet the universal property of conjunctions."
msgstr ""

#. §0: `Empty.elim`
#. §1: `Prod.snd`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "If your answer does not use the functions §0 and §1, you might have fun trying to solve this level again using them in appropriate places."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "While the goal is complicated to read, the outermost logical connective is a conjunction."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `A`
#. §2: `h : ∀ x : A, P x`
#. §3: `x : A`
#. §4: `P x`
#. §5: `a : A`
#. §6: `h`
#. §7: `P a`
#. §8: `h`
#. §9: `x : A`
#. §10: `h x : P x`
#. §11: `P x`
#. §12: `h`
#. §13: `h x`
#. §14: `P x`
#. §15: `h y`
#. §16: `P y`
#. §17: `h a : P a`
#. §18: `P a`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Let §0 be a predicate over a type §1.\n"
"\n"
"Suppose we have a proof §2 that for all §3, §4 is true.\n"
"\n"
"Then if we are given any particular §5. We can use §6 to provide a proof of §7.\n"
"\n"
"How?\n"
"\n"
"Recall that we can think of proofs of universally quantified statements as *dependent functions*.\n"
"\n"
"Thus, §8 can be thought of as a function that takes §9 to a proof §10 of the proposition §11.\n"
"\n"
"We say that §12 is a *dependent* function because the element §13 proves the proposition §14, while the element §15 proves a different proposition, namely §16.\n"
"\n"
"In particular, §17 is our desired proof of the proposition §18."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "More Component Functions"
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "Disjunction Boss Level"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f`
#. §3: `f`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "For functions §0 and §1 if §2 is injective, then so is §3."
msgstr ""

#. §0: `left`
#. §1: `right`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "The tactics §0 and §1 are useful for defining elements of coproduct types or defining functions valued in coproduct types. In the next level, we will begin to consider functions mapping out of coproduct types."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → B`
#. §3: `f : A → B`
#. §4: `A`
#. §5: `B`
#. §6: `A × B`
#. §7: `⟨a, b⟩ : A × B`
#. §8: `a : A`
#. §9: `b : B`
#. §10: `A`
#. §11: `B`
#. §12: `A ⊕ B`
#. §13: `a : A`
#. §14: `Sum.inl a : A ⊕ B`
#. §15: `b : B`
#. §16: `Sum.inr b : A ⊕ B`
#. §17: `f : A ⊕ B → C`
#. §18: `C`
#. §19: `A`
#. §20: `B`
#: Game.Levels.CoproductWorld
msgid "Given any types §0 and §1 we have studied\n"
"\n"
"* function types §2 whose elements §3 are *functions* from §4 to §5 and\n"
"\n"
"* product types §6 whose elements §7 are *pairs* of elements §8 and §9.\n"
"\n"
"In this world, we'll study another binary type forming operation. Given two types §10 and §11, there is a type §12 called the *coproduct type* which has two varieties of elements:\n"
"\n"
"* elements §13 define elements §14\n"
"* elements §15 define elements §16.\n"
"\n"
"Together, these constructions define the two *introduction rules* for coproduct types. Coproduct types also have an *elimination rule*, which gives a strategy for defining a function §17 whose inputs belong to a coproduct type and whose outputs take values in an arbitrary type §18.\n"
"\n"
"This elimination rule tells us that functions out of a coproduct can be defined &ldquo;by cases&rdquo; &mdash; that is, by independently specifying the images of those elements that come from §19 and those elements that come from §20.\n"
"\n"
"Collectively, these rules characterize coproduct types and can be used to establish their properties, which we will explore in the levels that follow."
msgstr ""

#. §0: `¬ Q`
#. §1: `Q → False`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that §0 is an abbreviation for the type §1."
msgstr ""

#. §0: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "The function §0 is bijective."
msgstr ""

#. §0: `A ⊕ B → C`
#. §1: `A → C`
#. §2: `B → C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "A function of type §0 may be split into component functions of types §1 and §2."
msgstr ""

#. §0: `x y : Empty`
#. §1: `x = y`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "The empty type is a proposition: for §0, §1."
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "Absurd"
msgstr ""

#. §0: `A → B → C → D → E`
#. §1: `A → (B → (C → (D → E)))`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "More generally, §0 abbreviates the iterated function type §1. Explicit parentheses must be used to express iterated function types with any other parenthesizations."
msgstr ""

#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "More Transitivity"
msgstr ""

#. §0: `gf_is_surj`
#. §1: `«{c}»`
#. §2: `have hc := gf_is_surj «{c}»`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "To use the hypothesis §0 at §1 type §2."
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What sort of type does §0 belong to? Can we extract other elements from an element of this type?"
msgstr ""

#. §0: `let`
#. §1: `have`
#. §2: `let`
#. §3: `a : A`
#. §4: `b : B`
#. §5: `let p : A × B := ⟨a, b⟩`
#. §6: `let f : A → B := fun _ ↦ b`
#. §7: `b`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The §0 tactic is like §1, but for creating elements of types rather than proofs of propositions. The §2 tactic will add new elements to your context provided you can define them. For example, given elements §3 and §4, you can type §5 to add their pair to the context or type §6 to add the constant function at §7 to the context."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `A`
#. §2: `∃ x : A, P x`
#. §3: `a : A`
#. §4: `P a`
#. §5: `p_a : P a`
#. §6: `⟨a, p_a⟩ : ∃ x : A, P x`
#. §7: `⟨a, p_a⟩`
#. §8: `P a`
#. §9: `p_a : P a`
#. §10: `a : A`
#. §11: `and : Bool → Bool → Bool`
#. §12: `x && y = and x y`
#. §13: `or : Bool → Bool → Bool`
#. §14: `x || y = or x y`
#. §15: `b : B`
#. §16: `b && b = b || b`
#. §17: `use`
#. §18: `∃ x : A, P x`
#. §19: `use a`
#. §20: `a : A`
#. §21: `P a`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Let §0 be a predicate over a type §1.\n"
"\n"
"To prove the proposition §2 it suffices to find any element §3 so that §4 holds.\n"
"\n"
"If you have a proof §5, then the same notation used for conjunctions and product types can be used to define an element §6.\n"
"\n"
"Here the element §7 can be thought of as a *dependent pair*, where the type §8 of the right component §9 depends on the left component §10.\n"
"\n"
"Recall the function §11 capturing the logical notion of conjunction. Lean uses alternate notation §12.\n"
"\n"
"Recall also the function §13 capturing the logical notion of disjunction. Lean uses the alternate notation §14\n"
"\n"
"In this level, you are asked to prove that there exists some boolean §15 so that §16.\n"
"\n"
"The tactic §17 is used to introduce proofs of existentially quantified predicates.\n"
"\n"
"If the goal is to prove §18, one can type §19 referencing a specific element §20 to reduce the goal to proving §21."
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
#: Game.Levels.BooleanWorld.L07_DeMorgan
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "What is the outermost logical connective?"
msgstr ""

#. §0: `f : A → B`
#. §1: `f : A → B`
#. §2: `∀ x y : A, f x = f y → x = y`
#. §3: `f : A → B`
#. §4: `b : B`
#. §5: `x : A`
#. §6: `f x = b`
#. §7: `not : Bool → Bool`
#. §8: `not`
#. §9: `Bool.not_injective`
#. §10: `Bool.not_surjective`
#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "We have introduced two properties that may or may not hold of a given function §0.\n"
"\n"
"Recall that a function §1 is *injective* if §2.\n"
"\n"
"Recall that a function §3 is *surjective* if for every §4 there exists some §5 so that §6.\n"
"\n"
"If a function is both injective and surjective, then it is called *bijective*.\n"
"\n"
"We have shown that the function §7 is both injective and surjective. Thus, we conclude that §8 is bijective.\n"
"\n"
"You do not need to reprove these results, which can be found in your library with the names §9 and §10."
msgstr ""

#. §0: `Unit`
#. §1: `⟨⟩`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type §0 has a canonical element §1."
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `b : B`
#. §3: `f a = b`
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "A function §0 must be *total* meaning for each §1 there is some §2 so\n"
"that §3."
msgstr ""

#. §0: `.1`
#. §1: `.2`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Note the §0 and §1 notation can be iterated."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `constructor`
#. §4: `P ∧ Q`
#. §5: `P`
#. §6: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "To prove a conjunction §0 we need to supply a proof of both §1 and §2.\n"
"\n"
"This expresses the introduction rule for the logical operation of conjunction.\n"
"\n"
"Use the tactic §3 to ask Lean to break up the goal or proving §4 into two steps, of first proving §5 and then proving §6."
msgstr ""

#. §0: `And.symm`
#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "You might be able to shorten your proof by applying the theorem §0 from our library at the appropriate point. In the next two levels, we will establish the precise relationship between bijective functions and invertible functions."
msgstr ""

#. §0: `A`
#. §1: `a : A`
#. §2: `a = a`
#. §3: `rfl : a = a`
#. §4: `rfl`
#. §5: `a = a`
#. §6: `a = a`
#. §7: `exact rfl`
#. §8: `rfl`
#. §9: `exact rfl`
#. §10: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Let §0 be a type with an element §1. Then the proposition §2 is always true\n"
"because there is a proof §3 witnessing the *reflexivity* of equality.\n"
"\n"
"In Lean, §4 is a name for an element of the type §5. So to produce a proof of §6, you\n"
"can type §7. As a shorthand, Lean also defines a tactic called §8 that is shorthand for\n"
"§9. So you can solve the goal by typing simply §10."
msgstr ""

#. §0: `P`
#. §1: `P → ¬ ¬ P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition §0, §1."
msgstr ""

#. §0: `A`
#. §1: `A → Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "In summary, something very strange happens if the types §0 and §1 both have elements."
msgstr ""

#. §0: `x : A × (B ⊕ C)`
#. §1: `x`
#. §2: `x`
#. §3: `⟨y, z⟩`
#. §4: `y : A`
#. §5: `z : B ⊕ C`
#. §6: `z`
#. §7: `Sum.inl b`
#. §8: `b : B`
#. §9: `Sum.inr c`
#. §10: `c : C`
#. §11: `x : A × (B ⊕ C)`
#. §12: `⟨y, Sum.inl b⟩`
#. §13: `⟨y, b⟩ : A × B`
#. §14: `x`
#. §15: `⟨y, Sum.inr c⟩`
#. §16: `⟨y, c⟩ : A × C`
#. §17: `A × (B ⊕ C) → (A × B) ⊕ (A × C)`
#. §18: `(A × B) ⊕ (A × C) → A × (B ⊕ C)`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "How should we think about an element of type §0?.\n"
"\n"
"Since §1 belongs to a product type, it can be split into two components. That is §2 has the form of a pair §3 with §4 and §5. And since §6 belongs to a coproduct type, there are two possible cases: it can have the form §7 for some §8 or it can have the form §9 for some §10. In the first case, the original §11 is a pair of the form §12 coming from §13 which in the second case §14 is a pair of the form §15 coming from §16.\n"
"\n"
"This explains the *distributivity* of products over coproducts, which can be encoded by a pair of functions, one of the form §17 and the other of the form §18.\n"
"\n"
"Your challenge in this level is to define these functions.\n"
"\n"
"While it may be complicated to think about the entire construction at once, you can use the context and goal types at each stage of the construction to help guide you.\n"
"\n"
"The introduction rules and their associated tactics can be used to transform the goal state into simpler goal states. Simultaneously, the elimination rules can be used to define new elements out of any elements that appear in your context of objects."
msgstr ""

#. §0: `«{f}» : A → Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have an assumption §0. What can be done with an element of a function type?"
msgstr ""

#. §0: `intro h1 h2 h3`
#. §1: `have`
#. §2: `</>`
#. §3: `editor mode`
#. §4: `>_`
#. §5: `typewriter mode`
#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "We are now ready for the Boss Level of Implication World.\n"
"\n"
"Multiple hypothesis can be introduced at once by writing §0 etc. You might consider using names that will help you remember which propositions are proven by each hypothesis!\n"
"\n"
"While it is not necessary to solve this level, you may enjoy experimenting with the §1 tactic that was recently added to the tactic library.\n"
"\n"
"To delete a proof (or proof attempt) and start over click on the button labelled §2 in the upper right hand corner to enter §3. Then delete all the lines of your first proof (or proof attempt). Clicking on §4 takes you back to §5."
msgstr ""

#. §0: `have pq : P ∧ Q := ⟨«{p}» , «{nq}»⟩`
#. §1: `apply «{npq}»`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Try §0 or try §1."
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Second Projection"
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "Using Functions"
msgstr ""

#. §0: `↔`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the §0 is the outermost logical connective. If you've forgotten what this means, you can look it up in the library."
msgstr ""

#. §0: `«{f}».1`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "What type does §0 belong to? Is this useful?"
msgstr ""

#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "Move on to Advanced Function World to use quantifiers to study important properties of functions."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.DependentWorld.L05_Currying
msgid "Currying"
msgstr ""

#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Universal Truth"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `A → B → C`
#. §4: `B → A → C`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "For any types §0, §1, and §2, the function types §3 and §4 are equivalent."
msgstr ""

#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "From a function of two variables, define another function of two variables, where the inputs are swapped."
msgstr ""

#: Game.Levels.BooleanWorld
msgid "Boolean World"
msgstr ""

#. §0: `¬ (P ∧ ¬ P)`
#. §1: `Q`
#. §2: `P`
#. §3: `¬ P`
#. §4: `P → ¬ P → Q`
#. §5: `¬ P → P → Q`
#. §6: `P`
#. §7: `P → Q`
#. §8: `exfalso`
#. §9: `exfalso`
#. §10: `Q`
#. §11: `False`
#. §12: `False.elim : Empty → Q`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "In the last level we proved the *law of noncontradiction*: §0.\n"
"\n"
"In this level, we will see that it is possible to prove any proposition §1 from the hypothesis that both §2 and §3 are true.\n"
"\n"
"In other words, §4 is always true.\n"
"\n"
"If we swapped order of the hypotheses, a similar proof would also show that §5 is true. In other words, if §6 is false, then §7 is always true.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck.\n"
"\n"
"While not necessary to solve this level, it is also possible to use the tactic §8 which is now in your library. The tactic §9 reduces the goal of proving a proposition §10 to the goal of proving §11 by applying the proof of the implication §12."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does either proof in this logical equivalence seem familiar? Do they both seem familar?"
msgstr ""

#. §0: `¬ P`
#. §1: `P`
#. §2: `P → False`
#. §3: `\\neg`
#. §4: `¬`
#: Game.Levels.NegationWorld.L02_Negation
msgid "§0, read as &ldquo; not §1&rdquo; is an abbreviation for §2. Use §3 to type §4."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `f : A → Empty`
#. §3: `A → B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "For any types §0 and §1, if there is a function §2 then there is also a function §3."
msgstr ""

#. §0: `Q`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Now Lean reminds you of the other goal, which is to prove §0. Which tactic applies here?"
msgstr ""

#. §0: `Nat.zero_add : ∀ n : ℕ, 0 + n = n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "The second half of this proves the theorem §0, which is now in your library."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "Predecessor of Successor"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `
#. flip Function.comp : (A → B) → (B → C) → (A → C)`
#. §4: `C`
#. §5: `Empty`
#. §6: `exact flip Function.comp`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types §0, §1, and §2, we have the function §3 defined by exchanging the inputs. This specializes in the case where §4 is the type §5 to define the function we seek here. Indeed, this level can be solved with §6. Does this perspective make this construction feel less strange?"
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "Negating Implication"
msgstr ""

#. §0: `rfl`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Recall the §0 tactic."
msgstr ""

#. §0: `P ∨ Q → R`
#. §1: `P ∨ Q → R`
#. §2: `P → R`
#. §3: `P`
#. §4: `P ∨ Q`
#. §5: `R`
#. §6: `P ∨ Q → R`
#. §7: `Q → R`
#. §8: `P → R`
#. §9: `Q → R`
#. §10: `P ∨ Q → R`
#. §11: `P → R`
#. §12: `Q → R`
#. §13: `P ∨ Q → R`
#. §14: `P ∨ Q → R`
#. §15: `(P → R) ∧ (Q → R)`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What must be true in order to have §0?\n"
"\n"
"On the one hand, if §1 is true, then §2 is true, because §3 implies §4, which implies §5.\n"
"\n"
"Similar reasoning shows that if §6 is true, then §7 is true.\n"
"\n"
"Conversely, if *either* §8 or §9 are true, this does not necessarily imply that §10 is true. Can you see why?\n"
"\n"
"However, if *both* §11 and §12 are true, then §13 is true, as you can argue using the strategy of proof by cases.\n"
"\n"
"The aim of this level is to establish a logical equivalence between §14 and §15."
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `P`
#. §3: `False`
#. §4: `p : P`
#. §5: `P`
#. §6: `False`
#. §7: `P`
#. §8: `np : ¬ P`
#. §9: `P`
#. §10: `False`
#. §11: `np : ¬ P`
#. §12: `False`
#. §13: `¬ ¬ P`
#. §14: `¬ ¬ P → P`
#. §15: `P`
#. §16: `¬ ¬ P → P`
#. §17: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Let §0 be a proposition.\n"
"\n"
"We have learned that there is a default strategy to prove §1, i.e., that §2 implies §3.\n"
"\n"
"The strategy is to start by assuming we have a proof §4, in other words, assuming that §5 is true.\n"
"\n"
"Then the goal is to derive an element of §6, also known as a *contradiction*.\n"
"\n"
"This proof strategy is fully compatible with constructive mathematics.\n"
"\n"
"There is a related, by distinct, strategy in classical logic that can be used to prove a proposition §7 assuming called &ldquo;proof by contradiction&rdquo;. Here one assumes we have a proof §8, in other words, assuming that §9 is false.\n"
"\n"
"The goal is again to derive an element of §10, also known as a contradiction.\n"
"\n"
"Such a proof &mdash; assuming §11 and then deriving an element of §12 &mdash; constructs an element of §13.\n"
"\n"
"In classical logic, there is an implication §14, which is why &ldquo;proof by contradiction&rdquo; can be used to ultimately prove that §15 is true.\n"
"\n"
"To prove §16 in Lean, type §17 to tell Lean that we are appealing to the proof by contradiction strategy."
msgstr ""

#. §0: `rfl`
#. §1: `cases «{b}»`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "As our previous theorem is not in the library, we'll have to reprove it. Recall §0 only applies for *definitional* equalities, and we only have this for certain cases of Booleans. Try §1."
msgstr ""

#. §0: `assumption`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "You can solve the goal by explicitly referring to the named hypothesis that Lean supplied or by typing §0 to indicate that the goal matches an assumption."
msgstr ""

#. §0: `∨`
#. §1: `P ∧ R`
#. §2: `(P ∧ S) ∨ ((Q ∧ R) ∨ (Q ∧ S))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Thus the outermost logical connective is the §0 combining §1 and §2."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "Do you see how this relates to the previous level?"
msgstr ""

#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "Composing Implication"
msgstr ""

#. §0: `ℕ → ℕ`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Now your goal is to define a function of type §0. Lean will accept any function of this type, but be careful. If you define a *different* function than the predecessor function, the properties you will be asked to prove later will not hold."
msgstr ""

#. §0: `«{hk}»`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "Now you can rewrite along the hypothesis §0."
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "Currying Implication"
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P`
#. §2: `Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "The converse implication is more subtle because if §0 is false we don't know which of §1 or §2 is false. This will be addressed in Classical World."
msgstr ""

#. §0: `(A : Type) → A → A`
#: Game.Levels.DependentWorld.L02_Functions
msgid "The polymorphic identity function has type §0."
msgstr ""

#. §0: `e : E`
#. §1: `E`
#. §2: `exact e`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "If there is an assumption §0 and the goal has type §1, then §2 closes the goal."
msgstr ""

#. §0: `(P ∨ Q) ∨ R`
#. §1: `P ∨ (Q ∨ R)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Or is associative: §0 is true if and only if §1 is true."
msgstr ""

#. §0: `or`
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "Was it necessary to consider all four cases of two boolean elements or can you define this function by considering fewer cases? The function §0 is now in your library."
msgstr ""

#. §0: `f : A → B`
#. §1: `f : A → B`
#. §2: `g : B → A`
#. §3: `g ∘ f = id`
#. §4: `f ∘ g = id`
#. §5: `A`
#. §6: `A`
#. §7: `∀ a : A, g (f a)`
#. §8: `B`
#. §9: `B`
#. §10: `∀ b : B, f (g a)`
#. §11: `f`
#. §12: `f`
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "Using function extensionality, we can give a third logically equivalence characterization of what it means for a function §0 to be bijective or invertible.\n"
"\n"
"A function §1 is an *isomorphism* if there exists a function §2 so that §3 and §4.\n"
"\n"
"The first equation is between functions from §5 to §6. By function extensionality, it is equivalent to the condition that §7.\n"
"\n"
"The second equation is between functions from §8 to §9. By function extensionality, it is equivalent to the condition that §10.\n"
"\n"
"In Lean, isomorphisms of types are also called *equivalences*, perhaps acknowledging a newly discovered connection between dependent type theory and homotopy theory.\n"
"\n"
"For the Boss Level, prove the logical equivalence between the conditions that whether §11 is invertible or whether §12 is an isomorphism."
msgstr ""

#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "Equality Proposition"
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `¬ ¬ ¬ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "For any proposition §0, §1 is logically equivalent to §2."
msgstr ""

#. §0: `P : A → B → Prop`
#. §1: `∃ z : B, ∀ w : A, P w z`
#. §2: `∀ x : A, ∃ y : B, P x y`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Given a family of propositions §0, §1implies §2"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `f : A → B → C`
#. §4: `Function.swap f : B → A → C`
#. §5: `b : B`
#. §6: `a : A`
#. §7: `f a b : C`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "For any types §0, §1, and §2 and function §3, §4 is the function that carries §5 and §6 to §7."
msgstr ""

#. §0: `«{A}»`
#. §1: `«{C}»`
#. §2: `intro x`
#. §3: `«{A}»`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "To define a function from §0 to §1, type §2 to introduce an\n"
"arbitrary element of type §3."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `comp : (B → C) → (A → B) → (A → C)`
#. §4: `f : A → B`
#. §5: `g : B → C`
#. §6: `comp g f : A → C`
#. §7: `a : A`
#. §8: `g (f a) : C`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "For types §0, §1, and §2, the function §3 takes a function §4 and a function §5 to the composite function §6 defined to take §7 to the element §8."
msgstr ""

#. §0: `cases b <;> rfl`
#. §1: `<;>`
#. §2: `rfl`
#. §3: `not ∘ not : Bool → Bool`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "This level can be solved in one line with §0 where the §1 indicates that the\n"
"tactic §2 should be applied in each of the cases. It follows that §3 is equal to the identity function by something called *function extensionality* that will be discussed in Advanced Function World."
msgstr ""

#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "Move on to Implication World to revisit these constructions from the prospective of propositions rather than types."
msgstr ""

#. §0: `«{f}»`
#. §1: `apply «{f}»`
#. §2: `«{A}»`
#. §3: `«{B}»`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Since §0 is a function with two variables, after §1 we now have two goals, where we need to supply first an element of type §2 and then an element of type §3. Lean records the first of these as the &ldquo;Active Goal&rdquo; and the second of these as &ldquo;Goal 2&rdquo;."
msgstr ""

#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "In the next level, we will learn about negating universal quantifiers."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "The lesson of this level is to pay attention to the big picture, namely what exactly you are being asked ot prove under what hypotheses."
msgstr ""

#. §0: `b`
#. §1: `b && b = b || b`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "There is some boolean §0 so that §1"
msgstr ""

#. §0: `True`
#. §1: `⟨⟩ : True`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The proposition §0 has a canonical element §1, which may be typed using '\\\\<' and '\\\\>'."
msgstr ""

#. §0: `intro w x y z p q r`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall you can introduce multiple variables and hypothesis at once by typing §0."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `P x : Prop`
#. §2: `x : A`
#. §3: `w = x → x = y → y = z → w = z`
#. §4: `w x y z : A`
#. §5: `w`
#. §6: `x`
#. §7: `y`
#. §8: `z`
#. §9: `∀ w x y z : A, w = x → x = y → y = z → w = z`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall that predicates §0 can also be thought of as indexed families of propositions: in this case, we have a proposition §1 for each element §2.\n"
"\n"
"More generally, we might consider propositions indexed by multiple variables, either drawn repeatedly from the same type or drawn from different types.\n"
"\n"
"In this level, we will consider the family of propositions\n"
"\n"
"§3\n"
"\n"
"indexed by four variables §4.\n"
"\n"
"Here this implication is true no matter what the specific elements §5, §6, §7, and §8 are.\n"
"\n"
"Thus, we will be able to prove\n"
"\n"
"§9\n"
"\n"
"an enhanced verison of the transitivity of equality."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#. §2: `P ∧ Q`
#. §3: `Q ∧ P`
#. §4: `P ∧ Q → Q ∧ P`
#. §5: `(P ∧ Q) → (Q ∧ P)`
#. §6: `P ∧ Q → Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "If §0 is true, then §1 is too.\n"
"\n"
"In other words, §2 implies §3, as is expressed by the proposition §4 which is implicitly parenthesized as §5.\n"
"\n"
"In a compound proposition such as §6, formed by iteratively applying logical connectives, the outermost logical connective (the one applied last in forming the proposition) often determines the overall proof strategy.\n"
"\n"
"Can you prove this?"
msgstr ""

#. §0: `S`
#. §1: `s : S`
#. §2: `exact s`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "If the goal is to prove §0 and we have a hypothesis §1, the tactic §2 supplies the required proof."
msgstr ""

#. §0: `∧`
#. §1: `P`
#. §2: `Q`
#. §3: `P ∧ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∧ Q`
#. §7: `P ∧ Q`
#. §8: `P ∧ Q`
#. §9: `p : P`
#. §10: `q : Q`
#. §11: `⟨p,q⟩ : P ∧ Q`
#. §12: `\\<`
#. §13: `\\>`
#. §14: `h : P ∧ Q`
#. §15: `P`
#. §16: `Q`
#. §17: `h.1 : P`
#. §18: `h.2 : Q`
#: Game.Levels.ConjunctionWorld
msgid "The logical connective of *conjunction*, denoted by §0, is the mathematical version of *and*.\n"
"\n"
"For arbitrary propositions §1 and §2, §3 is a new proposition asserting that §4 *and* §5 *are both true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §6.\n"
"* How to use a hypothesis of the form §7 to prove something else.\n"
"\n"
"To prove §8, one must supply proofs §9 and §10, which can be done using the syntax §11. Use §12 and §13 to type the angle brackets.\n"
"\n"
"If we have a proof §14 then we can extract proofs that §15 and §16 are true using the syntax §17 and §18.\n"
"\n"
"Like the analogy between function types and implication, there is a close analogy between product types and the logical operation of conjunction.\n"
"\n"
"The reuse of the syntax we first introduced for product types is deliberate, as the introduction and elimination rules for conjunctions precisely mirror those introduced for product types."
msgstr ""

#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "In the next level, we will search for a second element of the type of types."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "§0 implies §1."
msgstr ""

#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "Swapping Inputs"
msgstr ""

#. §0: `rcases «{even}» with ⟨d, hd⟩`
#. §1: `let ⟨d, hd⟩ := «{even}»`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Type §0 or §1 to decompose the hypothesis."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Using And"
msgstr ""

#. §0: `Unit`
#. §1: `⟨⟩ : Unit`
#. §2: `x y : Unit`
#. §3: `x = y`
#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "Recall from Type World that Lean has a built in unit type §0 that contains just one element denoted §1.\n"
"\n"
"The unit type is a proposition, meaning that it has at most one element.\n"
"\n"
"More precisely, if §2 are elements of the unit type, then we can prove §3 by a definitional equality, aka, by reflexivity."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "Can you figure out how you would encode other logical equivalences involving proposition variables as equalities involving booleans?"
msgstr ""

#. §0: `A`
#. §1: `x y : A`
#. §2: `x = y`
#. §3: `x`
#. §4: `y`
#. §5: `x = y`
#. §6: `x`
#. §7: `y`
#. §8: `A`
#. §9: `P`
#. §10: `x = y`
#. §11: `x = y`
#. §12: `p : x = y`
#. §13: `x`
#. §14: `y`
#. §15: `A`
#. §16: `2 + 2 = 4`
#. §17: `(2 + 2) 4 : ℕ`
#. §18: `0 = 1`
#. §19: `0 1 : ℕ`
#. §20: `0 = 1`
#. §21: `x = y`
#. §22: `x y : A`
#. §23: `x = y`
#. §24: `x = y`
#. §25: `p : x = y`
#. §26: `x`
#. §27: `y`
#. §28: `p`
#. §29: `x`
#. §30: `y`
#. §31: `x`
#: Game.Levels.EqualityWorld
msgid "Consider a type §0. For any two elements §1 there is a proposition §2\n"
"that encodes the mathematical assertion that §3 and §4 are *equal*.\n"
"\n"
"Note that the proposition §5 is only well-formed if §6 and §7 are elements of the same type §8.\n"
"\n"
"Like with generic propositions §9, the proposition §10 is not necessarily *true*.\n"
"\n"
"To prove that\n"
"§11 is true, we must construct an element §12 which can be thought of as a *proof* that\n"
"§13 equals §14 as elements of type §15.\n"
"\n"
"For example: §16 is true for elements §17. In Natural Numbers World, we will see a proof of this.\n"
"\n"
"But the proposition §18 is false, again for\n"
"§19.\n"
"\n"
"In Natural Numbers World, we will see how to prove its *negation*, in other words that §20 is false.\n"
"\n"
"To understand the proposition §21 for elements §22, we must understand:\n"
"\n"
"* How to prove propositions of the form §23.\n"
"* How to use hypotheses of the form §24 to prove other propositions or define elements of other types.\n"
"\n"
"The introduction rule for proving equality is surprisingly weak, only proving equalities that hold trivially &ldquo;by reflexivity&rdquo; or &ldquo;by definition&rdquo;.\n"
"\n"
"By contrast, the elimination rule for using proofs of equality is quite strong, expressing something like the *indiscernibility of identicals*: informally, if we have §25, then anything that is true of §26 must also be true of §27 (and conversely).\n"
"\n"
"Lean provides a tactic that can be applied to the proof §28 to convert a goal involving the element §29 to an analogous goal with §30 substituted in place of §31."
msgstr ""

#. §0: `+ : ℕ → ℕ → ℕ`
#. §1: `add_zero n : n + 0 = n`
#. §2: `add_succ m n : m + succ n = succ (m + n)`
#. §3: `succ m + n = succ (m + n)`
#. §4: `m`
#. §5: `n`
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "The addition function §0 is defined by the equations\n"
"\n"
"* §1 and\n"
"* §2.\n"
"\n"
"It is of course also true that §3 for all natural numbers §4 and §5, but this equation does not hold by definition.\n"
"\n"
"Instead you have to prove it by induction!\n"
"\n"
"Good luck."
msgstr ""

#. §0: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "The function §0 is invertible."
msgstr ""

#. §0: `use ??`
#. §1: `??`
#. §2: `m`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "To prove the existential quantifier, type §0 with an explicit numeral in the place of §1 to supply a well-chosen value of §2."
msgstr ""

#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Applying Implication"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `p : P`
#. §4: `q : Q`
#. §5: `→`
#. §6: `P`
#. §7: `Q`
#. §8: `P → Q`
#. §9: `P`
#. §10: `Q`
#. §11: `P → Q`
#. §12: `P → Q`
#. §13: `P → Q`
#. §14: `A → B`
#: Game.Levels.ImplicationWorld
msgid "We now step away from considerations involving types and their elements and turn our attention to propositions and their proofs.\n"
"\n"
"We begin our study of proofs with *propositional logic*.\n"
"\n"
"Many mathematical propositions are built out of simpler propositions using logical connectives. The structure of a compound proposition &mdash; that is, which connectives appear where &mdash; often suggests proof techniques, as we will discover.\n"
"\n"
"To study these connectives, we require *proposition variables* &mdash; denoted with letters like §0, §1, §2 &mdash; which stand for generic propositions, which may be true or false.\n"
"\n"
"The slogan *propositions as types* tells us that we can consider propositions as special cases of *types*.\n"
"\n"
"We think of the elements §3 and §4 as *proofs* that these propositions are true.\n"
"\n"
"Just as type forming operations can be used to build more complicated types out of existing types, *logical connectives* can be used to build more complicated propositions out of existing propositions.\n"
"\n"
"In this level we study the logical connective *implication* denoted by §5.\n"
"\n"
"For arbitrary *propositions* §6 and §7, §8 is a new proposition asserting that *if* §9 *is true then* §10 *is true*.\n"
"\n"
"To understand how implications work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §11.\n"
"* How to use a hypothesis of the form §12 to prove something else.\n"
"\n"
"We'll learn the rules for proving implications and using implications in the levels that follow.\n"
"\n"
"The introduction and elimination rules for implications precisely mirror the introduction and elimination rules for function types.\n"
"\n"
"This analogy is further emphasized by the fact that we use the same notation for implications §13 as for\n"
"function types §14. The Lean tactics that were introduced to define and work with functions will play an analogous role when proving or using implications."
msgstr ""

#. §0: `«{p}» : P`
#. §1: `¬ P`
#. §2: `¬ Q`
#. §3: `right`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Because  §0, it is unlikely that you will be able to prove §1. So instead try to prove §2. You can focus on this goal by using the tactic §3."
msgstr ""

#: Game.Levels.DependentWorld.L06_BossLevel
msgid "Congratulations for defeating the final Boss Level!"
msgstr ""

#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "Now you can start to apply some hypotheses to reduce the goal to one of your assumptions. Which tactic can be used here?"
msgstr ""

#. §0: `False`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "The proposition §0 has no elements."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `left`
#. §3: `P ∨ Q`
#. §4: `P`
#. §5: `A`
#. §6: `B`
#. §7: `left`
#. §8: `A ⊕ B`
#. §9: `A`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For propositions §0 and §1, the §2 tactic converts a goal of §3 to a goal of §4. For types §5 and §6, the §7 tactic converts a goal of §8 into a goal of §9."
msgstr ""

#. §0: `And.curry : (P ∧ Q → R) → (P → Q → R)`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "This proves the theorem §0, which is now in your library. We will next establish the converse implication."
msgstr ""

#. §0: `p : A × B`
#. §1: `⟨p.1, p.2⟩`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "A term §0 in a product type is definitionally equal to the pairing of its projections §1."
msgstr ""

#. §0: `f : A → B`
#. §1: `f`
#. §2: `f`
#. §3: `f`
#. §4: `g : B → A`
#. §5: `f`
#. §6: `b : B`
#. §7: `g b : A`
#. §8: `f (g b) = b`
#. §9: `f`
#. §10: `∃ x : A, f x = b`
#. §11: `A`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Suppose §0 is a bijective function, meaning §1 is both injective and surjective.\n"
"\n"
"Then it follows that §2 is invertible.\n"
"\n"
"The proof is more delicate, however, than the previous case as it requires classical logic rather than constructive logic.\n"
"\n"
"To define an inverse for §3, we must define a function §4 that &ldquo;un-does&rdquo; the action of §5.\n"
"For an element §6, we in particular want §7 to be chosen so that §8.\n"
"\n"
"Our hypothesis that §9 is surjective tells us that §10. But it doesn't give us a &ldquo;formula&rdquo; to pick a particular element of §11.\n"
"\n"
"Instead, we must appeal to something called the *axiom of choice* to make an explicit choice. We will\n"
"explain how to do so at that stage in the proof."
msgstr ""

#. §0: `Boss Level`
#. §1: `assumption`
#. §2: `exact`
#. §3: `Type`
#. §4: `Type`
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "Each world will end with a §0, which is intended to be more challenging than the levels that came before.\n"
"\n"
"It is not so easy to design a challenging exercise involving only the tactics §1 and §2 but nevertheless, we will end with a puzzle that you may find interesting.\n"
"\n"
"Your task in this level, like in the previous level, is to define an element in the type §3.\n"
"\n"
"In the previous level, you were asked to do this in the empty context. Here our context contains certain assumptions which could potentially be used to make your task easier.\n"
"\n"
"You are allowed, if you insist, to solve this level in the same way you solved the previous level. But we challenge you to define a different element of the type §4 than you used previously."
msgstr ""

#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "By Assumption"
msgstr ""

#. §0: `0`
#. §1: `rfl`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "To check that your function was defined correctly, we ask you to calculate its values on §0 and on successors. Hopefully you will be able to solve the goals with §1."
msgstr ""

#. §0: `cases «{hpqr}»`
#. §1: `rcases «{hpqr}» with hpq | hr`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "You can use §0 to split your hypothesis into cases or §1 to name your own variables."
msgstr ""

#. §0: `f : Bool → Bool → Bool`
#. §1: `f true true = true ∧ f false true = false ∧ f true false = false ∧ f false false = false`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Now you are asked to check that the function §0 that you just defined actually *is* the conjunction function. Specifically, you are asked to check that §1."
msgstr ""

#. §0: `A × B → C`
#. §1: `A → B → C`
#. §2: `A → B → C`
#. §3: `A × B → C`
#. §4: `(A × B → C) ≃ (A → B → C)`
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "*Currying* is the operation that converts a function of type §0 into a function of type §1.\n"
"\n"
"*Uncurrying* is the operation that converts a function of type §2 into a function of type §3.\n"
"\n"
"These operations are inverses, defining an equivalence of types\n"
"\n"
"§4.\n"
"\n"
"Note the currying and uncurrying functions are in the library, so can be used (rather than re-defined) in the proof."
msgstr ""

#. §0: `ℕ`
#. §1: `0 : ℕ`
#. §2: `succ : ℕ → ℕ`
#. §3: `∀ m n : ℕ, succ m = succ n → m = n`
#. §4: `¬ (∃ n : ℕ, succ n = 0)`
#. §5: `∀ P : ℕ → Prop, P 0 → (∀ k : ℕ, P k → P (succ k)) → (∀ n : ℕ, P n)`
#. §6: `ℕ`
#. §7: `0 : ℕ`
#. §8: `succ : ℕ → ℕ`
#. §9: `∀ P : ℕ → Type, P 0 → (∀ k : ℕ, P k → P (succ k)) → (∀ n : ℕ, P n)`
#. §10: `ℕ`
#. §11: `0 : ℕ`
#. §12: `succ : ℕ → ℕ`
#. §13: `ℕ`
#. §14: `0`
#. §15: `succ n`
#. §16: `n : ℕ`
#. §17: `ℕ`
#: Game.Levels.NaturalNumbersWorld
msgid "In this world, we will introduce the type §0 of natural numbers.\n"
"\n"
"In traditional foundations, the natural numbers are characterized by a series of axioms discovered roughly contemporaneously by Dedekind and Peano that are commonly called the *Peano postulates*. There are five axioms:\n"
"\n"
"  1. There is a natural number §1 called *zero*.\n"
"\n"
"  2. There is a function §2 that sends any natural number to its *successor*.\n"
"\n"
"  3. The successor function is injective: §3.\n"
"\n"
"  4. Zero is not the successor of any natural number: §4.\n"
"\n"
"  5. The principle of mathematical induction: §5.\n"
"\n"
"In type theory, the type §6 of natural numbers is instead characterized by introduction and elimination rules:\n"
"\n"
"* The *introduction rules* tell us that there is a natural number §7 as well as natural numbers obtained by applying the function §8.\n"
"* The *elimination rule* extends the principle of mathematical induction to families of types as well as families of propositions: §9.\n"
"\n"
"Together these rules say that §10 is an *inductive type* freely generated by §11 and §12. We may define (dependent) functions out of the inductive type §13 &ldquo;by induction&rdquo; by considering only the cases of §14 and §15 for some §16.\n"
"\n"
"The type-theoretic definition of §17 closely resembles Peano's first, second, and fifth axioms and in fact implies the other two, as we will see by the end of this world."
msgstr ""

#. §0: `g : A → C`
#. §1: `h : B → C`
#. §2: `A ⊕ B → C`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Two functions §0 and §1 combine to define a single function of type §2."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `A`
#. §2: `∀`
#. §3: `∀ x : A, P x`
#. §4: `∃`
#. §5: `∃ x : A, P x`
#. §6: `B : A → Type`
#. §7: `(x : A) → B x`
#. §8: `(x : A) × B x`
#. §9: `Π x : A, B x`
#. §10: `Σ x : A, B x`
#. §11: `fun x ↦ B : A → Type`
#. §12: `A → B`
#. §13: `fun x ↦ B : A → Type`
#. §14: `A × B`
#. §15: `f : (x : A) → B x`
#. §16: `B : A → Type`
#. §17: `B a`
#. §18: `a : A`
#. §19: `p : (x : A) × B x`
#. §20: `B : A→ Type`
#. §21: `p : (x : A) × B x`
#. §22: `p.1 : A`
#. §23: `p.2 : B p.1`
#: Game.Levels.DependentWorld
msgid "In Quantifier World, we studied familes of propositions §0 &mdash; also called *predicates* &mdash; indexed by elements of another type §1.\n"
"\n"
"We introduced two operations that  covert a family of propositions into a single proposition:\n"
"\n"
"* the *universal quantifier* §2, which yields the proposition §3 and\n"
"\n"
"* the *existential quantifier* §4, which yields the proposition §5.\n"
"\n"
"To conclude our reintroduction to proofs in dependent type theory, we study analogous families of types §6, which are also called *dependent types*.\n"
"\n"
"We also introduce a pair of type forming operations that turn a family of types into a single type:\n"
"\n"
"* the *dependent function type*, which yields a type denoted by §7 and\n"
"\n"
"* the *dependent pair type*, which yields a type denoted by §8.\n"
"\n"
"Dependent function types are also called *Pi types* and denoted by §9, although this notation is not used in Lean.\n"
"\n"
"Dependent pair types are also called *Sigma types* and denoted by §10.\n"
"\n"
"As the name suggests, the dependent function type generalizes the function type, introduced in Function World. Indeed, in the case of a constant type family §11, the dependent function type reduces to the ordinary function type §12.\n"
"\n"
"Similarly the dependent pair type generalizes the product type, introduced in Product World. Indeed, in the case of a constant type family §13, the dependent pair type reduces to the ordinary product type §14.\n"
"\n"
"(Dependent pair types are sometimes also called &ldquo;dependent product types&rdquo;, but this name is also used for the dependent function type, which can be thought of as forming the product of an indexed family of types; to avoid this confusion, we won't use this term in either setting.)\n"
"\n"
"An element §15 of the dependent function type associated to a type family §16 is called a *dependent function*. The introduction and elimination rules for dependent function types are analogous to those for ordinary function types and for the universal quantifier. In particular, dependent functions are necessarily total functions. To define a dependent function it is necessary to specify an element of the type §17 for every element §18.\n"
"\n"
"An element §19 of the dependent pair type associated to a type family §20 is called a *dependent pair*. The introduction and elimination rules for dependent pair types are analogous to those for ordinary product types and for the existential quantifier. In particular, a dependent pair §21 projects to define an element §22 and an element §23.\n"
"\n"
"Because of these analogies, you won't need any new tactics or syntax to solve the puzzles in this level. Let's begin!"
msgstr ""

#. §0: `f : A → B`
#. §1: `b : B`
#. §2: `x : A`
#. §3: `f x = b`
#. §4: `f : A → B`
#. §5: `g : B → C`
#. §6: `g ∘ f : A → C`
#. §7: `g : B → C`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "Recall that a function §0 is *surjective* if for every §1 there exists some §2 so that §3.\n"
"\n"
"In the level, we will consider a composable pair of functions §4 and §5.\n"
"\n"
"We will show that if the composite §6 is surjective, then the function §7 is surjective too."
msgstr ""

#. §0: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "The type §0 is the type of types at the smallest universe level."
msgstr ""

#: Game.Levels.TypeWorld
msgid "Type World"
msgstr ""

#: Game
msgid "ReintroToProofs"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#. §0: `cases h : «{x}»`
#. §1: `h : «{x}» = false`
#. §2: `h : «{x}» = true`
#. §3: `cases k : «{y}»`
#. §4: `match «{x}» , «{y}» with | ? , ? => exact ? | ? , ? => exact ? | ? , ? => exact ? | ? , ? => exact ?`
#. §5: `?`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "If you are using typewriter mode, try §0 to add hypotheses §1 and §2 that clarify which case you are in. Similarly, try §3 whenever you are ready to consider cases on the second boolean variable. Alternatively, you can define the function on one line with §4 replacing each §5 with appropriate boolean elements."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "In the next level, we will introduce a fundamental property of bijective functions, namely their\n"
"invertibility."
msgstr ""

#. §0: `fun x ↦ a`
#. §1: `x : B`
#. §2: `a : A`
#. §3: `fun _ ↦ a`
#. §4: `exact fun _ ↦ a`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "The formula for the constant function is §0. In other words, given any input §1, the output is always the specified term §2. Since the formula for the output does not depend on the input term, this can also be written as §3, so try solving this level with §4"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Modus Ponens"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "Invertibility"
msgstr ""

#. §0: `have rs : R ∨ S := «{h}».2`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try §0."
msgstr ""

#. §0: `«{P}»`
#. §1: `«{p}» : «{P}»`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Now the goal is to prove §0 assuming §1. Which tactic can be used to supply this proof?"
msgstr ""

#. §0: `P`
#. §1: `p : P`
#. §2: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "Under the hypothesis that we have a proposition §0 and a proof §1, we may conclude that §2 is true."
msgstr ""

#. §0: `Prod.fst : A × B → A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions."
msgstr ""

#. §0: `n`
#. §1: `Nat.pred_succ n`
#. §2: `Nat.pred (succ n) = n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "For all natural numbers §0, §1 proves that §2."
msgstr ""

#. §0: `Bool`
#. §1: `false`
#. §2: `true`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The type §0 is the type of booleans. It contains two elements, denoted §1 and §2."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "We are now ready for the Boss Level of Disjunction World."
msgstr ""

#. §0: `exact tr ⟨⟩`
#. §1: `False`
#. §2: `tr`
#. §3: `⟨⟩ : True`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Type §0 to return an element of §1 defined using the function §2 and the element §3."
msgstr ""

#. §0: `x y : Bool`
#. §1: `and x y = and y x`
#. §2: `x && y`
#. §3: `and x y`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
msgid "For any booleans §0, §1, capturing the symmetry of conjunction.\n"
"\n"
"Note Lean has an alternate notation §2 for §3."
msgstr ""

#. §0: `1`
#. §1: `2`
#. §2: `3`
#. §3: `4`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "Explicit numerals §0, §1, §2, §3, and so on are defined as repeated successors of the previous numerals."
msgstr ""

#. §0: `P`
#. §1: `P ∨ ¬ P → (¬ ¬ P → P)`
#. §2: `¬ ¬ P → P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `P`
#. §6: `exact em P`
#. §7: `apply byContradiction`
#. §8: `have np : ¬ P := ?`
#. §9: `?`
#. §10: `have np : ¬ P := by`
#. §11: `¬ P`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In Negation World, we proved that for any proposition §0: §1\n"
"\n"
"In other words, we showed that the law of excluded middle implies double negation elimination.\n"
"\n"
"We now show that converse: that double negation elimination implies the law of excluded middle. More\n"
"precisely, if we assume that §2 for all propositions §3, then we can show that §4 for\n"
"all proposition §5.\n"
"\n"
"While the proof will feel like an application of classical logic, using the strategy of proof by contradiction, in\n"
"fact the proof can be understood as a proof in constructive mathematics.\n"
"\n"
"This is because we are arguing under the assumption that double negation elimination holds, which means\n"
"we are working in a setting where the strategy of proof by contradiction applies.\n"
"\n"
"You can solve this level immediately with §6 &mdash; evading the boss &mdash; but try starting with §7 instead and see if you can argue without appealing to the law of excluded middle.\n"
"\n"
"You might wish to prove a few lemmas in the middle of this proof. We have seen that this can be done by typing §8 if you can supply the full name of the proof in place of the §9.\n"
"\n"
"Alternatively, switch into editor mode and type §10 and then move down to the next line. You'll see that Lean has replaced the overall goal by a local goal, in this case to prove the proposition §11 from the hypotheses in your context. This allows you to give a multi-line tactic proof."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This case is similar to the previous one. Can you figure out how to solve it?"
msgstr ""

#. §0: `Prop`
#. §1: `Type`
#. §2: `Prop : Type`
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "Note that elements of §0 are considered to be at a smaller universe level than elements of §1, which is why we have §2. Now move on to Function World to meet your first type forming operation."
msgstr ""

#. §0: `have q : Q := «{i}» «{p}»`
#. §1: `Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "Try §0 to add a proof of §1 to your assumptions."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `A`
#. §2: `A`
#. §3: `P x : Prop`
#. §4: `x : A`
#. §5: `∀ x : A, P x`
#. §6: `P x`
#. §7: `x : A`
#. §8: `x : A`
#. §9: `P x`
#. §10: `∀ x : A, P x`
#. §11: `x : A`
#. §12: `P x`
#. §13: `P x`
#. §14: `x : A`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Let §0 be a predicate over a type §1.\n"
"\n"
"As the notation suggests, a predicate is naturally regarded as a function, whose domain is the type §2 and whose target is the type of propositions.\n"
"\n"
"It is also natural to think of a predicate as an indexed family of propositions: we have propositions §3 indexed by the elements §4.\n"
"\n"
"To prove that §5 holds, one must show that §6 is true for each §7.\n"
"\n"
"That is, one must introduce an arbitrary element §8 and then construct a proof of §9.\n"
"\n"
"In other words, to prove §10, one must construct what is sometimes called a *dependent function* that carries §11 to an element of §12. Such functions are called &ldquo;dependent&rdquo; because the proposition §13 may vary with the input element §14."
msgstr ""

#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "Constant Functions"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld
msgid "Advanced Function World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Start by identifying the outermost logical connective and use the tactic corresponding to its introduction rule."
msgstr ""

#. §0: `cases «{p}»`
#. §1: `rcases «{p}» with x | c`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Now use §0 or §1 or similar to give your own variable names."
msgstr ""

#. §0: `p : A × B`
#. §1: `intro p`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Now Lean wants you to check that the first function followed by the second function yields the identity function at every element §0. Start with §1."
msgstr ""

#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "This proves the associativity of disjunction."
msgstr ""

#. §0: `p : x = y`
#. §1: `rw [p]`
#. §2: `x`
#. §3: `y`
#. §4: `rw [← p]`
#. §5: `y`
#. §6: `x`
#. §7: `rw`
#. §8: `rfl`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Given a hypothesis §0, the tactic §1 will replace each §2 in the goal by §3. Writing §4 will replace the each §5 in the goal by §6. This is a slightly less powerful version than the §7 tactic in Mathlib, which will attempt to close the goal with §8."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `Function.uncurry : (A → B → C) → (A × B → C)`
#. §4: `f : A → B → C`
#. §5: `p : A × B`
#. §6: `f p.1 p.2 : C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "For any types §0, §1, and §2, §3 is the function that sends §4 to the function that sends §5 to §6."
msgstr ""

#: Game.Levels.DependentWorld.L04_Pairs
msgid "Pairs"
msgstr ""

#. §0: `x : A × (B ⊕ C)`
#. §1: `rcases x with ⟨a, b | c⟩`
#. §2: `a : A`
#. §3: `b : B`
#. §4: `a : A`
#. §5: `c : C`
#. §6: `x : (A × B) ⊕ (A × C)`
#. §7: `rcases x with ⟨a, b⟩ | ⟨a, c⟩`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You might enjoy solving this level again with the following syntactic tricks. If given an element §0, then §1 will split into two cases, one of which involves elements §2 and §3 and the other of which involves elements §4 and §5. Similarly, if given §6, then §7 will split into the same pair of cases."
msgstr ""

#: Game.Levels.BooleanWorld.L01_Negation
msgid "Your first objective is to define the negation function."
msgstr ""

#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "More Distributivity"
msgstr ""

#. §0: `True`
#. §1: `Prop`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The proposition §0 and the type §1 are now in your library of definitions."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "If §0 is true, then if §1 is true, then §2 is true."
msgstr ""

#. §0: `Π x : A, B x`
#. §1: `Σ x : A, B x`
#. §2: `∀ x : A, P x`
#. §3: `∃ x : A, P x`
#. §4: `P : A → Prop`
#. §5: `Π`
#. §6: `Σ`
#. §7: `A`
#. §8: `B : A → Type`
#. §9: `A`
#. §10: `C : (x : A) → B x → C`
#. §11: `(x : A) → Σ y : B x, C x y`
#. §12: `(s : (x : A) → B x) × ((x : A) → C x (s x))`
#. §13: `C x y`
#. §14: `x : A`
#. §15: `y : B x`
#. §16: `C x y`
#. §17: `s : (x : A) → B x`
#. §18: `s x : B x`
#. §19: `x : A`
#. §20: `C x (s x)`
#. §21: `B`
#. §22: `C`
#: Game.Levels.DependentWorld.L06_BossLevel
msgid "We have now reached our final Boss Level.\n"
"\n"
"Your task is to define another equivalence involving dependent function and dependent pair types that is rather surprising.\n"
"\n"
"Recall that dependent function types are also called *Pi types* and can be denoted by §0, while dependent pair types are also called *Sigma types* and can be denoted by §1.\n"
"\n"
"These alternate notations are more directly analogous to the universal and existential quantifiers §2 and §3 used for a family of propositions §4.\n"
"\n"
"The equivalence of types you will construct here reveals that it is possible to move the quantifier §5 inside the quantifier §6.\n"
"\n"
"This equivalence does not contradict the observations made in Quantifier World that the order of the universal and existential quantifiers matters.\n"
"\n"
"Here the type appearing on the right-hand side of this equivalence &mdash; which is known as the *type theoretic axiom of choice* &mdash; is more elaborate.\n"
"\n"
"The type theoretic axiom of choice is an equivalence of types\n"
"involving a type §7, a type family §8 over §9, and a type family §10.\n"
"\n"
"It takes the form of an equivalence between:\n"
"\n"
"* the type §11 and\n"
"* the type §12.\n"
"\n"
"In the case where the types §13 are all propositions, an element of the first type proves that for all §14 there is some §15 so that §16 holds. The first component of an element of the second type is a dependent function §17 that specifies an element §18 for each §19 so that §20 holds. This is why the equivalence is referred to as the type theoretic &ldquo;axiom of choice&rdquo;.\n"
"\n"
"If you get stuck, it might help to consider the case where §21 and §22 are constant type families. As in the previous level, this equivalence is a familiar one!"
msgstr ""

#. §0: `have`
#. §1: `p : P`
#. §2: `h : P → Q`
#. §3: `have q : Q := h p`
#. §4: `q : Q`
#. §5: `h p`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "The §0 tactic can be used to add new hypotheses provided you can supply a proof. For example, given assumptions §1 and §2, type §3 to add a proof §4 defined by §5."
msgstr ""

#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "We will meet some further applications of the equality type in Boolean World. Head there next."
msgstr ""

#. §0: `(∃ x : A, ¬ (P x)) → ¬ (∀ x : A, P x)`
#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "We have just proven an implication\n"
"\n"
"§0.\n"
"\n"
"Use classical logic to prove the converse implication.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `constructor`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Use §0 to isolate the goal of defining the inverse function."
msgstr ""

#. §0: `constructor`
#. §1: `exact ⟨rfl, rfl, rfl, rfl, rfl⟩`
#. §2: `rfl`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "You can avoid the repeated applications of the §0 tactic by solving this level with §1. In the next level, we will encounter other equalities between natural numbers that can be proven with §2."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "How do you construct elements of a function type?"
msgstr ""

#. §0: `f : A ⊕ B → C`
#. §1: `Sum.inl : A → A ⊕ B`
#. §2: `g : A → C`
#. §3: `f`
#. §4: `f : A ⊕ B → C`
#. §5: `Sum.inr : B → A ⊕ B`
#. §6: `h : B → C`
#. §7: `A ⊕ B → C`
#. §8: `A → C`
#. §9: `B → C`
#. §10: `A ⊕ B → C`
#. §11: `(A → C) × (B → C)`
#. §12: `f : A ⊕ B → C`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Consider a function §0 mapping out of a coproduct type.\n"
"\n"
"By composing with the function §1 we obtain a function §2 which can be thought of as one of the two *component functions* associated to §3.\n"
"\n"
"The other component function is defined by composing §4 with the function §5 to obtain a function §6.\n"
"\n"
"Since a *single* function of type §7 decomposes into a pair of functions of types §8 and §9, we may  define a function from the function type §10 to the product of the function types §11. Thus carries a function §12 to its pair of component functions.\n"
"\n"
"Your task in this level is to define this operation, which splits a function out of a coproduct into into component functions."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "The DeMorgan equalities relate the operations of conjunction, disjunction, and negation on booleans."
msgstr ""

#. §0: `False`
#. §1: `«{eq}»`
#. §2: `«{neq}»`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Revisit Negation World to remind yourself how to get an element of §0 from §1 and §2."
msgstr ""

#. §0: `P ∧ (Q ∨ R)`
#. §1: `P`
#. §2: `Q ∨ R`
#. §3: `P ∧ Q`
#. §4: `P ∧ R`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "What does it mean if §0 holds?\n"
"\n"
"Then certainly §1 is true and also §2 is true.\n"
"\n"
"So we can conclude that §3 is true or §4 is true, demonstrating one of the implications in the following logical equivalence."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `B ⊕ A`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "For any types §0 and §1, the coproduct types §2 and §3 are equivalent."
msgstr ""

#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Commuting Quantifiers"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `Function.curry : (A × B → C) → (A → B → C)`
#. §4: `f : A × B → C`
#. §5: `a : A`
#. §6: `b : B`
#. §7: `f ⟨a, b⟩ : C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "For any types §0, §1, and §2, §3 is the function that sends §4 to the function that sends §5 and §6 to §7."
msgstr ""

#. §0: `«{p}»`
#. §1: `«{nq}»`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "What can you prove with §0 and §1?"
msgstr ""

#. §0: `¬ (true = false)`
#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "For the Boss Level of Natural Numbers World you are challenged to prove the fifth Peano axiom, that zero is not the successor of any natural numbers.\n"
"\n"
"For guidance, revisit the proof that §0 from Boolean World.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `P ∨ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "There are two ways to prove §0 from the given hypotheses. Can you find them both?"
msgstr ""

#. §0: `! x`
#. §1: `not x`
#. §2: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Here Lean writes §0 for §1, where §2 is the boolean negation function."
msgstr ""

#. §0: `B C : A → Type`
#. §1: `f : (x : A) → B x → C x`
#: Game.Levels.DependentWorld.L03_Application
msgid "Given a pair of type families §0 and a fiberwise function §1, then there is a function from sections of the first type family to sections of the second type family."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "Successor Injectivity"
msgstr ""

#. §0: `h : P ∧ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `h.1 : P`
#. §4: `h.2 : Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "A hypothesis §0 provides explicit proofs of both §1 and §2 which are denoted in Lean by §3 and §4.\n"
"\n"
"Collectively, this expresses the pair of elimination rules for the logical operation of conjunction."
msgstr ""

#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "In the next level, we will prove a similar universal property for coproduct types."
msgstr ""

#. §0: `A`
#. §1: `f : A → Empty`
#. §2: `a : A`
#. §3: `Empty`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "For any type §0, if there is a function §1 and there is an element §2, then there is an element of the §3 type."
msgstr ""

#. §0: `A ⊕ B → C × D`
#. §1: `(A → C) × (B → C) × (A → D) × (B → D)`
#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "A function of type §0 can be broken into component functions of type §1 and conversely the component functions assemble into a function from the coproduct type to the product type."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "The empty type is a weird type, so what was the point of this world? The hope is that your experience defining functions involving the empty type will prepare you to think about what it means to prove that a proposition is false in Negation World. Go there next."
msgstr ""

#. §0: `¬ (P ∧ Q)`
#. §1: `P ∧ Q`
#. §2: `P ∧ Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∧ Q`
#. §8: `¬ P ∨ ¬ Q`
#. §9: `¬ (P ∧ Q)`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"On the one hand, it suffices for just §3 to be false.\n"
"\n"
"On the other hand, it suffices for just §4 to be false.\n"
"\n"
"That is, if either §5 or §6 is false, then §7 is false.\n"
"\n"
"In this level, we will prove that §8 implies §9."
msgstr ""

#. §0: `h : P → Q`
#. §1: `p : P`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "We've seen that an implication §0 can be applied in the presense of a proof §1 to provide a proof of the proposition §2. This explains how implications are *used* in proofs of other statements. In the next level, we will see how implications can be *proven*."
msgstr ""

#: Game.Levels.ProductWorld
msgid "Product World"
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "When in doubt, recall the introduction rule for equality types."
msgstr ""

#. §0: `intro`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use the §0 tactic to define a term in a function type."
msgstr ""

#. §0: `exact fun g f a ↦ ?`
#. §1: `?`
#. §2: `exact fun g f ↦ ?`
#. §3: `?`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Can you solve this level in one line by using §0 with the appropriate thing in place of the §1?\n"
"\n"
"Can you solve this level in one line by using §2 with the appropriate thing in place of the §3?"
msgstr ""

#. §0: `not : Bool → Bool`
#. §1: `and : Bool → Bool → Bool`
#. §2: `Bool → Bool → Bool`
#. §3: `Bool → Bool → Bool`
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "We have seen that the logical operation of negation can be encoded as a function §0.\n"
"\n"
"We have also defined a function §1 that encodes the logical operation of conjunction.\n"
"\n"
"In this level, we will define a function §2 that encodes the logical operation of disjunction.\n"
"\n"
"Again, this level comes with two pre-defined goals: the first is to define the disjunction function §3 and the second is to check that your definition is correct by calculating the values of the function you defined on explicit pairs of booleans."
msgstr ""

#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "In the next level, we will explore the consequences of exchanging the order of universal and existential quantifiers."
msgstr ""

#. §0: `have`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "For the Boss Level of Conjunction World, the task is to prove a complicated implication.\n"
"\n"
"After introducing all of the allowed hypotheses, you may find it helpful to prove that some intermediate propositions are true using the §0 tactic.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A ⊕ B) ⊕ C`
#. §4: `A ⊕ (B ⊕ C)`
#. §5: `a : A`
#. §6: `b : B`
#. §7: `c : C`
#. §8: `b : B`
#. §9: `Sum.inl (Sum.inr b) : (A ⊕ B) ⊕ C`
#. §10: `Sum.inr (Sum.inl b) : A ⊕ (B ⊕ C)`
#. §11: `((A ⊕ B) ⊕ C) → (A ⊕ (B ⊕ C))`
#. §12: `(A ⊕ (B ⊕ C)) → ((A ⊕ B) ⊕ C)`
#. §13: `(((A ⊕ B) ⊕ C) → (A ⊕ (B ⊕ C))) × ((A ⊕ (B ⊕ C)) → ((A ⊕ B) ⊕ C))`
#. §14: `A ⊕ B ⊕ C`
#. §15: `A ⊕ (B ⊕ C)`
#. §16: `x : A ⊕ B ⊕ C`
#. §17: `rcases x with a | b | c`
#. §18: `a : A`
#. §19: `b : B`
#. §20: `c : C`
#. §21: `y : (A ⊕ B) ⊕ C`
#. §22: `rcases y with (a | b) | c`
#. §23: `a : A`
#. §24: `b : B`
#. §25: `c : C`
#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Given three types §0, §1, and §2, the coproduct type construction may be iterated to define types §3 and §4.\n"
"\n"
"For both of these types, there are three cases of elements: those coming from §5, those coming from §6, and those coming from §7. The notation for the corresponding elements of the iterated coproduct type depends on the parentheses: the terms §8 include as §9 but include as §10.\n"
"\n"
"The objective in this level is to define a pair of functions between these types in each direction, the first of type §11 and the second of type §12. That is, define a single element of type\n"
"\n"
"§13\n"
"\n"
"By convention, the notation §14 is an abbreviation for the coproduct type §15. For an element §16, typing §17 will split directly into the three cases corresponding to elements §18, §19, or §20.\n"
"\n"
"Similarly, for an element §21, §22 will split directly into the three cases corresponding to elements §23, §24, or §25."
msgstr ""

#: Game.Levels.ProductWorld.L06_Currying
msgid "Define the currying function, convering a function out of a product type into a function of two variables."
msgstr ""

#: Game.Levels.TypeWorld.L01_Elements
msgid "In the next level, we will learn about elements of propositions."
msgstr ""

#. §0: `A ⊕ B`
#. §1: `A`
#. §2: `Sum.inl : A → A ⊕ B`
#. §3: `left`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "To define an element of type §0 by defining an element of type §1 and applying the function §2, start by typing §3."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `P ∧ Q`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "For any propositions §0 and §1, if §2 is false or §3 is false then §4 is false."
msgstr ""

#. §0: `∃ x : A, P x`
#. §1: `a : A`
#. §2: `P a`
#. §3: `∀ x : A, ¬ (P x)`
#. §4: `∀ x : A, ¬ (P x)`
#. §5: `¬ (∃ x : A, P x)`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "How would you disprove a statement of the form\n"
"\n"
"§0?\n"
"\n"
"To do this, it is necessary to show that for *every* §1, §2 is not true.\n"
"\n"
"That is, it is necessary to prove\n"
"\n"
"§3.\n"
"\n"
"In this level we will prove §4 implies\n"
"§5 and conversely."
msgstr ""

#. §0: `Nat.add_comm : ∀ m n : ℕ, m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "This proves the theorem §0, which is now in your library."
msgstr ""

#. §0: `Bool → Prop`
#. §1: `let P : Bool → Prop := by intro b ; match b with | false => exact False | true => exact True`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Define a function §0 by §1."
msgstr ""

#. §0: `P ∧ ¬ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "In the next level, we will see that a contradiction of the form §0 can be used to prove any proposition."
msgstr ""

#. §0: `C : Bool → Type`
#. §1: `(b : Bool) → C b`
#: Game.Levels.DependentWorld.L01_Types
msgid "Does the family of types §0 you have just defined have any dependent functions of type §1. If not, could you define a different family of types that would have dependent functions? If so, could you define a different family of types that would not have dependent functions?"
msgstr ""

#. §0: `and : Bool → Bool → Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "The function §0 captures the logical operation of conjunction."
msgstr ""

#. §0: `«{f}»`
#. §1: `«{p}»`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "What sort of inputs does the function §0 require and how can these be extracted from §1?"
msgstr ""

#. §0: `Prop`
#. §1: `Prop`
#. §2: `True`
#. §3: `⟨⟩ : True`
#. §4: `P`
#. §5: `Q`
#. §6: `p : P`
#. §7: `P`
#. §8: `P`
#. §9: `Q`
#. §10: `P`
#. §11: `Q`
#. §12: `Prop`
#. §13: `Retry`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "Lean has a built in type of propositions denoted §0.\n"
"\n"
"In the empty context, §1 contains propositions like §2, which is the true proposition, with canonical proof §3.\n"
"\n"
"In this level, we consider the context given by two propositions §4 and §5 together with a proof §6 of §7.\n"
"\n"
"Thus, §8 is a proposition that we have assumed to be true, while §9 is a proposition that may or may not be true.\n"
"\n"
"Under these assumptions, either §10 or §11 define elements of §12. Use the §13 button to solve this level in multiple ways."
msgstr ""

#. §0: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "This equality does not hold by definition, so §0 fails. But your context has a new hypothesis that can help."
msgstr ""

#. §0: `ℕ`
#. §1: `0: ℕ`
#. §2: `succ : ℕ → ℕ`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "The type of natural numbers is denoted §0. It is an inductive type freely generated by §1 and the function §2 taking each natural number to its successor."
msgstr ""

#. §0: `Bool.noConfusion`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "We have added the theorem §0 to the library."
msgstr ""

#. §0: `«{na}»`
#. §1: `«{npa}»`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "There are various ways to use §0 and §1 to get a contradiction."
msgstr ""

#. §0: `ext`
#. §1: `f g : A → B`
#. §2: `f x = g x`
#. §3: `x : A`
#. §4: `ext`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "The §0 tactic can be used to apply function extensionality, changing a goal involving proving equality between functions §1 into a goal of proving §2 for an arbitrary §3. The §4 tactic  applies similar extensionality lemmas that have been proven for other types."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The goal is an implication. What tactic can be used to start a proof?"
msgstr ""

#. §0: `induction`
#. §1: `2 * d + 1 + 1 = 2 * (d + 1)`
#. §2: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The §0 tactic is now in your library.\n"
"\n"
"It is a bit surprising that the last equation §1 holds by §2. This has to do with the way that addition and multiplication are defined in Lean. We will explore the definition of addition in a future level."
msgstr ""

#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Universal Elimination"
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Combined with what we know already, we have established a logical equivalence between the implications §0 and §1 in classical logic."
msgstr ""

#. §0: `not : Bool → Bool`
#. §1: `false`
#. §2: `true`
#. §3: `true`
#. §4: `false`
#: Game.Levels.BooleanWorld.L01_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The negation function §0 sends the boolean §1 to §2 and §3 to §4."
msgstr ""

#. §0: `Nat.add_succ`
#. §1: `rw [add_succ]`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "To apply the theorem §0 type §1."
msgstr ""

#. §0: `and : Bool → Bool → Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "There is a function §0 that captures the logical operation of conjunction."
msgstr ""

#. §0: `x`
#. §1: `cases x`
#. §2: `x`
#. §3: `cases`
#. §4: `h : P ∨ Q`
#. §5: `cases h`
#. §6: `P`
#. §7: `Q`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Assuming §0 is a variable in the local context with an inductive type, §1 splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on §2, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well. §3 detects unreachable cases and closes them automatically.\n"
"\n"
"For example, given an assumption §4, §5 splits the main goal into two goals, one assuming §6 holds and the other assuming §7 holds."
msgstr ""

#: Game.Levels.TypeWorld.L07_BossLevel
#: Game.Levels.FunctionWorld.L10_BossLevel
#: Game.Levels.ImplicationWorld.L10_BossLevel
#: Game.Levels.ProductWorld.L10_BossLevel
#: Game.Levels.ConjunctionWorld.L10_BossLevel
#: Game.Levels.EmptyWorld.L07_BossLevel
#: Game.Levels.NegationWorld.L11_BossLevel
#: Game.Levels.ClassicalWorld.L06_BossLevel
#: Game.Levels.EqualityWorld.L10_BossLevel
#: Game.Levels.BooleanWorld.L09_BossLevel
#: Game.Levels.QuantifierWorld.L09_BossLevel
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
#: Game.Levels.EquivalenceWorld.L07_BossLevel
#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
#: Game.Levels.DependentWorld.L06_BossLevel
msgid "Boss Level"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What is the logical structure of the goal?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Bijective Implies Invertible"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Composing Surjectivity"
msgstr ""

#. §0: `P`
#. §1: `¬ (P ∧ ¬ P)`
#. §2: `P`
#. §3: `¬ P`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "For any proposition §0, the following is true:\n"
"\n"
"§1\n"
"\n"
"This is sometimes called the *law of noncontradiction*.\n"
"\n"
"It asserts that it is not the case that both §2 and §3 are true.\n"
"\n"
"Do you see how this relates to the previous levels?"
msgstr ""

#. §0: `f : X → A × B`
#. §1: `fun x ↦ (f x).1 : X → A`
#. §2: `fun x ↦ (f x).2 : X → B`
#. §3: `g : X → A`
#. §4: `h : X → B`
#. §5: `X`
#. §6: `X → A × B`
#. §7: `g`
#. §8: `h`
#. §9: `let`
#. §10: `let`
#. §11: `have`
#. §12: `p : (X → A) × (X → B)`
#. §13: `X → A`
#. §14: `X → B`
#. §15: `let`
#. §16: `let g : X → A := p.1`
#. §17: `p`
#. §18: `g`
#. §19: `let h : X → B := p.2`
#. §20: `p`
#. §21: `h`
#. §22: `let`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "We've seen that functions §0 into product types can be decomposed into component functions §1 and §2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions.\n"
"\n"
"To that end consider an arbitrary pair of functions §3 and §4 that have the same domain type §5 but are otherwise unrelated.\n"
"\n"
"These functions can be combined to define a single function of type §6 whose component functions are defined by §7 and §8, respectively.\n"
"\n"
"Your task in this level is to define the operation that produces a function into a product type from a pair of component functions.\n"
"\n"
"While it is not strictly necessary to solve this level, we use this opportunity to introduce the §9 tactic. The §10 tactic is similar to the §11 tactic from Implication World, but it is used for creating elements of types rather than proofs of propositions.\n"
"\n"
"Suppose your context contains an element §12. Using this element it is possible to define functions of type §13 and §14. The §15 tactic can be used to add these to your context with explicit names.\n"
"\n"
"Typing §16 will add the function defined by the first component of §17 to your context and give it the name §18. Similarly, typing §19 will add the function defined by the second component of §20 to your context and give it the name §21.\n"
"\n"
"Practice using the §22 tactic while solving this level."
msgstr ""

#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "Right Inclusion"
msgstr ""

#. §0: `False.elim : Empty → P`
#. §1: `exact False.elim`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Lean has a built-in name §0 for the theorem you have just proven. Thus §1 will also solve this level. This theorem has been added to the library."
msgstr ""

#. §0: `«{nor}»`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What can you do with the hypothesis §0?"
msgstr ""

#. §0: `Bool`
#. §1: `false : Bool`
#. §2: `true : Bool`
#. §3: `Bool → Bool`
#. §4: `false`
#. §5: `true`
#. §6: `true`
#. §7: `false`
#. §8: `intro b`
#. §9: `Bool`
#. §10: `b`
#. §11: `false`
#. §12: `true`
#. §13: `cases b`
#. §14: `false`
#. §15: `true`
#. §16: `cases`
#. §17: `intro b`
#. §18: `match b with | false => exact ? | true => exact ?`
#. §19: `?`
#. §20: `Bool`
#. §21: `Bool → Bool`
#. §22: `true`
#. §23: `false`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Recall the type §0 of booleans has two elements denoted §1 and §2.\n"
"\n"
"In this level, our aim is to define a function §3 that encodes the logical operation of negation, i.e., sends §4 to §5 and §6 to §7.\n"
"\n"
"You can start to define this function in the usual way, by typing §8. Lean will then update the goal to ask you to supply an element of type §9. But which element should you pick?\n"
"\n"
"The correct answer depends on whether §10 is §11 or §12. The type of Booleans is an example of an *inductive type*, which is\n"
"similar to a coproduct type, and thus you can type §13 to split into the two possible cases.\n"
"\n"
"Note the first case provided by Lean is the case of §14 while the second case is the case of §15.\n"
"\n"
"Unfortunately, it is difficult to see which case is which in typewriter mode. Try toggling to editor mode and perhaps add a few blank lines at the bottom to see if you can see what case you are in.\n"
"\n"
"Alternatively, if you prefer to stay in typewriter mode, you can avoid the §16 tactic and define the entire function at once in one line.\n"
"\n"
"After §17, try typing §18 where each §19 should be replaced by the appropriate element of §20.\n"
"\n"
"Note this level comes with two pre-defined goals: the first is to define the negation function §21 and the second is to check that your definition is correct by calculating the values of the function you defined on the booleans §22 and §23."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P → Q`
#. §3: `¬ Q → ¬ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "For any propositions §0 and §1, if §2 holds then §3 also holds."
msgstr ""

#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "This function is in the library. Rather than redefine it, can you use it?"
msgstr ""

#. §0: `Bool.noConfusion`
#. §1: `¬ (false = true)`
#. §2: `¬ (true = false)`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "§0 proves §1 or §2 for booleans."
msgstr ""

#. §0: `P ∧ Q → R`
#. §1: `P → Q → R`
#. §2: `P → (Q → R)`
#. §3: `(P → Q) → R`
#. §4: `And.curry`
#. §5: `And.uncurry`
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "We now establish a logical equivalence between §0 and §1.\n"
"\n"
"This is why implications of the form §2 are so much more common than implications of the form §3.\n"
"\n"
"The two implications that comprise this logical equivalence are referred to as *currying* and *uncurrying* because they are the logical analogs of the currying and uncurrying operations on functions of two variables.\n"
"\n"
"Note the two implications proven in the previous two levels have been added to the theorem library, should you wish to use them. Their full names are §4 and §5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "A function is *bijective* if it is both injective and surjective."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P ∧ Q`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If §0 is true then §1 is true."
msgstr ""

#. §0: `f : A → B`
#. §1: `b : B`
#. §2: `a : A`
#. §3: `f a = b`
#. §4: `f : A → B`
#. §5: `g : B → C`
#. §6: `g ∘ f : A → C`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Recall that a function §0 is *surjective* if for every §1 there exists some §2 so that §3.\n"
"\n"
"Your task in this level is to show that surjective functions compose: if §4 is surjective and §5 is surjective, then §6 is surjective."
msgstr ""

#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Introducing And"
msgstr ""

#. §0: `cases`
#. §1: `cases «{hpq}»`
#. §2: `rcases «{hpq}» with hp | hq`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "The hypothesis generated by the §0 tactic isn't directly useable yet. Try §1 again, or §2 to name your own variables."
msgstr ""

#. §0: `A → Empty`
#. §1: `A`
#. §2: `B`
#. §3: `f : A → Empty`
#. §4: `A → B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "In this level, we will explore another weird consequence of the hypothesis that we have a function of type §0.\n"
"\n"
"Let §1 and §2 be any types and assume there is a function §3.\n"
"\n"
"Then it is always possible to define a function §4.\n"
"\n"
"The proof requires a bit of cleverness, but you can ask for a few hints if you get stuck."
msgstr ""

#. §0: `A → B → C`
#. §1: `f : A → B → C`
#. §2: `a : A`
#. §3: `b : B`
#. §4: `f a b : C`
#. §5: `f`
#. §6: `a`
#. §7: `b`
#. §8: `A → B → C`
#. §9: `B → A → C`
#. §10: `A → B → C`
#. §11: `B`
#. §12: `A`
#. §13: `C`
#. §14: `intro f b a`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Recall that an element of type §0 can be thought of as a function of two variables.\n"
"\n"
"Given §1, §2, and §3, §4 denotes §5 applied first to §6 and then to §7.\n"
"\n"
"From a function of type §8, we can define a function of type §9 by exchanging the order of the variables that are input into the function.\n"
"\n"
"Here the goal is a multivariable function type that takes three inputs &mdash; of types §10 and §11 and §12 &mdash; and returns one ouput, of type §13. If you like, you can start with §14 to introduce all three variables at once."
msgstr ""

#. §0: `x = x`
#. §1: `x : A`
#. §2: `x = y`
#. §3: `y = x`
#. §4: `x = y`
#. §5: `y = z`
#. §6: `x = z`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "We've seen that equality is *reflexive*, meaning that §0 for any element §1.\n"
"\n"
"We've also proven that equality is *symmetric*: if §2 then §3.\n"
"\n"
"In this level, we will prove that equality is *transitive*: if §4 and §5, then §6."
msgstr ""

#. §0: `apply «{h}»`
#. §1: `exact «{h}» «{p}»`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "You can use §0 or conclude with §1. Can you understand the meaning of both proofs?"
msgstr ""

#. §0: `P`
#. §1: `A`
#. §2: `P`
#. §3: `p : P`
#. §4: `p`
#. §5: `P`
#. §6: `P`
#. §7: `p`
#. §8: `P`
#. §9: `P`
#. §10: `p`
#. §11: `P`
#. §12: `P`
#. §13: `p`
#. §14: `P`
#. §15: `P`
#. §16: `P`
#. §17: `assumption`
#. §18: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "In this level, we consider a proposition §0 in place of a type §1.\n"
"\n"
"When a proposition §2 has an element §3 we think of §4 as a *proof* that the proposition §5 is true.\n"
"\n"
"The context for this level collectively asserts that §6 is a proposition and §7 is a proof of §8. In particular, our assumptions imply that the proposition §9 is true.\n"
"\n"
"As we will see, it is useful to have an explicit name §10 for the proof that §11 is true. When we reference the truth of the proposition §12 to prove other propositions, we will do so by referring to the element §13.\n"
"\n"
"Our goal, which is displayed to the right of the vertical line, is to prove the proposition §14.\n"
"\n"
"We know that §15 is true because we have assumed that §16 is true. So the tactic §17 can be used to tell Lean that §18 is true by assumption."
msgstr ""

#. §0: `use`
#. §1: `Bool`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Type §0 followed by the name of an element of §1 that you believe will satisfy the predicate."
msgstr ""

#. §0: `intro`
#. §1: `Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "To prove a universally quantified statement, start with §0 to introduce arbitrary elements of type §1. "
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "The inverse of an invertible function is invertible."
msgstr ""

#. §0: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "The function §0 is injective."
msgstr ""

#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Define the composition of two functions as a multivariable function between function types."
msgstr ""

#. §0: `«{lem}»`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Now might be a good time to case split on the hypothesis §0."
msgstr ""

#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
msgid "What is the outermost logical connective? What tactic is used to prove statements of this form?"
msgstr ""

#. §0: `p : P`
#. §1: `h : P → Q`
#. §2: `Q`
#. §3: `h`
#. §4: `P → Q`
#. §5: `Q`
#. §6: `P`
#. §7: `p : P`
#. §8: `P`
#. §9: `Q`
#. §10: `p : P`
#. §11: `h : P → Q`
#. §12: `h`
#. §13: `P`
#. §14: `Q`
#. §15: `h`
#. §16: `p`
#. §17: `Q`
#. §18: `h p`
#. §19: `exact h p`
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "We just proved modus ponens using backwards reasoning.\n"
"\n"
"We were given proofs §0 and §1 were true and argued that it follows that §2 is also true.\n"
"\n"
"To show this, we used the proof §3 of the implication §4 to argue that to prove that §5 is true it suffices to prove that §6 is true.\n"
"\n"
"We then noted that the element §7 proves that §8 is true.\n"
"\n"
"Lean also has a syntax that allows us to directly construct a proof of §9 out of the proofs §10 and §11.\n"
"\n"
"The proof §12 can be thought of as a *function* that converts proofs of §13 into proofs of §14.\n"
"\n"
"In particular, we can apply the function §15 to the proof §16 to obtain a proof of §17 denoted by §18.\n"
"\n"
"Thus, you can solve this level, proving modus ponens again, simply by typing §19."
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `f : A × B → C`
#. §3: `⟨a, b⟩ : A × B`
#. §4: `h : C → D`
#. §5: `a' : A`
#. §6: `b' : B`
#. §7: `g : A × B → C`
#. §8: `⟨a',b'⟩ : A × B`
#. §9: `k : C → D`
#. §10: `p : a = a'`
#. §11: `q : b = b'`
#. §12: `r : h ∘ f = k ∘ g`
#. §13: `h ∘ f`
#. §14: `k ∘ g`
#. §15: `h ∘ f`
#. §16: `k ∘ g`
#. §17: `r`
#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "For the Boss Level of Equality World, you are asked to prove an equality of a more elaborate form than we've seen thus far.\n"
"\n"
"On the left-hand side of the equality is an element defined by\n"
"\n"
"* starting with a pair of elements §0 and §1,\n"
"* applying a function §2 to the pair §3, and\n"
"* then applying a function §4 to the result.\n"
"\n"
"On the right-hand side of the equality is an element defined by\n"
"* starting with a pair of elements §5 and §6,\n"
"* applying a function §7 to the pair §8, and\n"
"* then applying a function §9 to the result.\n"
"\n"
"In general, these elements would be distinct. However, we have assumed that we have equalities §10, §11, and §12.\n"
"\n"
"The last of these hypotheses is in a form that makes it somewhat difficult to use, as the functions §13 and §14 do not appear explicitly in the goal.\n"
"\n"
"But if you recall the way that composition of functions is defined, you'll see that these elements do appear implicitly in the goal.\n"
"\n"
"To solve this level, you will need to prove and then rewrite along another equality so that at least one of the functions §15 or §16 appears explicitly in the goal. This technique will be used frequently in Advanced Function World.\n"
"\n"
"Then you will be able to use the hypothesis §17 to complete the proof.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `have eq : ∀ a : A, (g ∘ f) a = g (f a) := fun a ↦ rfl`
#. §1: `(g ∘ f) x = (g ∘ f) y`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Alternatively, you could prove lemmas by §0 and then use rewrites to convert the goal into one where you can apply the hypothesis §1. Because the lemmas hold by definitional equality, you were able to skip that step."
msgstr ""

#. §0: `«{b}»`
#. §1: `surj «{b}» : ∃ x : A, f x = «{b}»`
#. §2: `a`
#. §3: `let a := (surj «{b}»).choose`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "At this stage of the proof, the idea is to apply the surjectivity hypothesis at §0, using the element §1. To extract an element of §2 satisfying this condition type §3."
msgstr ""

#. §0: `rw [p, q]`
#. §1: `rw [q, p]`
#. §2: `rw [← q, ← p]`
#. §3: `rw [← q, p]`
#. §4: `rw [← p, ← q]`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Try solving the goal by rewriting in both directions. You can also experiment with multiple rewrites at once, using a comma to separate multiple proofs of equality inside the brackets. Why does §0 work but §1 not? Why does §2 or §3 work but §4 not?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "Inverse Invertibility"
msgstr ""

#. §0: `g : B → A`
#. §1: `f (g (f «{x}»)) = f «{x}»`
#. §2: `«{x}» : A`
#. §3: `g (f («{x}»))`
#. §4: `f`
#. §5: `f «{x}»`
#. §6: `apply (surj f «{x}»).choose_spec`
#. §7: `f «{x}» : B`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "If §0 is the name of the inverse function you defined using the axiom of choice, now you are now meant to show that §1 for an arbitrary element §2. This element §3 was chosen using the surjectivity hypothesis so that when you apply §4 you get the element §5 back. Type §6 to apply the other half of the surjectivity hypothesis at the element §7."
msgstr ""

#. §0: `g : ((y : A) → B y) → ((z : A) → C z)`
#. §1: `(x : A) → B x → C x`
#: Game.Levels.DependentWorld.L03_Application
msgid "Note that from a function §0 it would not necessarily be possible to define a dependent function of type §1. Can you use the analogy with the universal quantifier to understand why not?"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `A`
#. §3: `C`
#. §4: `x : A`
#. §5: `f x : B`
#. §6: `g (f x) : C`
#. §7: `exact fun x ↦ ?`
#. §8: `?`
#. §9: `</>`
#. §10: `editor mode`
#. §11: `>_`
#. §12: `typewriter mode`
#. §13: `typewriter mode`
#. §14: `retry`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions §0 and §1 there is a *composite function* from §2 to §3.\n"
"\n"
"It is defined to be the function that sends §4 first to the element §5 and then\n"
"to the element §6.\n"
"\n"
"Can you solve this level in one line by using §7 with the appropriate thing in place of the §8?\n"
"\n"
"Alternatively, you can use other tactics to define the required function step by step.\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled §9 in the upper right hand corner to enter §10. Then delete all the lines of your first proof (or proof attempt). Clicking on §11 takes you back to §12.\n"
"\n"
"You can also delete a proof attempt in line by line in §13 using the §14 button to the right of that line."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "You have two things to prove. To break the goals into pieces, type `constructor."
msgstr ""

#. §0: `P ↔ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `(P → Q) ∧ (Q → P)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "§0, read as &ldquo;§1 if and only if §2&rdquo; is an abbreviation for §3."
msgstr ""

#. §0: `A`
#. §1: `id : A → A`
#. §2: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type §0, the identity function §1 is the function defined by sending and arbitrary element §2 to itself."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Think carefully about what §0 proves and what proofs can be extracted from this."
msgstr ""

#: Game.Levels.EqualityWorld.L10_BossLevel
msgid "Functions out of product types are well-defined, both regarding equalities between elements and equalities between hypotheses."
msgstr ""

#. §0: `And.symm`
#. §1: `P ∧ Q`
#. §2: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "The proof you have just constructed is now recorded as a theorem called §0 in the library to the right.\n"
"\n"
"In fact §1 is true if and only if §2 is true, as we will now demonstrate."
msgstr ""

#. §0: `X`
#. §1: `A`
#. §2: `B`
#. §3: `X → A × B`
#. §4: `(X → A) × (X → B)`
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "For any types §0, §1, and §2, the types §3 and §4 are equivalent."
msgstr ""

#. §0: `intro p`
#. §1: `p : A × B`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The goal is a term of a function type so type §0 to give yourself a term §1."
msgstr ""

#. §0: `cases h : x`
#. §1: `cases k :
#. cases y`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L05_Disjunction
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "Recall §0 and §1 may make it clearer which cases are which."
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P → P`
#. §2: `P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `P`
#. §6: `P`
#. §7: `P`
#. §8: `P`
#. §9: `P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The Boss Level of Negation World previews the next world by studying the relationship between two *classical* tautologies that we have not been able to prove involving a proposition §0.\n"
"\n"
"One statement we have not been able to prove is called *double negation elimination*: §1.\n"
"\n"
"Double negation elimination asserts that if §2 is not false, then §3 must be true.\n"
"\n"
"Another statement we have not been able to prove is called *law of excluded middle*: §4.\n"
"\n"
"The law of excluded middle asserts that either §5 is true or §6 is false.\n"
"\n"
"In Classical World, we'll explore why these statements fall outside the realm of *constructive logic*.\n"
"\n"
"But what we *can* prove constructively is that for any proposition §7, the law of excluded middle for §8 implies double negation elimination for §9.\n"
"\n"
"Have fun!"
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "And Implies Or"
msgstr ""

#. §0: `n`
#. §1: `0`
#. §2: `(∃ m : ℕ, 0 = 2 * m) ∨ (∃ m : ℕ, 0 = 2 * m + 1)`
#. §3: `left`
#. §4: `right`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "You are first asked to prove the base case assuming the natural number §0 from the original statement is §1. Thus your goal is to prove §2. Use the tactic §3 to indicate that you'd like to prove the left-hand statement or §4 to indicate that you'd like to prove the right-hand statement."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What proof strategy is available with an element of a coproduct type?"
msgstr ""

#. §0: `ℕ → ℕ → ℕ`
#. §1: `Nat.add m n`
#. §2: `m + n`
#. §3: `add_zero m : m + 0 = m`
#. §4: `add_succ m n : m + succ n = succ (m + n)`
#. §5: `add_assoc a b c : (a + b) + c = a + (b + c)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The binary addition function §0 is called §1, with notation §2. This is the usual sum of natural numbers, defined via the following two hypotheses:\n"
"\n"
"§3\n"
"\n"
"§4\n"
"\n"
"Other theorems about naturals, such as §5, are proved by induction using these two basic theorems.\""
msgstr ""

#. §0: `«{Q}» → «{P}»`
#. §1: `intro q`
#. §2: `q : «{Q}»`
#. §3: `«{P}»`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "To prove an implication, which in this case has the form §0, type §1 to introduce an assumption §2 and update the goal to §3."
msgstr ""

#. §0: `Nat.pred : ℕ → ℕ`
#. §1: `0`
#. §2: `0`
#. §3: `succ n`
#. §4: `n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "The function §0 is defined by recursion to send §1 to §2 and §3 to §4."
msgstr ""

#. §0: `constructor`
#. §1: `pred : ℕ → ℕ`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Use the tactic §0 to split the level into two goals, the first of which is to define the function §1."
msgstr ""

#. §0: `p : A × B`
#. §1: `p : A × B`
#. §2: `A`
#. §3: `B`
#. §4: `p : A × B`
#. §5: `p.1 : A`
#. §6: `p.2 : B`
#. §7: `p.fst : A`
#. §8: `p.snd : B`
#. §9: `A × B → A`
#. §10: `A × B → B`
#. §11: `p : A × B`
#. §12: `A`
#. §13: `B`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "The elimination rules for product types tell us which elements can be constructed from an element §0.\n"
"\n"
"There are two elimination rules: from an element §1, we may extract an element of §2, thought of as its first component, and also an element of §3, thought of as its second component.\n"
"\n"
"In Lean, the elements defined by projecting from §4 are denoted §5 and §6 or §7 and §8.\n"
"\n"
"These rules define *projection functions* of type §9 and §10, which take an element §11 and return the corresponding components from §12 and §13 respectively.\n"
"\n"
"Your task in this level is to define the first projection function."
msgstr ""

#. §0: `+ : ℕ → ℕ → ℕ`
#. §1: `add_zero n : n + 0 = n`
#. §2: `add_succ m n : m + succ n = succ (m + n)`
#. §3: `0 + n = n`
#. §4: `n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "The addition function §0 is defined by the equations\n"
"\n"
"* §1 and\n"
"* §2.\n"
"\n"
"It is of course also true that §3 for all natural numbers §4, but this equation does not hold by definition.\n"
"\n"
"Instead you have to prove it by induction!\n"
"\n"
"Good luck."
msgstr ""

#. §0: `cases «{p}»`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Type §0 to ask Lean to consider all possible cases involving a proof of false. As there are no cases, this will complete the proof."
msgstr ""

#. §0: `«{m}»`
#. §1: `«{n}»`
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "You can apply induction on either variable §0 or §1. It will be easiest, however, to induct on the same variable we used to define the addition function."
msgstr ""

#: Game.Levels.NegationWorld
msgid "Negation World"
msgstr ""

#. §0: `x = y`
#. §1: `y = x`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Equality is symmetric: if §0 then §1."
msgstr ""

#. §0: `false : Bool`
#. §1: `true : Bool`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "The elements §0 and §1 are not equal."
msgstr ""

#. §0: `«{P}» → «{Q}»`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "Which tactics can be used to prove §0 with our given assumptions?"
msgstr ""

#. §0: `f : A → B`
#. §1: `f`
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "The function §0 is an isomorphism if and only if §1 is invertible."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "What implications can you extract from §0?"
msgstr ""

#. §0: `cases`
#. §1: `Empty`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Use the §0 tactic to consider all possible cases for elements of §1."
msgstr ""

#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "The converse implication is more subtle, and will be addressed in the Classical World."
msgstr ""

#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "Unit Proposition"
msgstr ""

#. §0: `«{C}»`
#. §1: `exact`
#. §2: `apply`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Now that the goal is an element of type §0 there are several ways to proceed. You can use §1 or §2."
msgstr ""

#. §0: `Function.uncurry : (A → B → C) → (A × B → C)`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"The operations of *currying* and *uncurrying* are inverses in a sense we will be able to make precise later."
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "First Projection"
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ x y : A, f x = f y → x = y`
#. §2: `f : A → B`
#. §3: `g : B → C`
#. §4: `g ∘ f : A → C`
#. §5: `f`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Recall that a function §0 is *injective* if §1.\n"
"\n"
"In this level, we will prove that if §2 and §3 are functions, then if the composite §4 is injective, the function §5 must also be injective."
msgstr ""

#. §0: `exact b`
#. §1: `assumption`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Both §0 and §1 can be used here."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → (A → B) → B`
#. §3: `a : A`
#. §4: `ev a`
#. §5: `(A → B) → B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "For types §0 and §1, the evaluation function has type §2, meaning that for §3, §4 has type §5."
msgstr ""

#. §0: `cases «{h}»`
#. §1: `rcases «{h}» with pr | ps | qr | qs`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Uses §0 or §1 to break the hypothesis into the constituent cases"
msgstr ""

#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Composition Revisited"
msgstr ""

#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Noncontradiction"
msgstr ""

#. §0: `Q`
#. §1: `exact «{h}».2`
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now Lean reminds you of the other goal, which is to prove §0. Type §1 to supply this proof."
msgstr ""

#. §0: `«{P}»`
#. §1: `Show more help!`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now your goal is a proof of §0. Can you figure out how to finish the proof? If you need a reminder, click the button §1"
msgstr ""

#. §0: `Sum.inl : A → A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "The function §0 provides the first introduction rule for coproduct types. In the next level, we will explore the second introduction rule."
msgstr ""

#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Not Equal"
msgstr ""

#. §0: `exact ⟨Function.curry, Function.uncurry, fun f ↦ rfl, fun f ↦ rfl⟩`
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "Note this level can be solved in one line with\n"
"§0. Can you make sense of this proof?"
msgstr ""

#. §0: `let e := «{f}» «{a}»`
#. §1: `let e : Empty := «{f}» «{a}»`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Use §0 or §1 to add an element of the empty type to the list of assumptions."
msgstr ""

#. §0: `f : A → B`
#. §1: `x y : A`
#. §2: `p : x = y`
#. §3: `congrArg f p : f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "For a function §0 between types, elements §1, and a proof §2, then §3."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#. §3: `\\circ`
#. §4: `∘`
#. §5: `x : A`
#. §6: `(g ∘ f) x`
#. §7: `g (f x)`
#. §8: `g`
#. §9: `f`
#. §10: `g ∘ f`
#. §11: `exact g ∘ f`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Lean has built in notation for the composite of §0 and §1 namely §2, using §3 to type §4.\n"
"\n"
"Given §5, §6 is defined to be the element §7, which is why the function §8 appears on the left of §9 in the notation §10.\n"
"\n"
"Try solving this level with §11."
msgstr ""

#. §0: `cases`
#. §1: `rcases`
#. §2: `«{p}»`
#. §3: `B ⊕ C`
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "You can use §0 or §1 either on §2 to split it up into components or directly on its component in §3.Be careful to use the syntax that is appropriate for terms of product or coproduct types, respectively."
msgstr ""

#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
msgid "Conjunction Symmetry"
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `⟨a, b⟩ : A × B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "By pairing any element §0 with any element §1, there is an element §2."
msgstr ""

#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "Paired Projections"
msgstr ""

#. §0: `h : ∃ a : A, P a`
#. §1: `P : A → Prop`
#. §2: `h.choose_spec`
#. §3: `h.choose : A`
#. §4: `P (h.choose)`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Given a proof §0 for some §1, §2 gives a proof that the\n"
"element §3 satisfies §4."
msgstr ""

#. §0: `P → Q`
#. §1: `Q → R`
#. §2: `P → R`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "If §0, then if §1, then §2."
msgstr ""

#. §0: `P`
#. §1: `P`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "If the proposition §0 is true, then §1 is true."
msgstr ""

#. §0: `apply (surj «{b}»).choose_spec`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Type §0 to apply the other half of the surjectivity hypothesis."
msgstr ""

#. §0: `«{h}»`
#. §1: `«{P}»`
#. §2: `«{Q}»`
#. §3: `«{Q}»`
#. §4: `«{P}»`
#. §5: `apply «{h}»`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "The hypothesis §0 can be used to convert a proof of §1 into a proof of §2. This can be thought of as a step that reduces the problem of proving §3 to the problem of proving §4. To apply this hypothesis type §5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L08_Bijectivity
msgid "Bijectivity"
msgstr ""

#. §0: `Sum.inr : B → A ⊕ B`
#. §1: `A ⊕ B`
#. §2: `B`
#. §3: `apply Sum.inr`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "To use the built in function §0 to change the goal from §1 to §2 type §3."
msgstr ""

#. §0: `Empty`
#. §1: `Empty`
#. §2: `A`
#. §3: `A`
#. §4: `Empty.elim : Empty → A`
#. §5: `Empty → A`
#. §6: `X`
#. §7: `A`
#. §8: `x : X`
#. §9: `A`
#. §10: `Empty`
#. §11: `A`
#. §12: `Empty`
#: Game.Levels.EmptyWorld
msgid "In this world, we will introduce the *empty type*, which is commonly denoted by §0 in Lean.\n"
"\n"
"In general, types are characterized by:\n"
"* Introduction rules: which explain how to construct elements of the given type.\n"
"* Elimination rules: which explain how to use elements of the given type to construct elements of other types.\n"
"\n"
"In the case of the empty type, there are no introduction rules. This corresponds colloquially to the idea that the empty type has &ldquo;no elements.&rdquo;\n"
"\n"
"The elimination rule for the empty type defines a function from §1 to any other type §2, with no obligations on the type §3. This provides a canonical element §4 of the function type.\n"
"\n"
"There is another way to understand why the type §5 should always have an element.\n"
"\n"
"In order to define a function from a type §6 to a type §7 one must fulfill the following obligation: for each §8 one must specify an element of type §9.\n"
"\n"
"In the case of a function from the type §10 to a type §11, there are no obligations because the empty type has no elements.\n"
"\n"
"In this world, we will explore constructions involving the §12 type."
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#. §2: `P → Q`
#. §3: `¬ Q → ¬ P`
#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "In this level, we will study the relationship between an implication §0 and its *contrapositive*, which is the statement §1.\n"
"\n"
"The objective in this level is to prove that §2 implies §3.\n"
"\n"
"In fact, the construction of this proof should feel very familiar!\n"
"\n"
"The other direction of implication is considerably more subtle and will be discussed in Classical World."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P ∧ Q) ∧ R`
#. §4: `P ∧ (Q ∧ R)`
#. §5: `P ∧ Q ∧ R`
#. §6: `P ∧ (Q ∧ R)`
#. §7: `h : (P ∧ Q) ∧ R`
#. §8: `h.1 : P ∧ Q`
#. §9: `h.2 : R`
#. §10: `h.1.1 : P`
#. §11: `h.1.2 : Q`
#. §12: `k : P ∧ (Q ∧ R)`
#. §13: `k.1 : P`
#. §14: `k.2 : Q ∧ R`
#. §15: `k.2.1 : Q`
#. §16: `k.2.2 : R`
#. §17: `p : P`
#. §18: `q : Q`
#. §19: `r : R`
#. §20: `⟨⟨p, q⟩, r⟩ : (P ∧ Q) ∧ R`
#. §21: `⟨p, ⟨q, r⟩⟩ : P ∧ (Q ∧ R)`
#. §22: `⟨p, q, r⟩ : P ∧ Q ∧ R`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "For propositions §0, §1, and §2, §3 is true if and only if §4 is true.\n"
"\n"
"Lean likes to drop parentheses whenever possible so uses §5 as an abbreviation for §6. While it's difficult to remember this convention, at least the two possible statements are logically equivalent!\n"
"\n"
"Given a proof §7, we obtain proofs §8 and §9. From the first of these,\n"
"we obtain further proofs §10 and §11.\n"
"\n"
"A proof §12 can be decomposed similarly, using different notation. Now we have proofs §13 and §14 and the latter proof decomposes further as §15 and §16.\n"
"\n"
"Similarly, given proofs §17, §18, §19, then §20 while §21 are proofs of the triple conjunction. Lean allows the shorthand §22 for the latter proof.\n"
"\n"
"Your goal in this level is to prove the associativity of conjunction."
msgstr ""

#. §0: `P`
#. §1: `p : P`
#. §2: `p`
#. §3: `P`
#. §4: `P`
#. §5: `assumption`
#. §6: `p`
#. §7: `exact p`
#. §8: `assumption`
#. §9: `exact`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "We warm up by revisiting our first mathematical theorem, proven already in Type World.\n"
"\n"
"This theorem concerns an arbitrary proposition §0 which can be any well-formed mathematical statement.\n"
"\n"
"The hypothesis §1  can be thought of as providing a *proof* §2 that the proposition §3 is true. Our objective is to conclude that §4 is true, given this hypothesis.\n"
"\n"
"This is true by assumption, and you can type §5 to tell Lean this.\n"
"\n"
"But it is a bit more precise to tell Lean this is true by the assumption §6 which can be done by typing §7.\n"
"\n"
"If it is helpful to review the §8 and §9 tactics, you can read more about them in the tactic library on the upper right."
msgstr ""

#. §0: `intro`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "The goal is still an implication, so try another §0."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that you've completed the proof in the first case, Lean expects you to provide a proof in the second case."
msgstr ""

#. §0: `exact ⟨p,q⟩`
#. §1: `\\<`
#. §2: `\\>`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "Alternatively, you can type §0 using §1 and §2 to type the angle brackets."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "In the next levels, we will study general properties of surjective functions."
msgstr ""

#: Game.Levels.ClassicalWorld
msgid "Classical World"
msgstr ""

#. §0: `«{a}»`
#. §1: `f «{a}» = «{b}»`
#. §2: `have ha : f a = b := (surj b).choose_spec`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "You can also add the proof that your element §0 satisfies the equation §1 to the context by typing §2."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Let us now explore other implications that are provable with this strategy."
msgstr ""

#. §0: `! «{x}» = ! «{y}»`
#. §1: `! «{x}»`
#. §2: `not «{x}»`
#. §3: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "You should also introduce the hypothesis §0. Here Lean writes §1 for §2, where §3 is the boolean negation function."
msgstr ""

#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Using Or"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Surjectivity"
msgstr ""

#: Game.Levels.DependentWorld.L02_Functions
msgid ""
msgstr ""

#. §0: `intro n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Start with §0 to prove the universally quantified statement."
msgstr ""

#. §0: `a : A`
#. §1: `B`
#. §2: `const a : B → A`
#. §3: `x : B`
#. §4: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "For a term §0 and a type §1, §2 is the function defined by sending §3 to §4."
msgstr ""

#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "Note the similarly with the first level of Equality World. In fact, all of the statements we have proven about arbitrary elements of types can be reinterpreted as proving universally quantified propositions."
msgstr ""

#. §0: `apply Function.Injective.of_comp succ pred`
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "One of several options is to start the proof with §0, specializing a general result from Advanced Function World to this particular case. You are now ready for the Boss Level."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "The successor function is injective."
msgstr ""

#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "Left Inclusion"
msgstr ""

#. §0: `p : P`
#. §1: `h : P → Q`
#. §2: `Q`
#. §3: `h p : Q`
#. §4: `h`
#. §5: `P → Q`
#. §6: `p`
#. §7: `P`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Modus ponens tells us that under hypotheses §0 and §1 then §2 is true.\n"
"\n"
"The proof is given by §3, thought of as the result of applying the proof §4 of the implication §5 to the proof §6 of §7.\n"
"\n"
"Can you see why the following theorem is another form of modus ponens?"
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "Commuting Addition"
msgstr ""

#: Game.Levels.DependentWorld.L01_Types
msgid "Types"
msgstr ""

#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Composing Functions"
msgstr ""

#. §0: `«{ne}»`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "How can you use the hypothesis §0?"
msgstr ""

#. §0: `f a : B`
#. §1: `f`
#. §2: `a`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "While the tactics used in this level and the previous one are different, both solutions ultimately tell Lean to use the element §0 built by applying the function §1 to the element §2."
msgstr ""

#. §0: `h : P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `P`
#. §4: `Q`
#. §5: `R`
#. §6: `P`
#. §7: `R`
#. §8: `Q`
#. §9: `Q`
#. §10: `R`
#. §11: `P`
#. §12: `h : P ∨ Q`
#. §13: `cases h`
#. §14: `P`
#. §15: `Q`
#. §16: `cases`
#. §17: `h : P ∨ Q`
#. §18: `rcases h with p | q`
#. §19: `cases h`
#. §20: `p : P`
#. §21: `q : Q`
#. §22: `p`
#. §23: `q`
#. §24: `A ⊕ B`
#. §25: `P ∨ Q`
#. §26: `Q ∨ P`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Given a hypothesis §0, we know that *either* §1 or §2 is true (or possibly both are true).\n"
"\n"
"But we don't know *which* of §3 or §4 is true.\n"
"\n"
"If we want to use a hypothesis like this to prove some other proposition §5 is true we need proofs that cover either of the two cases: that is, we need to show that §6 implies §7 (whether or not §8 is true) and also that §9 implies §10 (whether or not §11 is true).\n"
"\n"
"If we have an assumption of the form §12, then type §13 to ask Lean to consider both cases: the first being that §14 is true and the second being that §15 is true.\n"
"\n"
"There is another tactic, similar to §16, which allows you to give explicit names for the hypotheses assumed in each case.\n"
"\n"
"When given a hypothesis §17, then §18 can be used in place of §19 to give hypotheses §20 in the first case and §21 in the second. (Here you can choose any variable names for §22 and §23.)\n"
"\n"
"This proof strategy should be reminiscent of a definition by cases of a function mapping out of a coproduct type §24. Recall the same tactics may be used for that sort of construction.\n"
"\n"
"In this level, use the strategy of arguing by cases to prove that or is symmetric, that is that §25 implies §26."
msgstr ""

#. §0: `rw [«{p}», «{q}», «{r}»]`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "Recall you can rewrite along multiple hypothesized equalities at once by typing §0."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ≃ B`
#. §3: `A`
#. §4: `B`
#. §5: `⟨f, g, α, β⟩ : A ≃ B`
#. §6: `f : A → B`
#. §7: `g : B → A`
#. §8: `α : ∀ a : A, g (f a) = a`
#. §9: `β : ∀ b : B, f (g b) = b`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "For types §0 and §1, §2 is the type of equivalences between §3 and §4. Its elements have the form §5 where §6, §7, §8, and §9."
msgstr ""

#. §0: `P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `«{rs}» : «{R}» ∨ «{S}»`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "This completes the proof in the case where §0 holds because §1 holds. Now we've started the case where §2 holds, which requires another case split over the proof §3."
msgstr ""

#. §0: `P ∨ Q`
#. §1: `Or.inl : P → P ∨ Q`
#. §2: `Or.inr : Q → P ∨ Q`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way. Alternatively, you can prove §0 by applying either of the implications §1 and §2 that are now in the library."
msgstr ""

#: Game.Levels.DisjunctionWorld
msgid "Disjunction World"
msgstr ""

#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "Evaluation"
msgstr ""

#: Game.Levels.DependentWorld.L02_Functions
msgid "Functions"
msgstr ""

#. §0: `constructor`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "The statement is a conjunction so use §0 to break into subgoals."
msgstr ""

#. §0: `A`
#. §1: `x : A`
#. §2: `y : A`
#. §3: `x = y`
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "For any type §0, for all elements §1, there exists an element §2, so that §3."
msgstr ""

#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Using Functions Backwards"
msgstr ""

#. §0: `w x y z : A`
#. §1: `w = x `
#. §2: `x = y`
#. §3: `y = z`
#. §4: `w = z`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "For all §0 if §1 and §2 and §3 then §4."
msgstr ""

#. §0: `Empty`
#. §1: `Empty`
#. §2: `A`
#. §3: `Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The type §0 has no elements &mdash; or, more precisely, the type §1 has no introduction rules.\n"
"\n"
"Consequently, for any other type §2, there is always a function §3.\n"
"\n"
"The task in this level is to define it."
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "The goal is a product type. You can use §0 to split into two goals, defining each component function separately."
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ x y : A, f x = f y → x = y`
#. §2: `f : A → B`
#. §3: `g : B → C`
#. §4: `g ∘ f : A → C`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Recall that a function §0 is *injective* if §1.\n"
"\n"
"In this level, we will prove that if §2 and §3 are both injective functions, then the composite §4 must also be injective."
msgstr ""

#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "Excluded Middle"
msgstr ""

#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Modus Ponens Again"
msgstr ""

#. §0: `x = x`
#. §1: `x : A`
#. §2: `x = y`
#. §3: `y = x`
#. §4: `x = y → y = x`
#. §5: `p : x = y`
#. §6: `y = x`
#. §7: `rw`
#. §8: `p : x = y`
#. §9: `p : x = y`
#. §10: `rw [p]`
#. §11: `x`
#. §12: `y`
#. §13: `y = x`
#. §14: `p`
#. §15: `y = y`
#. §16: `rw [← p]`
#. §17: `\\l`
#. §18: `←`
#. §19: `y`
#. §20: `x`
#. §21: `rw [← p]`
#. §22: `rw [p]`
#. §23: `x = x`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "We've already seen that equality is *reflexive*, meaning that §0 for any element §1.\n"
"\n"
"In this level, we will prove that equality is also symmetric: if §2 then §3.\n"
"\n"
"To prove the implication §4 we may assume that we have a proof §5. This allows us to appeal to the elimination rule of equality types to prove our goal that §6 also holds.\n"
"\n"
"To do this, we will make use of the §7 tactic, pronounced &ldquo;rewrite,&rdquo; which is the primary way we will use a hypothesis of the form §8.\n"
"\n"
"If we have a hypothesis §9, then §10 will look for the first instance of the element §11 in the goal type and change it to §12.\n"
"\n"
"In the case here, the goal is to show that §13, so rewriting along §14 will change the goal to §15, which is easier to prove.\n"
"\n"
"This tactic can be used in two directions: §16 &mdash; using §17 to type §18 &mdash; will look for the first instance of a §19 in the goal and replace it with §20. Thus typing §21 instead of §22 will change the goal to §23.\n"
"\n"
"Try solving this level using both directions of rewriting."
msgstr ""

#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Note the goal window in the interactive theorem prover keeps track of exactly what proposition you are trying to prove."
msgstr ""

#. §0: `cases x <;> cases y <;> rfl`
#. §1: `<;>`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "This proof can be written in one line as §0 where the §1 means &ldquo;do the following in all cases&rdquo;."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "You have a very close approximation to this function in your library. Can you see how to modify it to have the form you need here?"
msgstr ""

#. §0: `Unit ⊕ Unit`
#. §1: `Bool`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "The types §0 and §1 are equivalent."
msgstr ""

#: Game.Levels.NegationWorld.L01_ExFalso
msgid "Ex Falso"
msgstr ""

#. §0: `«{A}»`
#: Game.Levels.ProductWorld.L01_Pairing
#: Game.Levels.ProductWorld.L01_Pairing
msgid "Now Lean asks you to supply an element of type §0. Which tactic applies here?"
msgstr ""

#. §0: `f : Bool → Bool`
#. §1: `f true = false ∧ f false = true`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Now you are asked to check that the function §0 that you just defined actually *is* the negation function. Specifically, you are asked to check that §1."
msgstr ""

#. §0: `cases`
#. §1: `rcases`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "This proves the symmetry of disjunction. Practice using both the §0 and §1 tactics to get used to them."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Now how do we prove a conjunction?"
msgstr ""

#. §0: `P : A → Prop`
#. §1: `∀ x : A, ¬ (P x)`
#. §2: `¬ (∃ x : A, P x)`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Given a family of propositions §0,  §1 is logically equivalent to §2"
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "This can be solved in two ways. Can you find them both?"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `¬ (P ∨ Q)`
#. §3: `¬ P ∧ ¬ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "For any propositions §0 and §1, the propositions §2 and §3 are logically equivalent."
msgstr ""

#. §0: `assumption`
#: Game.Levels.TypeWorld.L01_Elements
msgid "The §0 tactic tries to solve the main goal using a hypothesis of compatible type, or else fails."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `∃ x : A, ¬ (P x)`
#. §2: `¬ (∀ x : A, P x)`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "Given a family of propositions §0,  §1 implies §2"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "We will explore the precise relationship between bijective functions and invertible functions soon. But first, we show that the inverse of an invertible function is again invertible."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Sum.inl : A → A ⊕ B`
#. §3: `A`
#. §4: `A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types §0 and §1, the function §2 can be used to include elements of type §3 as elements of the coproduct type §4."
msgstr ""

#. §0: `constructor`
#: Game.Levels.DependentWorld.L05_Currying
msgid "Recall that equivalences of types require four separate pieces of data. Type §0 to split the goal up into the four proof obligations."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "In the next levels, we will study general properties of injective functions."
msgstr ""

#. §0: `and : Bool → Bool → Bool`
#: Game.Levels.BooleanWorld.L04_ConjunctionSymmetry
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "The function §0 is symmetric."
msgstr ""

#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "In the next levels, we will study the effect of negating existential and universal quantifiers."
msgstr ""

#. §0: `«{p}»`
#. §1: `exact «{p}»`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "To use the hypothesis §0 to reach this conclusion type §1."
msgstr ""

#: Game.Levels.DependentWorld.L06_BossLevel
msgid "The type theoretic axiom of choice characterizes dependent functions into a dependent pair type."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A × B) × C`
#. §4: `A × (B × C)`
#. §5: `p : (A × B) × C`
#. §6: `p.1 : A × B`
#. §7: `p.2 : C`
#. §8: `p.1 : A × B`
#. §9: `p.1.1 : A`
#. §10: `p.1.2 : B`
#. §11: `q : A × (B × C)`
#. §12: `q.1 : A`
#. §13: `q.2 : B × C`
#. §14: `q.2 : B × C`
#. §15: `q.2.1 : B`
#. §16: `q.2.2 : C`
#. §17: `((A × B) × C) → (A × (B × C))`
#. §18: `(A × (B × C)) → ((A × B) × C)`
#. §19: `(((A × B) × C) → (A × (B × C))) × ((A × (B × C)) → ((A × B) × C))`
#. §20: `(A × B) × C`
#. §21: `A × (B × C)`
#. §22: `A × B × C`
#. §23: `A × (B × C)`
#. §24: `A × B × C`
#. §25: `(A × B) × C`
#. §26: `a : A`
#. §27: `b : B`
#. §28: `c : C`
#. §29: `⟨a,b,c⟩ : A × B × C`
#. §30: `⟨a, ⟨b,c⟩⟩ : A × (B × C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Given three types §0, §1, and §2, the product type construction may be iterated to define types §3 and §4.\n"
"\n"
"A term §5 has projections §6 and §7. Then §8 has further projections §9 and §10.\n"
"\n"
"A term §11 has projections §12 and §13. Then §14 has further projections §15 and §16.\n"
"\n"
"Use this to define a *pair* of functions, the first of type §17 and the second of type §18. That is, define a single element of type\n"
"\n"
"§19\n"
"\n"
"These functions indicate that the product types §20 and §21 are closely related.\n"
"\n"
"By convention, the notation §22 is an abbreviation for the product type §23.\n"
"\n"
"Lean also provides a shorthand notation for elements of §24 that is not available for elements of §25.\n"
"\n"
"Given §26, §27, and §28, we may write §29 to abbreviate §30."
msgstr ""

#. §0: `«{i}»`
#. §1: `«{p}»`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What can we prove with the hypotheses §0 and §1?"
msgstr ""

#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Think about where the contradiction will ultimately arise from."
msgstr ""

#. §0: `g_is_surj`
#. §1: `«{c}»`
#. §2: `have gc := g_is_surj «{c}»`
#. §3: `let ⟨b, hb⟩ := g_is_surj c`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "To use the hypothesis §0 at §1 type §2 or §3."
msgstr ""

#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "For the Boss Level of Empty World, we construct something that is just weird.\n"
"\n"
"Your challenge is to define functions in both directions between types that are formed by iteratively applying certain type forming operations to the empty type.\n"
"\n"
"Interestingly each of these types has an element, which can be used to define the functions if you wish.\n"
"\n"
"There are other strategies to defining the funtions as well, so you may enjoy trying to solve this level in multiple ways.\n"
"\n"
"Have fun!"
msgstr ""

#. §0: `x y : A`
#. §1: `x`
#. §2: `y`
#. §3: `p : x = y`
#. §4: `P`
#. §5: `Q`
#. §6: `P`
#. §7: `Q`
#. §8: `p : P ↔ Q`
#. §9: `A`
#. §10: `B`
#. §11: `p : A ≃ B`
#. §12: `A ≃ B`
#. §13: `A`
#. §14: `B`
#. §15: `A`
#. §16: `B`
#. §17: `f : A → B`
#. §18: `g : B → A`
#. §19: `α : ∀ a : A, g (f a) = a`
#. §20: `β : ∀ b : B, f (g b) = b`
#. §21: `P ↔ Q`
#. §22: `f : P → Q`
#. §23: `g : Q → P`
#. §24: `A`
#. §25: `B`
#. §26: `B`
#. §27: `A`
#. §28: `α`
#. §29: `g ∘ f = id`
#. §30: `β`
#. §31: `f ∘ g = id`
#. §32: `f`
#. §33: `g`
#. §34: `f`
#. §35: `g`
#. §36: `A`
#. §37: `B`
#. §38: `⟨f, g, α, β⟩ : A ≃ B`
#: Game.Levels.EquivalenceWorld
msgid "What does it mean for two things to be &ldquo;the same&rdquo;?\n"
"\n"
"The answer depends on what sort of things we are talking about.\n"
"\n"
"We have seen what it means for two elements of the same type to be the same. Given §0, we think of §1 and §2 as being &ldquo;the same&rdquo; if they are *equal*, meaning there is an element §3 in the equality type.\n"
"\n"
"We have also seen what it means for two propositions to be the same. Given propositions §4 and §5, we think of §6 and §7 as being &ldquo;the same&rdquo; if they are *logically equivalent*, meaning there is an element §8.\n"
"\n"
"What does it mean for two types to be &ldquo;the same&rdquo;?\n"
"\n"
"In this level, we will learn the answer: two types §9 and §10 are &ldquo;the same&rdquo; if they are *equivalent*. This means there is some element §11 in the type §12 of *equivalences* between §13 and §14 that we will introduce.\n"
"\n"
"To define an equivalence between §15 and §16 we need four pieces of data:\n"
"\n"
"* a function §17\n"
"* a function §18\n"
"* a proof §19\n"
"* a proof §20\n"
"\n"
"The first two pieces of data resemble the data required by a logical equivalence §21. For that one needs proofs §22 and §23 of the implications in each direction.\n"
"\n"
"The remaining data is relevant because functions carry more information than implications. In particular, there may be multiple functions from §24 to §25 and from §26 to §27.\n"
"\n"
"By function extensionality, the proof §28 witnesses the fact that §29 while the proof §30 witnesses the fact that §31. Together this tells us that the functions §32 and §33 are *inverses*.\n"
"\n"
"In other words, if §34 and §35 are thought of as operations that exchange elements of types §36 and §37, both operations can be undone by applying the other operation.\n"
"\n"
"The data §38 is sometimes also referred to as an *isomorphism* or a *bijection* but in Lean the term *equivalence* is more common."
msgstr ""

#. §0: `∃ (x : A), P x`
#. §1: `use`
#. §2: `a : A`
#. §3: `P a`
#. §4: `∃ (x y : A), P x y`
#. §5: `use a, a'`
#. §6: `use`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "For goals of the form §0 the tactic §1 can be used to provide an element §2 which will satisfy §3. For multiple constructors like §4, you can provide comma-separated values: §5.\n"
"\n"
"Note that the version of the §6 tactic for this game is somewhat weaker than the real one in Mathlib, which automatically tries to solve the remaining goal."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `a : A`
#. §3: `const a : B → A`
#. §4: `x : B`
#. §5: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "For any types §0 and §1 and element §2, there is a constant function §3 that sends any §4 to the element §5."
msgstr ""

#. §0: `induction «{n}» with k hk`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "To start a proof by induction in Lean, type §0. This will split the goal into two cases: proving the base case and the inductive step."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "Adding Successors"
msgstr ""

#. §0: `T ∨ U → V ∧ Y`
#. §1: `Q → P → T`
#. §2: `Y → Q → W`
#. §3: `(V ∧ W) ∨ (X ∧ Y) → Z`
#. §4: `(R → S → U) ∧ (V → R → X)`
#. §5: `P ∧ (Q ∨ R) ∧ S`
#. §6: `Z`
#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "If §0 and §1 and §2 and\n"
"§3 and §4 then  §5 implies §6."
msgstr ""

#. §0: `And.symm`
#. §1: `exact And.symm`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? In fact, we gave a name §0 to the proof given in the previous level, as you can see in the list of theorems to the right. Try typing §1 at an appropriate place in your proof."
msgstr ""

#. §0: `A`
#. §1: `a : A`
#. §2: `a = a`
#. §3: `rfl : a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For a type §0 and element §1, the proposition §2 is true because there is a proof\n"
"§3 witnessing the reflexivity of equality."
msgstr ""

#. §0: `Function.curry : (A × B → C) → (A → B → C)`
#. §1: `A → B → C`
#. §2: `A × B → C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"We'll now study the reverse process, which converts a function of type §1 to a function of type §2."
msgstr ""

#. §0: `f : A → B`
#. §1: `∃ g : B → A, (∀ a : A, g (f a) = a) ∧ (∀ b : B, f (g b) = b)`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "A function §0 is *invertible* if §1."
msgstr ""

#. §0: `P ∨ Q`
#. §1: `R ∨ S`
#. §2: `P ∧ R`
#. §3: `P ∧ S`
#. §4: `Q ∧ R`
#. §5: `Q ∧ S`
#. §6: `P ∨ Q`
#. §7: `R ∨ S`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "A more involved form of distributivity is also true.\n"
"\n"
"If §0 holds and §1 holds then at least one of the following four propositions holds: §2 or §3 or §4 or §5.\n"
"\n"
"Conversely, if either of these four conjunctions holds, then §6 holds and §7 holds.\n"
"\n"
"Demonstrate the following logical equivalence."
msgstr ""

#. §0: `B ⊕ A → A ⊕ B`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The same construction defines a function of type §0, demonstrating the symmetry of the coproduct."
msgstr ""

#: Game.Levels.ConjunctionWorld
msgid "Conjunction World"
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Look carefully at the order of the arguments of §0."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "In the next level, we will learn what it means for a function to be both injective and surjective."
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "From Empty"
msgstr ""

#. §0: `«{i}»`
#. §1: `«{nq}»`
#. §2: `have`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "What can you prove using §0 and §1? Use the tactic §2 to add this to your context."
msgstr ""

#. §0: `«{P}» → «{P}»`
#. §1: `intro p`
#. §2: `p : «{P}»`
#. §3: `«{P}»`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "When the goal has the form §0, type §1 to introduce an assumption §2 and update the goal to §3."
msgstr ""

#. §0: `P : ℕ → Prop`
#. §1: `P 0 → (∀ k : ℕ, P k → P (succ k)) → (∀ n : ℕ, P n)`
#. §2: `∀ n : ℕ, P n`
#. §3: `P 0`
#. §4: `∀ k : ℕ, P k → P (succ k)`
#. §5: `P : ℕ → Type`
#. §6: `P 0 → (∀ k : ℕ, P k → P (succ k)) → (∀ n : ℕ, P n)`
#. §7: `p_0 : P 0`
#. §8: `k : ℕ`
#. §9: `p_succ k : P k → P (succ k)`
#. §10: `n : ℕ`
#. §11: `P n`
#. §12: `fun _ ↦ A : ℕ → Type`
#. §13: `A`
#. §14: `A → (ℕ → A → A) → (ℕ → A)`
#. §15: `f_0 : A`
#. §16: `f_succ : ℕ → A → A`
#. §17: `ℕ → A`
#. §18: `f : ℕ → A`
#. §19: `f 0 = f_0`
#. §20: `f (succ k) = f_succ k (f k)`
#. §21: `pred : ℕ → ℕ`
#. §22: `pred 0 = 0`
#. §23: `pred (succ k) = k`
#. §24: `ℕ → A`
#. §25: `fun n ↦ match n with | zero => ? | succ k => ?`
#. §26: `?`
#. §27: `A`
#. §28: `f_0 : A`
#. §29: `f_succ : ℕ → A → A`
#. §30: `fun n ↦ match n with | zero => f_0 | succ k => f_succ k (f k)`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Recall the principle of mathematical induction, which applies to an arbitrary family of propositions\n"
"§0 and asserts that\n"
"\n"
"§1\n"
"\n"
"That is, to prove §2 it suffices to verify:\n"
"* the base case §3 and\n"
"* the inductive step §4.\n"
"\n"
"The full elimination rule of the type of natural numbers is known in traditional foundations as the\n"
"*principle of mathematical recursion*. It applies to an arbitrary family of types §5 and defines an element of type\n"
"\n"
"§6\n"
"\n"
"The meaning is now slightly different as the arrows should be read as functions rather than implication.\n"
"\n"
"This says that:\n"
"\n"
"* given an element §7\n"
"* and a function that for all §8 defines a function §9\n"
"\n"
"then there is a function that for all §10 chooses an element of type §11.\n"
"\n"
"This is easiest to understand in the case of a constant type family §12 defined using a type §13.\n"
"\n"
"Now recursion defines a function of type §14. This says that:\n"
"\n"
"* given an element §15\n"
"* and a function §16\n"
"\n"
"then we may recursively define a function §17.\n"
"\n"
"We define the function §18 by specifying that\n"
"* §19 and\n"
"* §20.\n"
"Formally speaking, these equalities comprise the *computation rules* for the natural numbers type.\n"
"\n"
"In this level, your objective is to define a particular function §21 by recursion so that\n"
"* §22 and\n"
"* §23.\n"
"\n"
"In Lean, a function of type §24 can be defined recursively using the syntax §25 where each §26 is replaced by an appropriate element of §27.\n"
"\n"
"For example, using the data of §28 and §29, the corresponding recursively defined function is\n"
"\n"
"§30."
msgstr ""

#. §0: `n`
#. §1: `n + 0 = n`
#. §2: `0 + n = n`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
msgid "For all natural numbers §0, §1 and §2."
msgstr ""

#. §0: `P → Q`
#. §1: `¬ Q → ¬ P`
#. §2: `¬ Q → ¬ P`
#. §3: `P → Q`
#. §4: `¬ Q → ¬ P`
#. §5: `P → Q`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "We have seen that the implication §0 implies the implication §1.\n"
"\n"
"The implication §2 is called the *contrapositive* of §3.\n"
"\n"
"In classical logic, these two statements are logically equivalent.\n"
"\n"
"That means, arguing classically, we can prove that §4 implies §5.\n"
"\n"
"Can you figure out how to prove this?"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#. §3: `x : A`
#. §4: `g (f x)`
#. §5: `Function.comp : (B → C) → (A → B) → (A → C)`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions §0 and §1, the *composite function* §2 is defined to send §3 to the element §4. *Composition* itself defines a function §5 between function types."
msgstr ""

#. §0: `Classical.em P : P ∨ ¬ P`
#. §1: `em _`
#. §2: `_`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "The classical tautology §0 has been added to your library of theorems and can be referred to by the name §1, with the desired proposition replacing the §2, whenever classical reasoning is open."
msgstr ""

#. §0: `«{c}».1`
#. §1: `«{c}».2`
#. §2: `«{c}» : P ∧ ¬ P`
#. §3: `have := «{c}».1`
#. §4: `have := «{c}».2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "Recall that §0 and §1 are the notations used for components of a conjunction, like §2. You can use these names directly or introduce them as assumptions with §3 and §4."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#. §0: `«{n}».succ`
#. §1: `succ «{n}»`
#. §2: `«{n}»`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Here you are asked to show that the value of the function you have just defined at §0, i.e., at §1, equals §2."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `Q`
#. §5: `P`
#. §6: `P`
#. §7: `Q`
#. §8: `(P → Q) ∧ (Q → P)`
#. §9: `P ↔ Q`
#. §10: `(P → Q) ∧ (Q → P)`
#. §11: `P ↔ Q`
#. §12: `P`
#. §13: `Q`
#. §14: `↔`
#. §15: `\\iff`
#. §16: `↔`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Two propositions §0 and §1 are *logically equivalent* if §2 implies §3 and §4 also implies §5.\n"
"\n"
"The assertion that §6 and §7 are logically equivalent can be expressed by the compound proposition §8.\n"
"\n"
"Because this notion will appear frequently in what follows, we introduce §9 as a useful shorthand for §10.\n"
"\n"
"The proposition §11 asserts that §12 is true *if and only if* §13 is true. In fact, the symbol §14 is typed using §15.\n"
"\n"
"See the library of definitions to the right for a reminder about what the symbol §16 means.\n"
"\n"
"The notion of logical equivalence enables us to upgrade our understanding of associativity of symmetry as follows."
msgstr ""

#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "Proving Implied Assumption"
msgstr ""

#. §0: `ev : A → (A → B) → B`
#. §1: `fun a f ↦ f a`
#. §2: `(A → B) → A → B`
#. §3: `fun f a ↦ f a`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "The evaluation function has type §0 and is defined by the formula §1. By swapping variables, we can also think of evaluation as defining a function §2 where this latter function is defined by §3."
msgstr ""

#. §0: `h : P ∧ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `And.symm h`
#. §4: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L03_Symmetry
msgid "Given a hypothesis §0 for some propositions §1 and §2, §3 is a proof of §4."
msgstr ""

#. §0: `y = y`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Note that the goal is now to prove §0. What tactic applies?"
msgstr ""

#. §0: `Empty.elim : Empty → A`
#. §1: `exact Empty.elim`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Lean has a built-in name §0 for the function you have just defined. Thus §1 will also solve this level. This function has been added to the library."
msgstr ""

#. §0: `A × B → A`
#. §1: `A × B → B`
#. §2: `p : A × B`
#. §3: `A`
#. §4: `B`
#. §5: `p : A × B`
#. §6: `p.1 : A`
#. §7: `p.2 : B`
#. §8: `p.fst : A`
#. §9: `p.snd : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "The elimination rules for product types can be understood as defining *projection functions* of type §0 and §1 which take an element §2 and return the corresponding components from §3 and §4 respectively.\n"
"\n"
"In Lean, the elements defined by projecting from §5 are denoted §6 and §7 or §8 and §9.\n"
"\n"
"Your task in this level is to define the second projection function."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "Numerals"
msgstr ""

#. §0: `A ⊕ B → C`
#. §1: `(A → C) × (B → C)`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "We will see later that functions of type §0 are uniquely determined by their component functions §1."
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `⟨a, b⟩ : A × B`
#. §3: `a : A`
#. §4: `b : B`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "If §0 and §1 then the projections of §2 are definitionally equal to §3 and §4, respectively."
msgstr ""

#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Introducing Existence"
msgstr ""

#. §0: `Q`
#. §1: `P`
#. §2: `¬ P`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "It is possible to prove any proposition §0 from the hypothesis that both §1 and §2 are true."
msgstr ""

#. §0: `P`
#. §1: `Classical.byContradiction : ¬ ¬ P → P`
#. §2: `P`
#. §3: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "For any proposition §0, §1 proves that if §2 is not false, then §3 is true."
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Have a look at the library of definitions for a function whose domain is the empty type."
msgstr ""

#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Logical Equivalence"
msgstr ""

#. §0: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
#: Game.Levels.TypeWorld.L07_BossLevel
msgid "The elements of the type §0 of types are types at the lowest universe level."
msgstr ""

#. §0: `m n`
#. §1: `m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "For all natural numbers §0, §1."
msgstr ""

#. §0: `Unit`
#. §1: `⟨⟩`
#. §2: `\\<`
#. §3: `\\>`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type §0 has a single canonical element §1, which may be typed using §2 and §3."
msgstr ""

#. §0: `«{p}»`
#. §1: `«{np}»`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "How can you use §0 and §1 to get a contradiction?"
msgstr ""

#: Game.Levels.DependentWorld.L04_Pairs
msgid "In the next level, we will consider general functions mapping out of a dependent pair type."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A × B`
#. §3: `A`
#. §4: `A × Empty`
#. §5: `A × Empty`
#. §6: `A × Empty`
#. §7: `Empty → A × Empty`
#. §8: `A × Empty → Empty`
#. §9: `A × Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Recall that for any types §0 and §1, there is a *product type* denoted §2.\n"
"\n"
"In particular, for any type §3, we may form the product §4 with the empty type.\n"
"\n"
"Elements of product types are pairs of elements, one from the first type and one from the second type.\n"
"\n"
"But the empty type does not have any elements! So this means the product §5 cannot have any elements either.\n"
"\n"
"More precisely, the type §6 is *equivalent* to the empty type in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions §7 and §8, which as discussed in a previous level, indicates that §9 cannot have any elements either.\n"
"\n"
"Your task in this level is to define these functions."
msgstr ""

#. §0: `(P → Q) → R`
#. §1: `P → (Q → R)`
#. §2: `P → Q → R`
#. §3: `P → (Q → R)`
#. §4: `P → (Q → R)`
#. §5: `P ∧ Q → R`
#. §6: `(P ∧ Q) → R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Recall that implication is *NOT* associative: the propositions §0 and §1 are not logically equivalent.\n"
"\n"
"The shorthand §2 is an abbreviation for §3.\n"
"\n"
"One reason that mathematical statements of the form §4 are more prevalent is that this is implied by §5, which is implicitly parenthesized as §6.\n"
"\n"
"Your task in this level is to prove this implication."
msgstr ""

#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "In the next level, we will prove that the empty type is also a proposition."
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `f a : B`
#. §3: `f`
#. §4: `a`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Given a function §0 and an element §1, there is an element §2 obtained by evaluating the function §3 at §4."
msgstr ""

#. §0: `false = true`
#. §1: `¬ (false = true) := Bool.noConfusion`
#. §2: `¬ (true = false) := Bool.noConfusion`
#. §3: `false = true`
#. §4: `exfalso`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This case is considerably more difficult than the previous one because your goal is to prove that §0. But you may recall from Boolean world that we can prove §1 and §2. This suggests that the only way we will be able to prove §3 is by finding a contradition among our hypothesis. To set up this proof strategy, use the tactic §4."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Recursion"
msgstr ""

#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "Universal property"
msgstr ""

#. §0: `Type`
#. §1: `Type u`
#. §2: `u`
#. §3: `Type`
#. §4: `Type 0`
#. §5: `Type`
#. §6: `exact Type`
#. §7: `Type`
#. §8: `Type`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "Lean also has a built in type of types denoted §0, which can be found in your library of definitions.\n"
"\n"
"More precisely &mdash; to avoid a contradiction known as *Russell's paradox* &mdash; Lean has a hierarchy of built in types of types denoted §1 parametrized by *universe levels* §2.\n"
"\n"
"Here §3 is a synonym for §4, which is the type of types at the smallest universe level.\n"
"\n"
"The goal in this level is to define an element of the type §5 of types.\n"
"\n"
"Note §6 will not work, because the type §7 belongs to the type of types in a larger universe. Try this and see what happens.\n"
"\n"
"However, we have introduced a type that is small enough to define an element of §8. Use this to solve this level."
msgstr ""

#. §0: `B × D → M`
#. §1: `E → Y × N`
#. §2: `A → M → X`
#. §3: `C → N → Z`
#. §4: `A × B × C × D × E`
#. §5: `X × Y × Z`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "Given functions of types §0, §1, §2, and §3, there is a function from the product type §4 to the product type §5."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `x : A`
#. §3: `y z : B`
#. §4: `B`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "Under the hypothesis that we have types §0 and §1 and elements §2 and §3, we may define an element of type §4."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Normal Forms"
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "Now we are ready for the Boss Level."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Prod.snd : A × B → B`
#. §3: `p : A × B`
#. §4: `p.2 : B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "For any types §0 and §1, §2 is the function that sends §3 to its second coordinate §4."
msgstr ""

#. §0: `Empty`
#. §1: `x y : Empty`
#. §2: `x = y`
#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Recall from Empty World, that Lean has a built in empty type §0 which has no elements.\n"
"\n"
"The empty type is also a proposition: if §1, then §2. Can you prove this?"
msgstr ""

#. §0: `a : A`
#. §1: `f : A → B`
#. §2: `f a : B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "Define the *evaluation* function that takes §0 and §1 to §2."
msgstr ""

#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "Negating Universality"
msgstr ""

#. §0: `assumption`
#. §1: `P`
#. §2: `P`
#: Game.Levels.TypeWorld.L02_Proofs
msgid "Type §0 to tell Lean to use the assumption that §1 is true to conclude that §2 is true."
msgstr ""

#. §0: `P`
#. §1: `R → S ∧ T`
#. §2: `U → P → R`
#. §3: `(U → Y) → Z`
#. §4: `W ∧ T ∧ V → X ∧ Y`
#. §5: `S → V ∧ W`
#. §6: `Z`
#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "If §0, §1, §2, §3, §4, and §5 are true, then §6 is true."
msgstr ""

#. §0: `f : A → B`
#. §1: `f`
#. §2: `g : B → A`
#. §3: `f`
#. §4: `f`
#. §5: `∃ g : B → A, (∀ a : A, g (f a) = a) ∧ (∀ b : B, f (g b) = b)`
#. §6: `f`
#. §7: `g`
#. §8: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L09_Invertibility
msgid "Consider a function §0.\n"
"\n"
"We say that §1 is *invertible* if there exists a function §2 that &ldquo;un-does&rdquo; the action of §3 on both pre- and post-composition.\n"
"\n"
"More formally, §4 is invertible if\n"
"\n"
"§5.\n"
"\n"
"When §6 is invertible, the function §7 is called its *inverse*.\n"
"\n"
"As a first example, prove that the function §8 is invertible."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#. §3: `¬ ¬ ¬ P → ¬ P`
#. §4: `P`
#. §5: `¬ P`
#. §6: `¬ ¬ ¬ P`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "This level contains another tautology whose proof you have seen before.\n"
"\n"
"We will show that for any proposition §0, if §1 is not not false, then §2 is false.\n"
"\n"
"That is, we will prove §3.\n"
"\n"
"In fact, for any proposition §4, its negation §5 and its triple negation §6 are logically equivalent.\n"
"\n"
"So we will prove this too."
msgstr ""

#. §0: `have lemP : P ∨ ¬ P := em P`
#. §1: `have lemP := em P`
#. §2: `P`
#. §3: `Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Type §0 or §1 to appeal to the law of excluded middle for §2. Alternatively, you can appeal to the law of excluded middle for §3 or for any other proposition."
msgstr ""

#. §0: `P true → P false`
#. §1: `let tr : P true → P false := by intro x ; rw [p] ; exact x
#. `
#. §2: `let tr : P true → P false := by`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Define a function §0 by §1. In editor mode, start with §2 then continue with each of the three tactics on three subsequent lines. This way you can see how the goal evolves with each step in the construction."
msgstr ""

#. §0: `f`
#. §1: `f`
#. §2: `f`
#. §3: `f`
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "In the proof that §0 is injective, you used only one half of the invertibility condition. Can you use this observation to state a theorem that proves that §1 is injective under a weaker hypothesis? Similarly, in the proof that §2 is surjective, you used only the other half of the invertibility condition. Can you use this observation to state a theorem that proves that §3 is surjective under a weaker hypothesis?"
msgstr ""

#. §0: `f : X → A × B`
#. §1: `fun x ↦ (f x).1 : X → A`
#. §2: `fun x ↦ (f x).2 : X → B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that functions §0 into product types can be decomposed into component functions §1 and §2.\n"
"\n"
"We'll now consider the reversed process, defining a function into a product type from a pair of component functions."
msgstr ""

#. §0: `apply`
#. §1: `Q`
#. §2: `h : P → Q`
#. §3: `apply h`
#. §4: `P`
#. §5: `T`
#. §6: `e : R → S → T`
#. §7: `apply e`
#. §8: `R`
#. §9: `S`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "The §0 tactic can be used when the goal matches the conclusion of an implication or the output type of a function. For example if the goal is §1 and there is a hypothesis §2, then §3 updates the goal to §4. If the goal is §5 and there is a hypothesis §6, then §7 produces two subgoals, one each for §8 and §9."
msgstr ""

#. §0: `f : A → B`
#. §1: `x y : A`
#. §2: `p : x = y`
#. §3: `congrArg f p : f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "For a function §0 between types, elements §1, and a proof §2, then §3. This theorem has been added to the library."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A × B) × C`
#. §4: `A × (B × C)`
#: Game.Levels.ProductWorld.L05_Associativity
msgid "Product types are associative: for types §0, §1, and §2, there are canonical functions in each direction between the types §3 and §4."
msgstr ""

#: Game.Levels.DependentWorld.L03_Application
msgid "Application"
msgstr ""

#. §0: `«{P}»`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "Now the goal is to prove §0 using *any* of our given hypotheses. Which tactic can be used to supply this proof?"
msgstr ""

#. §0: `P : A → Prop`
#. §1: `∀ x : A, P x`
#. §2: `P a`
#. §3: `a : A`
#. §4: `h : ∀ x : A, P x`
#. §5: `a : A`
#. §6: `h a`
#. §7: `P a`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "For a family of propositions §0, §1 is the proposition that asserts that §2 is true for\n"
"every element §3. Elements §4 can be thought of as *dependent functions* that carry an arbitrary element §5 to a proof §6 of the proposition §7."
msgstr ""

#. §0: `(x : A) × B x`
#. §1: `x : A`
#. §2: `y : B x`
#: Game.Levels.DependentWorld.L05_Currying
msgid "There is an equivalence between the type of dependent functions out of the dependent pair type §0 and the type of dependent functions of two variables §1 and §2 defined by currying and uncurrying."
msgstr ""

#. §0: `P → ¬ ¬ P`
#. §1: `(P → Q) → (¬ Q → ¬ P)`
#. §2: `¬ P ∨ ¬ Q → ¬ (P ∧ Q)`
#. §3: `(P ∧ ¬ Q) → ¬ (P → Q)`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∨ Q`
#. §7: `P`
#. §8: `Q`
#. §9: `A`
#. §10: `B`
#. §11: `A → (A → Empty) → Empty`
#. §12: `(A → B) → (B → Empty) → (A → Empty)`
#. §13: `(A → Empty) ⊕ (B → Empty) → (A × B → Empty)`
#. §14: `A × (B → Empty) → (A → B) → Empty`
#. §15: `P`
#. §16: `P ∨ ¬ P`
#. §17: `P ∨ ¬ P`
#. §18: `P`
#. §19: `P`
#. §20: `P`
#. §21: `¬ ¬ P → P`
#. §22: `P`
#. §23: `¬ ¬ P → P`
#. §24: `P`
#. §25: `¬ P`
#. §26: `¬ P`
#. §27: `¬ ¬ P`
#. §28: `¬ ¬ P → P`
#. §29: `¬ ¬ P`
#. §30: `P`
#: Game.Levels.ClassicalWorld
msgid "In Negation World, we proved various tautologies involving negation such as\n"
"\n"
"* §0\n"
"* §1\n"
"* §2\n"
"* §3\n"
"\n"
"for arbitrary propositions §4 and §5.\n"
"\n"
"But we were not able to prove the converses of any of these implications. Why not?\n"
"\n"
"The reason is that all of the proofs we have given thusfar involve explicit constructive arguments. For example, whenever we proved that a disjunction §6 held under certain hypotheses, our proof gave the information of *which* of the propositions §7 and §8 is true.\n"
"\n"
"One way to identify a constructive proof of implication is to think about whether there is a corresponding function between types. For arbitrary types §9 and §10 it is possible to define functions of type\n"
"\n"
"* §11\n"
"* §12\n"
"* §13\n"
"* §14\n"
"\n"
"using analogous constructions to the proofs of the constructive implications.\n"
"\n"
"In this world, we study *classical mathematics*, which assumes two additional axioms, each of which permits new proof techniques.\n"
"\n"
"The first axiom, called the *law of excluded middle*, asserts that for any proposition §15, §16 is true.\n"
"\n"
"This permits the strategy of proof by cases. Under the assumption that §17 is true, you can split the argument into two cases, one assuming §18 is true and the other assuming §19 is false.\n"
"\n"
"The other axiom, called *double negation elimination*, asserts that for any proposition §20, §21 is true.\n"
"\n"
"This permits a proof strategy called *proof by contradiction*. If the goal is to prove §22 we can use the assumption §23 to reason as follows:\n"
"\n"
"* First assume that §24 is false, so §25 is true.\n"
"* Then use the assumption §26 to derive a contradiction, thus constructing a proof of §27.\n"
"* Finally, apply the implication §28 to convert the proof of §29 into a proof of §30.\n"
"\n"
"In fact, as statements concerning arbitrary propositions, the law of exluded middle and double negation elimination are equivalent &mdash; even constructively &mdash; as we will show in the Boss Level of this world."
msgstr ""

#: Game.Levels.EmptyWorld.L01_FromEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L02_ToEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "The goal is a function type. What tactic can be used to define an element?"
msgstr ""

#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "Disjunction Symmetry"
msgstr ""

#. §0: `f : A → B`
#. §1: `x y : A`
#. §2: `x = y`
#. §3: `f x = f y`
#. §4: `f : A → B`
#. §5: `a : A`
#. §6: `b : B`
#. §7: `f a`
#. §8: `b`
#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "Recall from Equality World that a function §0 must be *well-defined*.\n"
"\n"
"That is if §1 and §2, then §3.\n"
"\n"
"In this level, we will state and prove a second defining property of functions.\n"
"\n"
"A function §4 must necessarily be &ldquo;total&rdquo;, rather than &ldquo;partially-defined&rdquo;.\n"
"\n"
"To say a function is *total* means that for each §5 there is some §6 so that §7 equals §8.\n"
"\n"
"Your task this level is to prove this."
msgstr ""

#. §0: `(P ∧ R) ∨ ((P ∧ S) ∨ ((Q ∧ R) ∨ (Q ∧ S)))`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "The implicit parentheses in the goal are to the right §0."
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `f a`
#. §3: `exact f a`
#. §4: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The syntax for the application of the function §0 to an element §1 is just §2. So to solve this level, type §3 to obtain an element of type §4."
msgstr ""

#. §0: `B : A → Type`
#. §1: `(x : A) × B x`
#. §2: `(x : A) × B x → C`
#. §3: `C`
#. §4: `B`
#. §5: `A × B`
#. §6: `(A × B → C) ≃ (A → B → C)`
#. §7: `B : A → Type`
#. §8: `((x : A) × B x → C) ≃ ((x : A) → B x → C)`
#. §9: `C`
#. §10: `(x : A) × B x`
#: Game.Levels.DependentWorld.L05_Currying
msgid "Consider a family of types §0 and the associated dependent pair type §1.\n"
"\n"
"In this level, we will characterize the type of functions §2 valued in another type §3.\n"
"\n"
"In the case of a constant type family valued at a type §4, the dependent pair type reduces to the ordinary product type §5. In this setting, we have an equivalence of types\n"
"\n"
"§6\n"
"\n"
"defined by currying and uncurrying.\n"
"\n"
"Similarly, when §7 is a non-constant type family, there is an equivalence of types\n"
"\n"
"§8\n"
"\n"
"defined by currying and uncurrying.\n"
"\n"
"Your task in this level is in fact to construct a further generalization of this equivalence where the type §9 is replaced by a type family over the dependent pair type §10.\n"
"\n"
"While the statement of the equivalence in this case is harder to read, the construction of the equivalence in all three settings is identical."
msgstr ""

#: Game.Levels.BooleanWorld.L05_Disjunction
msgid "Disjunction"
msgstr ""

#. §0: `Retry`
#. §1: `exact x`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "After solving this level, use the §0 button to solve it again. What happens if you try §1?"
msgstr ""

#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "Type of Propositions"
msgstr ""

#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Which function might be useful to apply here?"
msgstr ""

#. §0: `«{pnq}»`
#: Game.Levels.NegationWorld.L07_NegatingImplication
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What can we prove with the hypothesis §0?"
msgstr ""

#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Coproduct Symmetry"
msgstr ""

#. §0: `P : Bool → Prop`
#. §1: `tr : P true → P false`
#. §2: `tr : True → False`
#. §3: `tr`
#. §4: `True`
#. §5: `False`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "By the definition of the family of propositions §0, the function §1 is a function §2. In particular, if we apply §3 to an element of §4, we get an element of §5, which is what we want."
msgstr ""

#. §0: `«{andn}»`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "What proofs can you extract from the hypothesis §0?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A → B`
#. §3: `f : A → B`
#. §4: `A`
#. §5: `B`
#. §6: `A`
#. §7: `B`
#. §8: `A × B`
#. §9: `p : A × B`
#. §10: `A`
#. §11: `B`
#. §12: `A × B`
#. §13: `A × B`
#: Game.Levels.ProductWorld
msgid "In Function World, we learned that for any types §0 and §1 there is a new type §2 whose elements §3 are *functions* from §4 to §5.\n"
"\n"
"In this world, we'll meet another binary type forming operation.\n"
"\n"
"Given two types §6 and §7, there is a type §8 called the *product type* whose elements §9 should be thought of as encoding ordered pairs of elements, one from §10 and one from §11.\n"
"\n"
"To understand how products work in type theory we must learn:\n"
"\n"
"* How to construct elements of type §12.\n"
"* How to use elements of type §13 to construct elements of other types.\n"
"\n"
"Like all type forming operations, the product type is characterized by these introduction and elimination rules."
msgstr ""

#. §0: `Type`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The unit type can be found in the library of definitions in the folder §0."
msgstr ""

#: Game.Levels.TypeWorld.L02_Proofs
msgid "Proofs"
msgstr ""

#. §0: `pred : ℕ → ℕ`
#. §1: `0`
#. §2: `0`
#. §3: `succ n`
#. §4: `n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "There is a function §0 that sends §1 to §2 and §3 to §4."
msgstr ""

#. §0: `a : A`
#. §1: `a = a`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "For all §0, §1 holds."
msgstr ""

#. §0: `swap`
#. §1: `f : A → B → C`
#. §2: `swap f : B → A → C`
#. §3: `b : B`
#. §4: `a : A`
#. §5: `f a b : C`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "The §0 function exchanges the inputs of a function of two variables. For a function with two variables §1, §2 is the function that sends §3 and §4 to §5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "In the next level, we will practice using function extensionality to demonstrate an equality between functions."
msgstr ""

#. §0: `apply byContradiction`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Now that you are stuck, it is a good time to try classical reasoning. Try §0 and see how this transforms the goal."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `¬ (∀ x : A, P x)`
#. §2: `∃ x : A, ¬ (P x)`
#: Game.Levels.QuantifierWorld.L09_BossLevel
msgid "Given a family of propositions §0, using classical logic, §1 implies §2."
msgstr ""

#. §0: `Bool`
#. §1: `C : Bool → Type`
#. §2: `C false`
#. §3: `C true`
#. §4: `b : Bool`
#. §5: `match`
#. §6: `cases`
#. §7: `false`
#: Game.Levels.DependentWorld.L01_Types
msgid "Your challenge in this level is to define an example of a dependent type indexed by the type of booleans.\n"
"\n"
"There are many ways to do this. In particular, it is perfectly valid to define a constant type family.\n"
"\n"
"But the elimination rule for the type §0 can be used to define a non-constant type family. To define a family of types §1, it suffices to specify types §2 and §3.\n"
"\n"
"After introducing a generic element §4 use the tactics §5 or §6 to consider the explicit booleans §7 and `true."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "A bijective function is invertible."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "For any proposition §0, §1 implies §2 is true."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "If this is not the term you want, how can you use it to define the correct term?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L15_BossLevel
msgid "Using our newly understood notion of bijective function, or invertible function, or isomorphism, we can now study what it means for a pair of types to be *equivalent*. Move on to Equivalence World next."
msgstr ""

#: Game.Levels.ClassicalWorld.L02_Contrapositive
msgid "Contrapositive"
msgstr ""

#. §0: `¬ (P ∨ Q)`
#. §1: `P ∨ Q`
#. §2: `P ∨ Q`
#. §3: `P`
#. §4: `P ∨ Q`
#. §5: `Q`
#. §6: `P ∨ Q`
#. §7: `P ∨ Q`
#. §8: `P`
#. §9: `Q`
#. §10: `¬ (P ∨ Q)`
#. §11: `¬ P ∧ ¬ Q`
#. §12: `↔`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"Recall, if §3 is true, then we can prove §4. Similarly, if §5 is true, we can prove §6.\n"
"\n"
"So if §7 is false, then both §8 and §9 must be false.\n"
"\n"
"In this level, we will show that §10 is logically equivalent to §11.\n"
"\n"
"If you have forgotten the meaning of logical equivalence, denoted §12, you can look it up in the library."
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ x y : A, x = y → f x = f y`
#. §2: `f : A → B`
#. §3: `x y : A`
#. §4: `f x = f y`
#. §5: `x = y`
#. §6: `f`
#. §7: `B`
#. §8: `A`
#. §9: `∀ x y : A, f x = f y → x = y`
#. §10: `f`
#. §11: `not : Bool → Bool`
#. §12: `b : Bool`
#. §13: `! b`
#. §14: `not b`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Recall that every function is *well-defined*. For any function §0, we have proven that §1.\n"
"\n"
"A function §2 is *injective* if for every §3, §4 implies §5.\n"
"\n"
"This condition says that any output element of §6 has a unique corresponding input. Note it is not necessary that any element of §7 is an output of an injective function. Instead, injectivity asserts that if two elements of §8 have the same output, then those elements must be equal.\n"
"\n"
"Unlike well-definedness, the statement §9 is true for some functions §10 but false for others.\n"
"\n"
"In this level, we will show that the function §11 is injective.\n"
"\n"
"Recall that when §12, Lean writes §13 for §14."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `a : A`
#. §4: `A ⊕ B`
#. §5: `Sum.inl : A → A ⊕ B`
#. §6: `A ⊕ B`
#. §7: `apply Sum.inl`
#. §8: `A`
#. §9: `left`
#. §10: `A ⊕ B`
#. §11: `left`
#. §12: `A`
#. §13: `A ⊕ B`
#. §14: `Sum.inl : A → A ⊕ B`
#. §15: `left`
#. §16: `A`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
msgid "For types §0 and §1, the coproduct type §2 has two kinds of elements. The first kind can be thought of as copies of elements §3 included into the coproduct §4 *on the left*.\n"
"\n"
"Lean has a built in function called §5, which can now be found in your library.\n"
"\n"
"If the goal is to produce an element of §6, typing §7 will convert this to a goal of producing an element of §8.\n"
"\n"
"The tactic §9 has the same effect. When the goal is a coproduct type §10, using the tactic §11 tells Lean that you plan to provide an element of type §12, which should then be converted to an element of type §13 by applying the function §14. Thus, typing §15 will update the goal to type §16."
msgstr ""

#. §0: `«{p}» : A ⊕ B`
#. §1: `rfl`
#. §2: `«{p}»`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "The functions you have just defined are not definitionally inverses on all elements §0. This is why §1 fails. Try splitting §2 into cases first."
msgstr ""

#. §0: `Prod.snd : A × B → B`
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Lean uses the name §0 for the function you have just defined. This function has been added to the library of definitions.\n"
"\n"
"In the next level, we'll use the projection functions to prove symmetry of product types."
msgstr ""

#. §0: `¬ P ∨ ¬ Q`
#. §1: `¬ (P ∧ Q)`
#. §2: `¬ (P ∧ Q)`
#. §3: `¬ P ∨ ¬ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∨ ¬ P`
#. §7: `have := em P`
#. §8: `P ∨ ¬ P`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "We have seen that §0 implies §1.\n"
"\n"
"But we were not able to prove constructively that §2 implies §3, since we cannot tell whether §4 or §5 is the false proposition.\n"
"\n"
"However, we can prove this using classical logic.\n"
"\n"
"Recall that in classical logic, we may assume the *law of excluded middle*, i.e., that §6 is true for any proposition.\n"
"\n"
"In particular, in the middle of your proof, you can type §7 to introduce §8 as a hypothesis.\n"
"\n"
"Can you use this to prove the desired implication?"
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What is the logical form of the goal?"
msgstr ""

#. §0: `rw`
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "We will now explore other applications of the tactic §0."
msgstr ""

#. §0: `x : Bool`
#. §1: `not x = «{b}»`
#. §2: `«{b}»`
#. §3: `cases «{b}»`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Now you must give an explicit element §0, so that §1. To do this, you need to know which boolean §2 is! Use §3 for this."
msgstr ""

#. §0: `f : A × B → C`
#. §1: `Function.curry f : A → B → C`
#. §2: `f : X → A × B`
#. §3: `X`
#. §4: `A × B`
#. §5: `X → A`
#. §6: `X → B`
#. §7: `x : X`
#. §8: `(f x).1 : A`
#. §9: `(f x).2 : B`
#. §10: `f x : A × B`
#. §11: `f : X → A × B`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "We've seen that a function §0 out of a product can be regarded as a function of two variables §1.\n"
"\n"
"How should we think about a function into a product?\n"
"\n"
"Consider a function §2 from a type §3 into a product type §4.\n"
"\n"
"From this data, one can define a pair of functions with types §5 and §6 that map an element §7 to the values §8 and §9 defined by projecting the pair §10 to its components.\n"
"\n"
"These functions are called the *component functions* associated to §11.\n"
"\n"
"Your task in this level is to define a function that extracts the component functions associated to a function into a product type."
msgstr ""

#. §0: `P ∧ (Q ∨ R)`
#. §1: `(P ∧ Q) ∨ (P ∧ R)`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Conjunction distributes over disjunction: §0 and §1 are logically equivalent."
msgstr ""

#. §0: `ℕ`
#. §1: `Bool`
#. §2: `17 : ℕ`
#. §3: `true : Bool`
#: Game
msgid "Mathematicians from all over &mdash; most of whom have never met one another &mdash; nevertheless agree to an incredible extent about the nature of the mathematical universe. How did this degree of consensus come about?\n"
"\n"
"Firstly mathematicians have developed a precise formal language which allows them to define new abstract concepts and state their properties in an unambiguous way. A mathematical *proposition* is a well-formed mathematical statement that is either true or false, for instance:\n"
"\n"
"* &ldquo;There are infinitely many prime numbers.&rdquo;\n"
"* &ldquo;Every prime number is odd.&rdquo;\n"
"* &ldquo;There are infinitely many prime numbers that are two less than another prime.&rdquo;\n"
"\n"
"Mathematicians distinguish between the true propositions, the false ones, and the ones whose truth value is not yet known through *proofs* made precise in the formal language of mathematical logic.\n"
"\n"
"While the idea of a mathematical proof is over 2000 years old, the practice of proof writing continues to evolve. Today mathematicians may elect to use a tool called a computer proof assistant that can provide real-time feedback to a theorem prover about the status of a logical argument that is currently under development.\n"
"\n"
"The aim of this game will be to introduce proof writing in a computer proof assistant while developing skils that can be used to develop proofs in other contexts: on paper, in conversation with a friend, or in your head.\n"
"\n"
"There is one caveat to this introduction to proof writing, which we now address explicitly. The formal vocabulary we will introduce to discuss mathematical proofs is somewhat different from the one that most mathematicians learn. The mathematics we will be developing is essentially unchanged but the formal language introduced here will make it easier to be fully precise about every step in a proof, as is required to convince a computer that a logical argument in sound.\n"
"\n"
"In particular, we will explore an analogy between mathematical *propositions* and another form of primitive mathematical structure called *types*. Examples of types include:\n"
"\n"
"* The type §0 of natural numbers.\n"
"* The type §1 of booleans.\n"
"\n"
"Each type comes with its *elements* such as §2 or §3 governed by rules which explain the requirements for constructing an element and how previously-constructed elements can be used. We will see that these rules closely parallel the logical rules which dictate the requirements for proving a proposition and explain how a previously-proven proposition can be used to prove other theorems.\n"
"\n"
"This formal vocabulary for mathematics is called *dependent type theory*, with the adjective &ldquo;dependent&rdquo; referring to the fact that all of the rules just mentioned apply in any *context* of previously-constructed elements of types and previously-proven propositions.\n"
"\n"
"In Type World, we will introduce types and their elements and propositions and their proofs. We will explore these notions interactively with the computer proof assistant Lean.\n"
"\n"
"Later worlds will reveal that more complicated types can be built from simpler types, like more complicated mathematical statements can be built from simpler propositions.\n"
"\n"
"Let's begin!"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Sum.swap : A ⊕ B → B ⊕ A`
#. §3: `Sum.inl a`
#. §4: `Sum.inr a`
#. §5: `Sum.inr b`
#. §6: `Sum.inl b`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For types §0 and §1, the function §2 is defined to send elements of the form §3 to §4 and elements of the form §5 to §6."
msgstr ""

#. §0: `left`
#. §1: `right`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Use the tactic §0 to indicate that you'd like to prove the left-hand statement or §1 to indicate that you'd like to prove the right-hand statement."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `f : A → B`
#. §3: `a : A`
#. §4: `B`
#. §5: `apply`
#. §6: `f : A → B`
#. §7: `B`
#. §8: `apply f`
#. §9: `A`
#. §10: `f`
#. §11: `apply`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "The context and goal for this level is identical to the previous level. We are given types §0 and §1, a function §2 and an element §3. The goal is to define an element of type §4.\n"
"\n"
"Lean has another tactic called §5, which can be used in the presence of a function to transform the goal. If §6 is part of the context and the goal is to define an element of type §7 then §8 will update the goal to ask instead for an element of type §9.\n"
"\n"
"This proof strategy asks Lean to solve the initial goal by applying the function §10 to the element you provide next.\n"
"\n"
"Try using the §11 tactic to solve this level."
msgstr ""

#. §0: `let`
#. §1: `p : A × B × C × D × E`
#. §2: `let ⟨a, b, c, d, e⟩ := p`
#. §3: `a : A`
#. §4: `b : B`
#. §5: `c : C`
#. §6: `d : D`
#. §7: `e : E`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The §0 tactic can also be used to decompose an element of a product type into its components. For example, using an element §1, typing §2 will add elements §3, §4, §5, §6, and §7 to your context.\n"
"\n"
"Move on to Conjunction World to learn about the logical operation that is analogous to product types."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∧ Q`
#. §3: `P ∧ ¬ Q`
#. §4: `¬ P ∧ Q`
#. §5: `¬ P and ¬ Q`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "In classical logic, for any propositions §0 and §1, §2 is true or §3 is true or §4 is true or §5 is true."
msgstr ""

#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "In the next level, we will introduce another tactic that can be used to solve this goal."
msgstr ""

#. §0: `Prod.swap`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Lean calls the function you have just defined §0. It is now part of your library of definitions. Are function types symmetric? Why or why not?"
msgstr ""

#. §0: `P`
#. §1: `P ∨ ¬ P`
#. §2: `¬ ¬ P → P`
#: Game.Levels.NegationWorld.L11_BossLevel
msgid "The law of excluded middle implies double negation elimination: for any proposition §0, §1 implies §2."
msgstr ""

#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "Reflexivity"
msgstr ""

#: Game.Levels.FunctionWorld
msgid "Function World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Can we apply our hypothesis now?"
msgstr ""

#. §0: `intro`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L07_SwappingInputs
#: Game.Levels.FunctionWorld.L09_Evaluation
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "When in doubt, start defining a function by using the tactic §0 followed by your preferred variable name."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Next move on to Disjunction World to study the logical operation that is analogous to coproduct types."
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
msgid "Compound Implication"
msgstr ""

#. §0: `ext x`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Type §0 to apply function extensionality and see how the goal state transforms."
msgstr ""

#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "Introducing Or"
msgstr ""

#. §0: `«{nnnp}»`
#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "What can you do with hypothesis §0?"
msgstr ""

#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Identity Function"
msgstr ""

#. §0: `intro`
#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "As the goal is to prove an implication, the tactic §0 can be used to introduce a hypothesis and update the goal. Before using this tactic, try to figure out which hypothesis will be assumed and what the goal will be, using the discussion about the implicit parenthesization above."
msgstr ""

#. §0: `∨`
#. §1: `P`
#. §2: `Q`
#. §3: `P ∨ Q`
#. §4: `P`
#. §5: `Q`
#. §6: `P ∨ Q`
#. §7: `P ∨ Q`
#. §8: `P ∨ Q`
#. §9: `P`
#. §10: `Q`
#. §11: `P`
#. §12: `Q`
#. §13: `P ∨ Q`
#. §14: `P ∨ Q`
#. §15: `P`
#. §16: `Q`
#. §17: `h : P ∨ Q`
#. §18: `h : P ∨ Q`
#: Game.Levels.DisjunctionWorld
msgid "The logical connective of *disjunction*, denoted by §0, is the mathematical version of *or*.\n"
"\n"
"For arbitrary propositions §1 and §2, §3 is a new proposition asserting that at least one of §4 *or* §5 *are true*.\n"
"\n"
"To understand how conjunctions work in logic we must learn:\n"
"\n"
"* How to prove theorems of the form §6.\n"
"* How to use a hypothesis of the form §7 to prove something else.\n"
"\n"
"There are two strategies to prove §8. It suffices to supply a proof of §9 and it also suffices to supply a proof of §10.\n"
"\n"
"Note that the mathematical &ldquo;or&rdquo; is *inclusive*, meaning that if §11 and §12 are both true, then §13 is true.\n"
"\n"
"Together these strategies define the two introduction rules for disjunctions. Note that a proof that employs either of these strategies carries extra information. In addition to concluding that §14 is true, a proof using the first strategy will prove along the way that §15 is true (perhaps subject to certain hypotheses) while a proof using the second strategy will prove along the way that §16 is true (perhaps subject to other hypotheses).\n"
"\n"
"Similarly, the construction of an element of a coproduct type via either of the introduction rules will carry the information of whether the element comes from the left-hand type or the right-hand type.\n"
"\n"
"The elimination rule for disjunctions explains how to use a hypothesis §17 to prove something else.\n"
"\n"
"Using a hypothesis §18 leads to a proof strategy of arguing &ldquo;by cases&rdquo; as we will soon discover.\n"
"\n"
"Like the analogy between function types and implication, and product types and conjunction, there is a close analogy between coproduct types and the logical operation of disjunction.\n"
"\n"
"In particular, we will use similar notations and the same tactics introduced in Coproduct World."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Does this goal seem familiar? If not, it's okay to just follow your nose and let the logical structure guide you."
msgstr ""

#. §0: `Retry`
#: Game.Levels.ImplicationWorld.L01_ByAssumption
msgid "You can click on §0 to attempt a different proof."
msgstr ""

#. §0: `«{hk}»`
#. §1: `0 + «{k}»`
#. §2: `«{k}»`
#. §3: `0 + succ «{k}»`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "It would be nice if we could use the hypothesis §0 to replace the §1 in the goal with the element §2, but the parentheses in the left-hand side of the goal equation are not a match for this. Lean thinks that the left hand side is of the form §3. Do we have any theorems that can be used to rewrite this into something else?"
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ x y : A, x = y → f x = f y`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "A function §0 is *injective* if §1."
msgstr ""

#. §0: `(p || !q || r) && (q || !r) && (!p || r)`
#. §1: `p q r : Bool`
#. §2: `(!p || q) && (!q || p) && (!p || !r) && (!q || !r) && (p || q)`
#. §3: `p q r`
#. §4: `true`
#. §5: `p`
#. §6: `q`
#. §7: `r`
#. §8: `exact p`
#. §9: `exact q`
#. §10: `exact r`
#. §11: `true`
#. §12: `false`
#. §13: `rfl`
#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "An expression involving booleans is in *conjuctive normal form* if it expressed as a conjunction (possibly involving many formulas) of disjunctions (possibly involving many formulas) of either booleans or their negations.\n"
"\n"
"Using Lean's alternate notation for conjunction, disjunction, and negation, conjunctive normal form statements look like\n"
"\n"
"§0\n"
"\n"
"For the Boss Level, you are asked to find booleans §1 so that\n"
"\n"
"§2\n"
"\n"
"is satisfiable, meaning that the after substituting appropriate elements for §3, this conjunctive normal form formula is equal to §4.\n"
"\n"
"You can see this expression in the fourth goal, with §5, §6, and §7 standing in for the yet-to-be-determined boolean variables.\n"
"\n"
"Solve the first three goals by §8, §9, and §10 &mdash; replacing the boolean variables by explicit booleans §11 or §12 as appropriate. If you have found the right solution, the final goal should be solvable with §13."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → A`
#. §2: `f`
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "Suppose §0 is an invertible function, with an inverse function §1.\n"
"\n"
"Then it follows that §2 is bijective, both injective and surjective.\n"
"\n"
"Your objective this level is to prove this."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `absurd`
#. §3: `P → ¬ P → Q`
#. §4: `p : P`
#. §5: `np : ¬ P`
#. §6: `absurd p np`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "For any propositions §0 and §1, §2 proves that §3. So if §4 and §5,\n"
"then §6 supplies a proof of any proposition."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "There is one remaining level in our game. Move on to Dependent World to encounter type forming operations that take as input families of types, the *dependent types* of dependent type theory."
msgstr ""

#. §0: `«{h}» : «{P}» ∨ «{Q}»`
#. §1: `cases h`
#. §2: `P`
#. §3: `Q`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "After introducing the hypothesis §0, type §1 to ask Lean to consider both cases: the first being that §2 is true and the second being that §3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "If this is your first time solving this level, delete your code and prove the same theorem another way."
msgstr ""

#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "The next level will give more practice with the existential quantifier."
msgstr ""

#. §0: `n : ℕ`
#. §1: `n`
#. §2: `induction n with d hd`
#. §3: `n`
#. §4: `d`
#. §5: `hd`
#. §6: ```
#. 0 + n = n
#. ```
#. §7: `induction n with d hd`
#. §8: `0 + 0 = 0`
#. §9: `hd : 0 + d = d`
#. §10: `0 + succ d = succ d`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "## Summary\n"
"\n"
"If §0 is an object, and the goal mentions §1, then §2\n"
"attempts to prove the goal by induction on §3, with the inductive\n"
"variable in the successor case being §4, and the inductive hypothesis being §5.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"§6\n"
"\n"
"then\n"
"\n"
"§7\n"
"\n"
"will turn it into two goals. The first is §8;\n"
"the second has an assumption §9 and goal\n"
"§10.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.NegationWorld.L10_TripleNegation
msgid "Triple Negation"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "In the next level, we will prove that surjective functions compose."
msgstr ""

#. §0: `0 : ℕ`
#. §1: `zero : ℕ `
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "An introduction rule for the type of natural numbers defines an element which may be written in Lean §0 or §1."
msgstr ""

#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "Type of Types"
msgstr ""

#. §0: `g (f «{x}») = g (f «{y}»)`
#. §1: `(g ∘ f) «{x}» = (g ∘ f) «{y}»`
#. §2: `exact «{p}»`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Your goal §0 is very similar to one of your assumptions §1. Try §2."
msgstr ""

#: Game.Levels.NaturalNumbersWorld
msgid "Natural Numbers World"
msgstr ""

#. §0: `constructor`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "Type §0 to split the goal up into the four proof obligations."
msgstr ""

#. §0: `Unit`
#. §1: `() : Unit`
#. §2: `Bool`
#. §3: `false true : Bool`
#. §4: `Unit ⊕ Unit → Bool`
#. §5: `Bool → Unit ⊕ Unit`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "For the Boss Level of Equivalence World you are asked to establish an equivalence between a priori unrelated types.\n"
"\n"
"One of these is the coproduct of the unit type §0 with itself. Recall the unit type has a canonical element §1.\n"
"\n"
"The other is the type of booleans §2 which has two canonical elements §3.\n"
"\n"
"Be careful how you define the functions §4 and §5. If you make a wrong choice, you will not be able to solve the rest of this level."
msgstr ""

#. §0: `«{A}»`
#. §1: `«{x}» : «{A}»`
#. §2: `«{x}» : «{A}»`
#. §3: `exact «{x}»`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "Now the goal is an element of type §0, which should be thought of as result of applying the function to the element §1. In the case of the identity function, we want to return §2 again which is done by typing §3."
msgstr ""

#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "In the next level, we will establish another equivalence involving function types."
msgstr ""

#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "In the next level, we will see that the equality type is itself a proposition."
msgstr ""

#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Coproduct With Empty"
msgstr ""

#. §0: `f : A → B`
#. §1: `a : A`
#. §2: `f`
#. §3: `a`
#. §4: `f a : B`
#. §5: `B`
#. §6: `f a`
#. §7: `B`
#. §8: `f`
#. §9: `a`
#. §10: `a : A`
#. §11: `f : A → B`
#. §12: `B`
#: Game.Levels.FunctionWorld.L02_UsingFunctions
msgid "The *elimination rule* for function types explains how functions can be used to define elements of other types.\n"
"\n"
"Given a function §0 and any element §1. You can apply the function §2 to §3 to obtain an element §4 of type §5.\n"
"\n"
"Like many programming languages, Lean uses juxtaposition, with a space in between, to denote function application. So §6 is the Lean notation  for the element of §7 obtained by applying the function §8 to the element §9.\n"
"\n"
"In this level, the context contains the elements §10 and §11 and the goal is to define an element of type §12."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Projected Pairs"
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
#: Game.Levels.ConjunctionWorld.L03_Symmetry
#: Game.Levels.CoproductWorld.L05_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.EqualityWorld.L04_Symmetry
msgid "Symmetry"
msgstr ""

#. §0: `Empty`
#. §1: `Empty.elim : Empty → A`
#. §2: `A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "The empty type §0 has no introduction rules. It is an inductive type, meaning that it is in some sense *freely generated* by the elements provided by its introduction rules. In this case, this means that the elimination rule provides a canonical function §1 valued in any type §2."
msgstr ""

#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Negating Conjunction"
msgstr ""

#. §0: `P : A → B → Prop`
#. §1: `∀ x : A, ∃ y : B, P x y`
#. §2: `∃ z : B, ∀ w : A, P w z`
#. §3: `h : ∃ z : B, ∀ w : A, P w z`
#. §4: `h`
#. §5: `b : B`
#. §6: `hb : ∀ w : A, P w b`
#. §7: `b`
#. §8: `z`
#. §9: `∀ w : A, P w z`
#. §10: `h`
#. §11: `⟨b, hb⟩ : ∃ z : B, ∀ w : A, P w z`
#. §12: `h = ⟨b, hb⟩`
#. §13: `h`
#. §14: `rcases h with ⟨b, hb⟩`
#. §15: `h`
#. §16: `b : B`
#. §17: `hb : ∀ w : A, P w b`
#. §18: `let ⟨b, hb⟩ := h`
#. §19: `b : B`
#. §20: `hb : ∀ w : A, P w b`
#. §21: `h`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Consider a family of propositions that depends on elements drawn from two separate types:\n"
"\n"
"§0\n"
"\n"
"In this level, we will compare the two statements\n"
"\n"
"§1 and\n"
"§2.\n"
"\n"
"We will see that the second statement implies the first.\n"
"\n"
"The converse implication is not true in general. Can you see why?\n"
"\n"
"To solve this level, you will need to use a hypothesis involving an existential quantifier,\n"
"which in this case will have the form:\n"
"\n"
"§3\n"
"\n"
"We would like to decompose the hypothesis §4 into a pair of elements: firstly an element §5\n"
"and secondly a proof §6. Note that the element §7 gets substituted for the variable §8 in the family of propositions §9.\n"
"\n"
"We can think of the proof §10 as being given by this pair of data §11. Indeed §12.\n"
"\n"
"To extract this data from the proof §13, type §14 to replace §15 by the pair of assumptions §16 and §17.\n"
"\n"
"Alternatively, type §18 to extract the elements §19 and §20 from §21."
msgstr ""

#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Now the goal is an element of a product type. How can such elements be defined?"
msgstr ""

#. §0: `f g : A → B`
#: Game.Levels.AdvancedFunctionWorld
msgid "In this world, we will return to our study of functions.\n"
"\n"
"Using the universal and existential quantifiers, we will state important properties of functions\n"
"and prove the interrelationships between these notions.\n"
"\n"
"We will also answer the question of what it means for two functions §0 to be equal.\n"
"\n"
"These results will be used in Equivalence World to answer what it means for two types to be the same."
msgstr ""

#. §0: `exact «{a}»`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Now finish the definition of the inverse function with §0."
msgstr ""

#. §0: `constructor`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The goal asks you to prove two theorems, so start with §0."
msgstr ""

#. §0: `A`
#. §1: `a : A`
#. §2: `A`
#: Game.Levels.TypeWorld.L01_Elements
msgid "Under the hypothesis that we have a type §0 and an element §1, we may define an element of §2."
msgstr ""

#. §0: `g`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Try applying the hypothesis that §0 is injective."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `Q → P`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "If §0 is true, then for any proposition §1, §2 is always true."
msgstr ""

#. §0: `f g : A → B`
#. §1: `rfl : f = fun x ↦ f x`
#. §2: `f`
#. §3: `x ↦ f x`
#. §4: `η-rule`
#. §5: `rfl : g = fun x ↦ g x`
#. §6: `f = g`
#. §7: `fun f ↦ f x`
#. §8: `fun x ↦ g x`
#. §9: `p x : f x = g x`
#. §10: `x : A`
#. §11: `f = g`
#. §12: `f x = g x`
#. §13: `x : A`
#. §14: `ext`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Suppose that §0 are functions. What does it mean for these functions to be equal?\n"
"\n"
"There is an idea that a function is determined by its values. In fact, we have §1, meaning that the function §2 is definitionally equal to the function defined by the formula §3. This is sometimes called the §4 for functions.\n"
"\n"
"Similarly of course §5. So when does §6?\n"
"\n"
"By transitivity of equality, it suffices for §7 and §8 to be equal.\n"
"\n"
"This suggests that it suffices to have a proof §9 for all elements §10.\n"
"\n"
"To reduce the question of proving an equality §11 to the question of proving that §12 for all §13, we must appeal to an axiom called *function extensionality*.\n"
"\n"
"Function extensionality is an instance of a general §14 tactic that can be used to prove equality in many types."
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Product Symmetry"
msgstr ""

#. §0: `n : ℕ`
#. §1: `Nat.add_zero n`
#. §2: `n + 0 = n`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
#: Game.Levels.NaturalNumbersWorld.L08_AddingSuccessors
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "For §0, §1 is the proof that §2."
msgstr ""

#. §0: `«{h}» : P → Q ∧ R`
#. §1: `«{p}»: P`
#. §2: `«{h}» «{p}» : Q ∧ R`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "We can apply the proof §0 to the proof §1 to obtain §2. How can these be used to prove the goal?"
msgstr ""

#. §0: `intro n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Use §0 to start your definition."
msgstr ""

#. §0: `succ : ℕ → ℕ`
#. §1: `pred : ℕ → ℕ`
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "The composite of §0 followed by §1 is the identity function."
msgstr ""

#. §0: `(P → Q) ∧ (P → R)`
#. §1: `P → Q ∧ R`
#. §2: `P → (Q ∧ R)`
#. §3: `S`
#. §4: `T`
#. §5: `S → (S → T) → T`
#. §6: `s : S`
#. §7: `h : S → T`
#. §8: `T`
#. §9: `h`
#. §10: `S`
#. §11: `s`
#. §12: `h s : T`
#. §13: `h`
#. §14: `s`
#. §15: `h : S → T`
#. §16: `h`
#. §17: `s : S`
#. §18: `h s : T`
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
msgid "The task in this level is to show another logical equivalence,\n"
"this time between the conjoined implications §0 and the implication §1, which is implicitly parenthesized as §2.\n"
"\n"
"The proof will require an idea that we have not used for a while. We've seen that for propositions §3 and §4,\n"
"§5 can be proven by introducing hypotheses §6 and §7, at which point the goal is to prove §8.\n"
"Then applying the hypothesis §9 reduces the goal to proving §10 which we know is true by §11.\n"
"\n"
"Recall there is special notation §12 for the proof constructed by applying the hypothesis §13 to the hypothesis §14.\n"
"\n"
"This notation is justified by the analogy between proofs of implications like §15 and functions. The proof §16 can be thought of as a function that takes a proof §17 and returns a proof §18."
msgstr ""

#. §0: `a : A`
#. §1: `B`
#. §2: `B → A`
#. §3: `a : A`
#. §4: `x : B`
#. §5: `a : A`
#: Game.Levels.FunctionWorld.L05_ConstantFunctions
msgid "Given a term §0 and any type §1, there is a function of type §2 which is *constant* at §3.\n"
"\n"
"This means that for any input §4 the output is always the element §5.\n"
"\n"
"Can you figure out how to define this function?"
msgstr ""

#. §0: `Unit ⊕ Unit`
#. §1: `Bool`
#. §2: `ℕ`
#: Game.Levels.EquivalenceWorld.L07_BossLevel
msgid "The equivalence between the types §0 and §1 has to do with the fact that both are examples of *inductive types*. In Natural Numbers World, we will finally properly introduce another inductive type, namely the type §2 of natural numbers. Go there next."
msgstr ""

#. §0: `P`
#. §1: `¬ P`
#. §2: `P`
#. §3: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "For any proposition §0, if §1 and §2 are both true, then we obtain a proof of §3."
msgstr ""

#. §0: `Or.inl`
#. §1: `Or.inr`
#. §2: `S ∨ T`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Recall §0 and §1 refer to the left and right propositions in a disjunction §2."
msgstr ""

#. §0: `Type`
#. §1: `A → A`
#. §2: `A : Type`
#. §3: `Type → Type`
#. §4: `A : Type`
#. §5: `A → A`
#. §6: `(A : Type) → A → A`
#. §7: `A : Type`
#. §8: `A → A`
#: Game.Levels.DependentWorld.L02_Functions
msgid "We have already seen many examples of dependent types and dependent functions indexed by the type §0 of types.\n"
"\n"
"For example, consider the family of types §1 indexed by §2. This defines an element of §3 defined to send §4 to the function type §5.\n"
"\n"
"Your task in this level is to define an element of the corresponding dependent function type §6. That is, for each §7, you are asked to define an element of type §8.\n"
"\n"
"Can you do it?"
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "For the Boss Level, your task is to:\n"
"\n"
"* break apart a function from a coproduct type into a product type into four separate component functions and\n"
"\n"
"* then reassemble four component functions to a single function from a coproduct type into a product type.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "If §0 and §1 are both surjective then §2 is also surjective."
msgstr ""

#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.BooleanWorld.L02_DoubleNegation
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Double Negation"
msgstr ""

#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "What tactics can be used to break a goal involving conjunction into subgoals?"
msgstr ""

#. §0: `«{p}» : not false = not true`
#. §1: `not false = true`
#. §2: `not true = false`
#. §3: `«{p}»`
#. §4: `true = false`
#. §5: `have eq : true = false := p`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Now where does the contradiction come from? We have exactly one hypothesis, namely §0. Recall that §1 and §2, with both of these equalities by definition. Thus §3 is also a proof of §4. You can add this to your context by §5."
msgstr ""

#. §0: `intro`
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L06_Currying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L07_Uncurrying
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a function type, so start with §0."
msgstr ""

#. §0: `P : A → Prop`
#. §1: `x : A`
#. §2: `a : A`
#. §3: `P a`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "Suppose the predicate §0 holds for all §1. Then for any particular element §2, §3 is true."
msgstr ""

#. §0: `intro n`
#. §1: `n`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The goal is a universally quantified statement. Start with §0 to consider an arbitrary natural number §1."
msgstr ""

#. §0: `P → Q → R → S → T`
#. §1: `intro p q r s`
#. §2: `p : P`
#. §3: `q : Q`
#. §4: `r : R`
#. §5: `s : S`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "For compound implications &mdash; statements of the form §0 &mdash; you can type §1 to introduce hypothesis §2, §3, §4, and §5 all at once."
msgstr ""

#. §0: `have eq1 : (g ∘ f) «{x}» = g (f «{x}») := rfl`
#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Use §0 and a similar lemma to give yourself more equalities to rewrite along."
msgstr ""

#. §0: `exact fun _ ↦ p
#. `
#. §1: `\\mapsto`
#. §2: `↦`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "The proof of an implication constructs a function which converts a proof of the first proposition into a proof of the second function. Try solving this level again by typing §0, using §1 to type the §2 symbol."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `A`
#. §4: `A ⊕ Empty`
#. §5: `A ⊕ Empty`
#. §6: `Sum.inl a`
#. §7: `a : A`
#. §8: `Sum.inr x`
#. §9: `x : Empty`
#. §10: `A ⊕ Empty`
#. §11: `A`
#. §12: `A → A ⊕ Empty`
#. §13: `A ⊕ Empty → A`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall that for any types §0 and §1, there is a *coproduct type* denoted §2.\n"
"\n"
"In particular, for any type §3, we may form the product §4 with the empty type.\n"
"\n"
"In general, coproduct types like §5 have two types of elements: those of the form §6 for some §7 and those of the form §8 for §9.\n"
"\n"
"But the empty type does not have any elements. So this second case does not exist.\n"
"\n"
"It follows that the type §10 is *equivalent* to the type §11 in a sense we cannot yet make precise.\n"
"\n"
"But we can at least show that there are functions §12 and §13.\n"
"\n"
"Your task in this level is to define these functions."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `P ∨ Q`
#. §2: `P ∧ Q → P ∨ Q`
#. §3: `P ∨ Q → P ∧ Q`
#. §4: `P ∧ Q → P ∨ Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∨ Q`
#: Game.Levels.DisjunctionWorld.L02_AndImpliesOr
msgid "The proposition §0 is *stronger* than the proposition §1 because §2 is true in general, but the implication §3 does not necessarily hold.\n"
"\n"
"Note the implication §4 holds because the mathematical or is *inclusive*, meaning that if §5 and §6 are both true, then §7 is true, and in fact can be proven in two different ways."
msgstr ""

#. §0: `cases «{gc}»`
#. §1: `rcases «{gc}» with ⟨b, hb⟩`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "Try §0 or §1."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∨ Q`
#. §3: `Q ∨ P`
#. §4: `Or.symm`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "We can improve our understanding of the symmetry of disjunction as follows.\n"
"\n"
"For propositions §0 and §1, §2 is true if and only if §3 is true.\n"
"\n"
"To prove this you might find it useful to use the theorem §4 proven in the previous level. This is now in your library."
msgstr ""

#. §0: `¬ (false = true)`
#. §1: `p : false = true`
#. §2: `False`
#. §3: `P : Bool → Prop`
#. §4: `false`
#. §5: `False`
#. §6: `true`
#. §7: `True`
#. §8: `True → False`
#. §9: `P true → P false`
#. §10: `x : P true`
#. §11: `p`
#. §12: `P false`
#. §13: `P true`
#. §14: `x : P true`
#. §15: `⟨⟩ : True`
#. §16: `False`
#. §17: `exact Bool.noConfusion`
#. §18: `¬ (false = true)`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "We will now finally prove an example that two elements of a type are distinct, demonstrating that\n"
"the two booleans are not equal:\n"
"\n"
"§0.\n"
"\n"
"The proof is quite delicate, so let us explain how it works.\n"
"\n"
"We are asked to prove a negation so suppose we have §1. We would like to derive a contradiction, that is an element of §2.\n"
"\n"
"The key ingredient is to use a function §3 defined to send the boolean §4 to the proposition §5 and the boolean §6 to the proposition §7.\n"
"\n"
"Using this we can define a function §8, i.e., a function §9 by introduction a hypothesis §10 then rewriting along the equality §11 to change the goal from §12 to §13, then returning §14.\n"
"\n"
"Applying this function to the element §15 returns an element of §16, a contradiction.\n"
"\n"
"Use the hints to step through this proof.\n"
"\n"
"Alternatively, type §17 to solve this level with Lean's built in proof that §18."
msgstr ""

#. §0: `A`
#. §1: `id : A → A`
#. §2: `a : A`
#. §3: `a : A`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "For a type §0, §1 is the function defined by sending §2 to §3."
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ x : A, ∃ y : B, f x = y`
#. §2: `f : A → B`
#. §3: `y : B`
#. §4: `x : A`
#. §5: `f x = y`
#. §6: `B`
#. §7: `f`
#. §8: `A`
#. §9: `y : B`
#. §10: `x : A`
#. §11: `f x = y`
#. §12: `∀ y : B, ∃ x : A, f x = y`
#. §13: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "Recall that every function is *total*. For any function §0, we have proven that\n"
"§1.\n"
"\n"
"A function §2 is *surjective* if for every §3 there exists some §4 so that §5.\n"
"\n"
"The condition asserts that every element of §6 is an output of the function §7 for some element of §8. For each §9 there is some §10 so that §11.\n"
"\n"
"Unlike totality, the statement §12 is true for some functions but false for others.\n"
"\n"
"In this level, we will show that the function §13 is surjective."
msgstr ""

#. §0: `X → A × B`
#. §1: `(X → A) × (X → B)`
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "Another equivalence of types captures the full universal property of product types.\n"
"\n"
"Namely the type of functions §0 into a product type is equivalent to the type of functions\n"
"\n"
"§1\n"
"\n"
"defined by taking the product of two function types."
msgstr ""

#. §0: `pred : Nat → Nat`
#. §1: `match n with | zero => exact ? | succ k => exact ?`
#. §2: `?`
#. §3: `pred zero`
#. §4: `?`
#. §5: `pred (succ k)`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "To define the function §0 by recursion type §1 replacing the first §2 with the value of §3 and the second §4 with the value of §5."
msgstr ""

#. §0: `P ∨ Q`
#. §1: `P`
#. §2: `Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P ∨ Q`
#. §6: `p : P`
#. §7: `q : Q`
#. §8: `exact p`
#. §9: `exact q`
#. §10: `P`
#. §11: `Q`
#. §12: `left`
#. §13: `right`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
msgid "To prove a disjunction §0 it suffices to supply a proof of either §1 or of §2.\n"
"\n"
"Thus under the hypothesis that §3 and §4 are both true, there are two ways to prove §5: one using §6 and one using §7.\n"
"\n"
"Note §8 or §9 won't work as these are proofs of different propositions, namely the proposition §10 or the proposition §11.\n"
"\n"
"To give a proof you have two choices: to reduce to the case of proving the left proposition or to reduce to the case of proving the right proposition.\n"
"\n"
"Type §12 to tell Lean you'd like to prove the left proposition or type §13 to tell Lean you'd like to prove the right proposition."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "The upshot of this level and the previous one is that in classical logic at least, a function is bijective if and only if it is invertible."
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a product type, so §0 can be used to break the goal into pieces."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `And.curry`
#. §4: `P ∧ Q → R`
#. §5: `P → Q → R`
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "For propositions §0, §1, and §2, §3 is a proof that §4 implies §5."
msgstr ""

#. §0: `ext`
#. §1: `ext b`
#. §2: `b : Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Type §0 to apply function extensionality or §1 to apply function extensionality with §2 the chosen variable."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `y : B`
#. §3: `z : B`
#. §4: `B`
#. §5: `B`
#. §6: `assumption`
#. §7: `exact`
#. §8: `E`
#. §9: `e : E`
#. §10: `exact e`
#. §11: `e`
#. §12: `exact`
#. §13: `P`
#. §14: `p : P`
#. §15: `exact p`
#. §16: `exact`
#: Game.Levels.TypeWorld.L03_ExactElements
msgid "A more elaborate context may contain multiple types and multiple elements, or a mix of types, elements, propositions, and proofs.\n"
"\n"
"Thus, we may require a more precise way to tell Lean which data or hypothesis from our context should be used.\n"
"\n"
"In this level, our context includes two types §0 and §1 with three elements between them. Note the use of a space rather than a list to indicate that §2 and §3 each define elements of type §4.\n"
"\n"
"Our goal is to define an element of type §5 and the tactic §6 will solve this goal. But this tactic does not convey to the reader which assumption was used.\n"
"\n"
"In this sort of setting, it is better practice to use the tactic §7. If the goal has type §8 and there is an element §9 in the context, then §10 uses the element §11 to close the goal.\n"
"\n"
"The §12 tactic can also be used when the goal is a proposition §13 and the context includes a proof §14. Then §15 will solve the goal.\n"
"\n"
"The tactic §16 can now be found in the library."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `x : A`
#. §3: `y : B`
#. §4: `ℕ`
#. §5: `ℤ`
#. §6: `ℚ`
#. §7: `ℝ`
#. §8: `ℂ`
#. §9: `ℕ`
#. §10: `0 : ℕ`
#. §11: `1 : ℕ`
#. §12: `57`
#. §13: `57`
#. §14: `P`
#. §15: `Q`
#. §16: `p : P`
#. §17: `q : Q`
#. §18: `P`
#. §19: `x`
#. §20: `y`
#. §21: `P`
#. §22: `x`
#. §23: `y`
#: Game.Levels.TypeWorld
msgid "In this world, we introduce two primitives:\n"
"\n"
"* *types* denoted with capital variables like §0 and §1 and\n"
"* *elements* written §2 or §3.\n"
"\n"
"For example, there are types §4 of\n"
"natural numbers, §5 of integers, §6 of rational numbers, §7 of real numbers, §8 of natural\n"
"numbers, and so on. There are also types of more sophisticated mathematical structures, like vector spaces or groups.\n"
"\n"
"Types can have more than one element. The elements of the type §9 are the familiar natural numbers:  §10, §11 and so on.\n"
"\n"
"By contrast, elements belong to unique types. The integer §12 is distinct from the natural number §13. This is one of the reasons why type theory is useful for precise mathematical communication: an element always carries the information of the type that it belongs to.\n"
"\n"
"Mathematical *propositions* can be thought of as a special case of types. For propositions §14 and §15, we think of\n"
"elements §16 and §17 as *proofs* that these propositions are true.\n"
"\n"
"By contrast, false propositions will not have any elements. In Negation World, we will learn how to prove that a proposition §18 is false.\n"
"\n"
"What distinguishes propositions from types is the fact that the elements do not contain any information beyond witnessing the truth of the proposition. If §19 and §20 are two proofs of a proposition §21, then §22 and §23 are equal in a sense that will be introduced in Equality World."
msgstr ""

#. §0: `Active Goal`
#. §1: `objects`
#. §2: `assumptions`
#. §3: `goal`
#. §4: `A`
#. §5: `a : A`
#. §6: `A`
#. §7: `A`
#. §8: `assumption`
#. §9: `enter`
#. §10: `Execute`
#. §11: `assumption`
#: Game.Levels.TypeWorld.L01_Elements
msgid "An interative theorem prover &mdash; in this case Lean &mdash; helps the user &mdash; this means you &mdash; keep track of the state of a proof or a mathematical construction.\n"
"\n"
"In the §0 window, Lean keeps track of the §1 and §2 &mdash; which together define the hypotheses of a mathematical statement &mdash; as well as the §3 &mdash; meaning the thing we are trying to prove.\n"
"\n"
"The objects and assumptions together define the mathematical *context* for a given theorem or construction.\n"
"\n"
"Here our context is given by a single type §4 with a hypothesized element §5.\n"
"\n"
"On the right-hand side we see the name of a type, which is the *goal* for this level. Here that type is §6, which means that our goal is to define an element of type §7.\n"
"\n"
"We have such an element by assumption, and you can type §8 to tell Lean this. Then type §9 or click the button §10 to ask Lean to check your work.\n"
"\n"
"Here §11 is an example of a *tactic*, which is built into Lean. You can find this in the tactic library on the upper right."
msgstr ""

#. §0: `((((V → F) → F) → F) → F)`
#. §1: `(V → F) → F`
#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "Given a function of type §0 there is a canonically defined function of type §1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
msgid "Are function types associative? Why or why not?"
msgstr ""

#. §0: `have np : ¬ P := by`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "If you used editor mode to prove some lemmas in the middle of this proof, it is good practice to indent the lines that form the proof of the lemma following the §0. This makes it more clear which steps are used to prove the lemma and which are used to prove the main goal. Go next to Equality World where we will finally introduce the slippery notion of mathematical equality."
msgstr ""

#. §0: `Unit`
#. §1: `⟨⟩ : Unit`
#. §2: `Unit`
#. §3: `assumption`
#. §4: `exact`
#. §5: `\\<`
#. §6: `\\>`
#. §7: `⟨⟩`
#: Game.Levels.TypeWorld.L04_UnitType
msgid "The previous levels involved type variables or proposition variables.\n"
"\n"
"But there are other specific types or propositions that exist in the empty context. In other words, these types are globally defined.\n"
"\n"
"One example is the unit type §0 which has a canonical element §1.\n"
"\n"
"Here our goal has type §2. We cannot solve this goal with the tactic §3 because we have not made an assumptions!\n"
"\n"
"But we can solve this level with the tactic §4 by typing the name of the canonical element.\n"
"\n"
"Use §5 and §6 to type the angle brackets §7."
msgstr ""

#: Game.Levels.ImplicationWorld
msgid "Implication World"
msgstr ""

#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "What can you do with these assumptions?"
msgstr ""

#. §0: `m`
#. §1: `n`
#. §2: `n + 0 = n`
#. §3: `m + (succ n) = succ (m + n)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "For all natural numbers §0 and §1, §2 and §3."
msgstr ""

#. §0: `match`
#. §1: `_`
#. §2: `and`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Was it necessary to consider all four cases of two boolean elements or can you define this function by considering fewer cases? If using the tactic §0, try replacement one of the input booleans with §1 to indicate that the value does not matter. The function §2 is now in your library."
msgstr ""

#. §0: `A × B`
#. §1: `A`
#. §2: `B`
#. §3: `a : A`
#. §4: `b : B`
#. §5: `A × B`
#. §6: `⟨a , b⟩ : A × B`
#. §7: `a : A`
#. §8: `b : B`
#. §9: `exact ⟨a,b⟩`
#. §10: `\\<`
#. §11: `\\>`
#. §12: `constructor`
#. §13: `A × B`
#. §14: `constructor`
#. §15: `A`
#. §16: `B`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "The introduction rule for product types tells us that elements of a product type §0 are formed by *pairing* elements of type §1 with elements of type §2.\n"
"\n"
"Given an element §3 and an element §4 there is a corresponding element of the product type §5 that is denoted by §6.\n"
"\n"
"This element should be thought of as an *ordered pair* whose first component is the element §7 and whose second element is the element §8.\n"
"\n"
"This can be input directly by typing §9 using §10 and §11 to type the angle brackets; note the spacing around the angle brackets and the commas is not important.\n"
"\n"
"Alternatively, you can apply the §12 tactic which allows you to first input the first component and then input the second component.\n"
"\n"
"When the goal is a product type §13, typing §14 will produce two goals, the first of which has type §15 and the second of which has type §16."
msgstr ""

#. §0: `p : A × B`
#. §1: `p.1 : A`
#. §2: `p.2 : B`
#. §3: `⟨p.1, p.2⟩ : A × B`
#. §4: `p`
#. §5: `⟨p.1, p.2⟩`
#. §6: `A × B`
#. §7: `p = ⟨p.1, p.2⟩`
#. §8: `x = y`
#. §9: `x`
#. §10: `y`
#. §11: `p = ⟨p.1, p.2⟩`
#. §12: `rfl : p = ⟨p.1, p.2⟩`
#. §13: `p.fst`
#. §14: `p.snd`
#. §15: `p.1`
#. §16: `p.2`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "The introduction rule for equality types is surprisingly weak, telling us only that proofs of equality can be defined by reflexivity.\n"
"\n"
"This tactic is stronger than it initially appears on account of the *computation rules* for elements of certain types.\n"
"\n"
"To illustrate, consider an element in a product type §0. Using the projections, we obtain terms\n"
"§1 and §2. These can then be paired back to form an element §3 in the product type.\n"
"\n"
"What is the relationship between §4 and §5?\n"
"\n"
"Firstly, both of these are elements of the same type, namely §6. Thus, there is a mathematically meaningful proposition\n"
"§7 because in general it makes mathematical sense to ask whether §8 whenever §9 and §10 are both terms belonging to the same type.\n"
"\n"
"In this case one of the *computation rules* for product types tells us that the proposition\n"
" §11 is true, essentially by definition of the projection and pairing functions associated to products. Thus the proof is again by reflexivity and we have §12.\n"
"\n"
"Note Lean uses §13 and §14 as synonyms for §15 and §16 respectively."
msgstr ""

#. §0: `P → Q`
#. §1: `Q`
#. §2: `P`
#. §3: `P → Q`
#. §4: `p : P`
#. §5: `P`
#. §6: `Q`
#. §7: `P → Q`
#. §8: `intro p`
#. §9: `p : P`
#. §10: `Q`
#. §11: `Q`
#. §12: `P`
#. §13: `intro`
#. §14: `P`
#. §15: `P`
#. §16: `P → P`
#. §17: `P`
#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "To prove an implication §0 one needs to give a construction of a proof of §1 from a hypothesized proof of §2.\n"
"\n"
"In particular, to prove that §3 it suffices to assume that we have a proof §4 &mdash; even if §5 is false and such a proof does not exist &mdash; in which case the new goal is to find a proof of §6.\n"
"\n"
"When the goal has the form §7, type §8 to introduce an assumption §9 and update the goal to proving §10 &mdash; asking for a proof that §11 is true under the assumption that §12 is true.  It is also possible to type simply §13 in which case Lean will automatically generate a name for the proof of §14.\n"
"\n"
"In this level, we will see that for any proposition §15, §16 is true. Indeed, this is the case even if §17 itself is false!"
msgstr ""

#. §0: `not : Bool → Bool`
#. §1: `Bool → Bool → Bool`
#. §2: `Bool → Bool → Bool`
#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "We have seen that the logical operation of negation can be encoded as a function §0.\n"
"\n"
"We can similarly define a function §1 that encodes the logical operation of conjunction.\n"
"\n"
"Again, this level comes with two pre-defined goals: the first is to define the conjunction function §2 and the second is to check that your definition is correct by calculating the values of the function you defined on explicit pairs of booleans."
msgstr ""

#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "We are now ready for the Boss Level of Equivalence World."
msgstr ""

#. §0: `intro`
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "When in doubt, start the proof of an implication with the §0 tactic."
msgstr ""

#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "This logical equivalence captures the *universal property* of disjunction, explaining how the mathematical or is used in a proof."
msgstr ""

#. §0: `f : A → B → C`
#. §1: `A`
#. §2: `B`
#. §3: `flip f : B → A → C`
#: Game.Levels.FunctionWorld.L07_SwappingInputs
msgid "Note that for a particular multvariable function §0, its type dictates that the variable of type §1 must be supplied before the variable of type §2. But as observed in this level, we can then define a corresponding function §3 which encodes the same information."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `(A → B) → (B → Empty) → (A → Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "For any types §0 and §1, there is a function §2 defined by composition."
msgstr ""

#. §0: `S ↔ T`
#. §1: `(S → T) ∧ (T → S)`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
msgid "Recall that §0 is an abbreviation for §1. What is the outermost connective here? Which tactic can be used to break this into subgoals?"
msgstr ""

#. §0: `«{na}»`
#. §1: `A`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "To apply the hypothesis §0 it would help to have a specific element of §1 to apply it to. Can you see where this might come from?"
msgstr ""

#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L06_CompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Can we apply our hypothesis yet or must we act on the goal first?"
msgstr ""

#. §0: `A → Empty`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "This level illustrates another strange construction that can be made from an element of type §0."
msgstr ""

#. §0: `x y : Unit`
#. §1: `x = y`
#: Game.Levels.EqualityWorld.L07_UnitProposition
msgid "The unit type is a proposition: for §0, §1."
msgstr ""

#: Game.Levels.EquivalenceWorld.L04_CurryingUncurrying
msgid "Currying / Uncurrying"
msgstr ""

#. §0: `P ∧ Q → R`
#. §1: `P → Q → R`
#. §2: `P → Q → R`
#. §3: `P ∧ Q → R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "In the previous level we proved that §0 implies §1.\n"
"\n"
"We now show that §2 implies §3."
msgstr ""

#. §0: `A`
#. §1: `Empty.elim : Empty → A`
#. §2: `f : A → Empty`
#. §3: `A`
#. §4: `Empty`
#. §5: `A`
#. §6: `A`
#. §7: `f : A → Empty`
#. §8: `a : A`
#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "We have seen that any type §0 has a function from the empty type §1.\n"
"\n"
"By contrast, if there is a function §2 from §3 to the empty type §4 then §5 must be very special: this is only possible if §6 is *equivalent* to the empty type.\n"
"\n"
"We do not have all the tools needed to define equivalence of types just yet, so in this level we observe something else.\n"
"\n"
"We will see that if there is a function §7 and if there is an element §8, then we get an element of the empty type, which is very strange indeed!\n"
"\n"
"Can you construct this element?"
msgstr ""

#. §0: `Nat.pred : ℕ → ℕ`
#. §1: `Nat.pred_succ n : Nat.pred (succ n) = n`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "The function §0 that you have just defined is now in your library as well as the theorem §1."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "The next topic in our study of propositional logic is *negation*, which is used to assert that a proposition is false rather than true. But to help us understand it, move on to Empty World to learn about the empty type."
msgstr ""

#: Game.Levels.DependentWorld
msgid "Dependent World"
msgstr ""

#. §0: `cases «{x}»`
#. §1: `«{x}»`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "Recall you can type §0 to ask Lean to consider which cases are actually possible for the hypothetical element §1."
msgstr ""

#: Game.Levels.TypeWorld.L02_Proofs
msgid "In the next level, we will learn a new tactic, which allows us to be more precise about which assumption is being used."
msgstr ""

#. §0: `B C : A → Type`
#. §1: `A`
#. §2: `B`
#. §3: `C`
#. §4: `A`
#. §5: `a : A`
#. §6: `B a`
#. §7: `C a`
#. §8: `(x : A) → B x`
#. §9: `B`
#. §10: `f : (x : A) → B x → C x`
#. §11: `B a → C a`
#. §12: `a : A`
#: Game.Levels.DependentWorld.L03_Application
msgid "In this level, we consider a pair of type families §0 indexed by the type §1.\n"
"\n"
"The families of types §2 and §3 can be pictured as &ldquo;bundles&rdquo; of types living over the &ldquo;base&rdquo; type §4. For each element §5, there is a corresponding fiber §6 and §7 specified by each type family.\n"
"\n"
"With this mental image, an element of the dependent function type §8 may also be thought of as a *section* of the type family §9, as it specifies an element of the fiber living over each element of the base type.\n"
"\n"
"In this level, you are given a dependent function §10 that specifies a map between fibers §11 for each element §12 of the base type.\n"
"\n"
"Using this, your task is define a function that sends a section of the first type family to a section of the second type family."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `Or.inl`
#. §3: `P → (P ∨ Q)`
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L01_IntroducingOr
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "For propositions §0 and §1, §2 is a proof that §3."
msgstr ""

#. §0: `P`
#. §1: `False → P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition §0, the implication §1 is true."
msgstr ""

#. §0: `False`
#. §1: `P`
#. §2: `False → P`
#. §3: `False`
#. §4: `Empty`
#. §5: `False`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "The proposition §0 has no elements &mdash; there are no proofs of &ldquo;false.&rdquo;\n"
"\n"
"Consequently, for any other proposition §1, the implication §2 is true.\n"
"\n"
"The task in this level is to prove this.\n"
"\n"
"The proposition §3 is really just another name for the empty type §4, so the constructions explored in Empty World can be used analogously to prove propositions involving §5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Now you are ready for the Boss Level."
msgstr ""

#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Applying Functions"
msgstr ""

#. §0: `cases «{p}»`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "Type §0 to ask Lean to consider all possible cases involving an element of the empty type. As there are no cases, this will complete the proof."
msgstr ""

#. §0: `not (and x y) = or (not x) (not y)`
#. §1: `not (or x y) = and (not x) (not y)`
#. §2: `x y : Bool`
#. §3: `!(x && y) = !x || !y`
#. §4: `!(x || y) = !x && !y`
#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "The DeMorgan laws for booleans take the form of equalities\n"
"\n"
"§0 and\n"
"\n"
"§1\n"
"\n"
"for all booleans §2.\n"
"\n"
"In Lean's alternate notation the first equality is\n"
"\n"
"§3\n"
"\n"
"while the second equality is\n"
"\n"
"§4.\n"
"\n"
"The objective of this level is to prove these equalities."
msgstr ""

#. §0: `A ⊕ B → C`
#. §1: `(A → C) × (B → C)`
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "Another equivalence of types captures the full universal property of coproduct types.\n"
"\n"
"Namely the type of functions §0 out of a coproduct type is equivalent to the type of functions\n"
"\n"
"§1\n"
"\n"
"defined by taking the product of two function types."
msgstr ""

#. §0: `P → Q`
#. §1: `P → Q`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "If §0 is true, then §1 is true."
msgstr ""

#. §0: `Bool`
#. §1: `false : Bool`
#. §2: `true : Bool`
#. §3: `Bool`
#. §4: `true : Bool`
#. §5: `false : Bool`
#. §6: `¬(true = false)`
#: Game.Levels.BooleanWorld
msgid "In this world, we'll meet the type §0 of *booleans*.\n"
"\n"
"This type has two elements: §1 and §2.\n"
"\n"
"Formally these elements are just two elements with distinct names.\n"
"\n"
"But the terminology suggests that we can think of §3 as the type of truth values, with §4 representing the true proposition and §5 representing the false proposition.\n"
"\n"
"In this world, we will define various functions involving the type of booleans.\n"
"\n"
"We will also show that the type of booleans is *not* a proposition by proving that §6."
msgstr ""

#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Multivariable Functions"
msgstr ""

#. §0: `«{k}»`
#. §1: `«{k}»`
#. §2: `«{hk}» : (∃ m, «{k}» = 2 * m) ∨ ∃ m, «{k}» = 2 * m + 1`
#. §3: `«{k}» + 1`
#. §4: `k`
#. §5: `rcases «{hk}» with even | odd`
#. §6: `«{k}»`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Now that you have completed the base case, the next goal is to prove the inductive step. Here §0 is an arbitrary natural number and you are given a hypothesis that the predicate is true for §1, i.e., that §2. Your goal is to prove that the analogous result holds for §3, aka, the successor of §4. Type §5 to split into cases depending on whether or not §6 is even or odd."
msgstr ""

#. §0: `Unit`
#. §1: `Type`
#. §2: `exact Unit`
#: Game.Levels.TypeWorld.L06_TypeOfTypes
msgid "In the previous level, we introduced the type §0. This is an element of the type §1, so you can solve this level by typing §2."
msgstr ""

#. §0: `«{c}».2`
#: Game.Levels.NegationWorld.L04_Noncontradiction
msgid "What is the logical structure of the type that §0 belongs to?"
msgstr ""

#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "The following expression in conjunctive normal form is satisfiable."
msgstr ""

#. §0: `Prop`
#. §1: `P : A → B → C → Prop`
#: Game.Levels.QuantifierWorld.L02_MoreTransitivity
msgid "In general families of propositions indexed by multiple variables are just functions with multiple input types valued in §0, such as §1."
msgstr ""

#. §0: `And.uncurry : (P → Q → R) → (P ∧ Q → R)`
#. §1: `P ∧ Q → R`
#. §2: `P → Q → R`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "This proves the theorem §0. In the next level, we will combine these results to show that §1 and §2 are logically equivalent."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B → B ⊕ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "For any types §0 and §1, there is a canonical function of type §2."
msgstr ""

#. §0: `0 : ℕ`
#. §1: `succ : ℕ → ℕ`
#. §2: `0`
#. §3: `1 = succ 0`
#. §4: `2 = succ (succ 0)`
#. §5: `3 = succ (succ (succ 0))`
#. §6: `4 = succ (succ (succ (succ 0)))`
#. §7: `rfl`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "How do we construct examples of natural numbers?\n"
"\n"
"By the introduction rules:\n"
"\n"
"* There is a natural number §0.\n"
"* There are natural numbers obtained by applying the function §1.\n"
"\n"
"Familiar *numerals* are defined by repeated applications of the successor function to the natural number §2. For example:\n"
"* §3\n"
"* §4\n"
"* §5\n"
"* §6\n"
"and so on.\n"
"\n"
"As all of these are definitions, the equalities in this level can be proven with §7."
msgstr ""

#. §0: `rcases «{h}» with ⟨b, hb⟩`
#. §1: `«{h}»`
#. §2: `b : B`
#. §3: `hb : ∀ w : A, P w b`
#: Game.Levels.QuantifierWorld.L06_CommutingQuantifiers
msgid "Type §0 to replace §1 by the pair of assumptions §2 and\n"
"§3."
msgstr ""

#. §0: `↔`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Recall the meaning of §0. What tactic breaks this goal into its components?"
msgstr ""

#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Distributivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "What is the logical structure of this type?"
msgstr ""

#: Game.Levels.NegationWorld.L05_Absurd
msgid "This might be a useful time to apply one of the theorems proven earlier in Negation World."
msgstr ""

#. §0: `Or.symm`
#. §1: `exact Or.symm`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "Did you give the same proof twice? If so, why does this make sense? If not, could you have done this? If your proof does not make use of the name §0 that Lean has assigned to the proof given in the previous level, try typing §1 at an appropriate place in your proof."
msgstr ""

#. §0: `«{ne}»`
#. §1: `(∃ x, P x) → False`
#. §2: `apply «{ne}»`
#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "The hypothesis §0 is a proof that §1. So try §2."
msgstr ""

#. §0: `f g : A → B`
#. §1: `∀ x : A, f x = g x`
#. §2: `f = g`
#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "For functions §0 if §1 then §2."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A ⊕ B) ⊕ C`
#. §4: `A ⊕ (B ⊕ C)`
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "For types §0, §1, and §2, there are canonical functions between the types §3 and §4."
msgstr ""

#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "More Compound Implication"
msgstr ""

#. §0: `(x : A) × B x`
#: Game.Levels.DependentWorld.L04_Pairs
msgid "The dependent pair type §0 has a pair of projection functions, sending a dependent pair to its first and second components respectively."
msgstr ""

#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "Next move on to Product World to meet a second type forming operation, which will again have a corresponding logical connective."
msgstr ""

#. §0: `match`
#. §1: `b : Bool`
#. §2: `match b with | false => ? | true => ?`
#. §3: `b`
#. §4: `b`
#. §5: `?`
#. §6: `x y : Bool`
#. §7: `match x y with | false, false => ? | false, true => ? | true, false => ? | true, true => ?`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "The tactic §0 can be used to define a function by cases. For example, in the context of an\n"
"element §1, §2 splits the construction into the case where §3 is false followed by the case where §4 is true. Here both §5 should be replaced by the appropriate sequence of tactics for each case, using semicolons if more than one tactic is needed. In the context of §6,\n"
"§7 splits into the four possible cases."
msgstr ""

#. §0: `B`
#. §1: `Empty.elim : Empty → B`
#. §2: `Empty`
#. §3: `B`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Recall that for any type §0, there is a function §1. Using this and your element of §2 can you define an element of type §3?"
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L01_Pairing
msgid "The §0 tactic can be used when the goal is a conjunction (among other settings) to split the goal into cases."
msgstr ""

#. §0: `h`
#. §1: `P`
#. §2: `Q`
#: Game.Levels.ConjunctionWorld.L07_MoreCompoundImplication
msgid "Since §0 is a compound implication, we have multiple hypothesis to satisfy. We must prove that §1 is true and also prove that §2 is true. Fortunately, our assumptions cover both cases."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `p`
#. §4: `P`
#. §5: `h1`
#. §6: `P → Q`
#. §7: `h2`
#. §8: `Q → R`
#. §9: `R`
#. §10: `apply`
#. §11: `have`
#. §12: `have`
#. §13: `p : P`
#. §14: `h1 : P → Q`
#. §15: `have q : Q := h1 p`
#. §16: `q : Q`
#. §17: `h1 p`
#. §18: `have`
#. §19: `R`
#. §20: `have r : R := h2 q`
#. §21: `r : R`
#. §22: `h2 q`
#. §23: `have`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "Now we are in the setting of three proposition variables §0, §1, and §2 with several hypotheses.\n"
"\n"
"The first assumption provides a proof §3 that the proposition §4 is true.\n"
"\n"
"The second provides a proof §5 that the implication §6 is true.\n"
"\n"
"The final hypothesis provides a proof §7 that §8 is true. Our goal is to conclude that §9 is true.\n"
"\n"
"This can be proven either backwards &mdash; by using the §10 tactic &mdash; or forwards &mdash; by directly constructing proofs out of our hypothesis.\n"
"\n"
"But it is also possible to work forwards with the §11 tactic, which is now in your library.\n"
"\n"
"The §12 tactic can be used to add new hypotheses provided you can supply a proof.\n"
"\n"
"For example, given assumptions §13 and §14, type §15 to add a proof §16 defined by §17.\n"
"\n"
"If you like, you can use the §18 tactic again to add a proof of §19 to the assumptions, by typing §20 to add a proof §21 defined by §22.\n"
"\n"
"The §23 tactic often makes proofs longer but it also makes them easier to read and easier to find.\n"
"\n"
"Practice using both forwards and backwards reasoning to solve this level."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
msgid "There are various ways to solve this level. You might enjoy searching for a shorter proof. For instance, there is a proof that takes just line and involves eight characters."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `¬ (P → Q)`
#. §3: `P ∧ ¬ Q`
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "In classical logic, for any propositions §0 and §1, §2 implies §3."
msgstr ""

#. §0: `have : (g ∘ f) «{a}» = ?? := rfl`
#. §1: `??`
#. §2: `rw [← ??]`
#. §3: `\\l`
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "You can either prove a lemma §0 by replacing the §1 with the definition of the composition function. Or you can try §2 using §3 to type the left arrow."
msgstr ""

#. §0: `Prop`
#. §1: `True`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The type of propositions §0 contains propositions like §1."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L11_BossLevel
msgid "Zero is not the successor of any natural number."
msgstr ""

#: Game.Levels.EqualityWorld.L08_EmptyProposition
msgid "Empty Proposition"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Does this proof of modus ponens feel familiar?"
msgstr ""

#. §0: `Classical.byContradiction : ¬ ¬ P → P`
#. §1: `Classical`
#. §2: `exact byContradiction`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "Lean has a built-in name §0 for this implication, which is also called *double negation elimination*. In the source files for Classical World, we have told that we want to use classical reasoning (by opening the §1 namespace), which is why typing §2 suffices to solve this level."
msgstr ""

#: Game.Levels.QuantifierWorld.L07_NegatingExistence
msgid "Negating Existence"
msgstr ""

#. §0: `rfl`
#. §1: `x = y`
#. §2: `x`
#. §3: `y`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Once more, §0 can also be used to prove propositions of the form §1 when §2 and §3 are equal *by definition* (rather than by a more complicated chain of reasoning)."
msgstr ""

#. §0: `Bool`
#. §1: `Bool.false`
#: Game.Levels.BooleanWorld.L01_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "There is an element of type §0 called §1."
msgstr ""

#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "In the next level, we will see that coproduct types are similarly symmetric."
msgstr ""

#: Game.Levels.EmptyWorld.L04_Composition
msgid "Composition"
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `A`
#. §3: `C`
#. §4: `g ∘ f : A → C`
#. §5: `\\circ`
#. §6: `∘`
#. §7: `g ∘ f`
#. §8: `a : A`
#. §9: `f a : B`
#. §10: `g (f a) : C`
#. §11: `comp : (B → C) → (A → B) → (A → C)`
#. §12: `g : B → C`
#. §13: `f : A → B`
#. §14: `comp g f : A → C`
#. §15: `g`
#. §16: `f`
#. §17: `a : A`
#. §18: `g (f a) : C`
#. §19: `comp`
#. §20: `∘`
#. §21: `comp g f`
#. §22: `g ∘ f`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "Recall that given functions §0 and §1 there is a *composite function* from §2 to\n"
"§3 denoted §4, using §5 to type §6.\n"
"\n"
"The function §7 is defined to be the function that sends §8 first to the element §9 and then\n"
"to the element §10.\n"
"\n"
"The goal in this level is to define composition as a multivariable function between function types §11.\n"
"\n"
"We think often think of composition as the function that takes §12 and §13 to the composite function §14.\n"
"\n"
"But it can also be thought of a function that takes §15, §16, and §17 to the element §18.\n"
"\n"
"Aside: Lean treats the functions §19 and §20 slightly differently because the former uses the usual notation for multivariable functions (where the arguments are provided afterwards as §21) while the latter uses infix notation (where the function name appears inbetween the two arguments as §22)."
msgstr ""

#. §0: `a : A`
#. §1: `Sum.inl a : A ⊕ B`
#: Game.Levels.CoproductWorld.L01_LeftInclusion
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For any §0, there is an element §1."
msgstr ""

#. §0: `A × B → C`
#. §1: `A → B → C`
#. §2: `A`
#. §3: `B`
#. §4: `C`
#. §5: `f : A × B → C`
#. §6: `⟨a, b⟩ : A × B`
#. §7: `C`
#. §8: `g : A → B → C`
#. §9: `a : A`
#. §10: `g a : B → C`
#. §11: `b : B`
#. §12: `C`
#. §13: `A → B → C`
#. §14: `A × B → C`
#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "We have seen that the types §0 and §1 both provide a notion of function of two variables, with inputs from the types §2 and §3 and output in the type §4. The difference is that §5 is thought of as a function that takes a pair §6 to an element of type §7, while §8 is thought of as a function that takes §9 to a function §10 (which then takes §11 to an element of type §12).\n"
"\n"
"The process of converting a function of type  §13 to one of type §14 is called *uncurrying*. Your task in this level is to define the uncurrying function."
msgstr ""

#. §0: `0`
#. §1: `0`
#: Game.Levels.NaturalNumbersWorld.L04_Recursion
msgid "Here you are asked to show that the value of the function you have just defined at §0 equals §1."
msgstr ""

#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "The converse implication is classical but not constructive as you will show in the Boss Level."
msgstr ""

#: Game.Levels.TypeWorld.L03_ExactElements
msgid "Exact Elements"
msgstr ""

#. §0: `absurd`
#. §1: `exact absurd`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "Lean has a built in name §0 for the theorem you have just proven, so this level may be solved with §1. This has been added to the theorem library."
msgstr ""

#. §0: `b : Bool`
#. §1: `b = not (not b)`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "For any §0, §1."
msgstr ""

#. §0: `«{A}» → «{A}»`
#. §1: `x : «{A}»`
#. §2: `«{A}»`
#. §3: `intro x`
#. §4: `«{A}»`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "To define a function, in this case an element of type §0, one must define a rule to convert an arbitrary element §1 to some element of type §2. Start by typing §3 to add an arbitrary element of type §4 to the context."
msgstr ""

#: Game.Levels.NegationWorld.L11_BossLevel
msgid "Move on to Classical World to better understand the statements involving negation that we have not been able to prove thus far."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Prod.swap : A × B → B × A`
#. §3: `⟨a, b⟩`
#. §4: `⟨b, a⟩`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "For types §0 and §1, the function §2 can be thought of as the function that sends a pair §3 to the pair §4."
msgstr ""

#. §0: `rfl`
#. §1: `x = y`
#. §2: `x`
#. §3: `y`
#: Game.Levels.EqualityWorld.L02_PairedProjections
msgid "In summary, §0 can also be used to prove propositions of the form §1 when §2 and §3 are equal *by definition*, rather than by a more complicated chain of reasoning."
msgstr ""

#: Game.Levels.EqualityWorld
msgid "Equality World"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Where have you seen this construction before? Can you solve this level in a different way?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A × B`
#. §3: `B × A`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "For any types §0 and §1, the product types §2 and §3 are equivalent."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Negation"
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P`
#. §2: `P → ¬ ¬ P`
#. §3: `P`
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The *double negation* of a proposition §0 is the proposition §1.\n"
"\n"
"In this level, we reinterpret the construction from the previous level as a proof that the implication §2 is always true, no matter whether or not §3 is true."
msgstr ""

#. §0: `«{h}».1 : «{P}»`
#. §1: `«{h}».2 : «{Q}» ∨ «{R}»`
#. §2: `have p := «{h}».1`
#. §3: `have qr := «{h}».2`
#. §4: `p`
#. §5: `qr`
#. §6: `cases «{h}».2`
#. §7: `rcases`
#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "Recall that §0 and §1. We can introduce these as named variables in the context by typing §2 and §3 where §4 and §5 are variable names you get to pick. This allows you to case split on an explicitly named variable. Alternatively, type §6, or use §7 to name your own variables."
msgstr ""

#. §0: `∀ m n : ℕ, succ m = succ n → m = n`
#. §1: `pred : ℕ → ℕ`
#: Game.Levels.NaturalNumbersWorld.L10_SuccessorInjectivity
msgid "In this level, we will prove the third Peano axiom using the introduction and elimination rules for the type of natural numbers.\n"
"\n"
"Your objective is to show that the successor function is injective: §0.\n"
"\n"
"There are several ways to make use of the function §1 to prove this, either by applying results from the library or by stating and proving helpful lemmas."
msgstr ""

#. §0: `constructor`
#. §1: `«{A}» → «{C}»`
#. §2: `«{B}» → «{C}»`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "Now the goal is a product type. The §0 tactic will split into two subgoals, defining the functions §1 and §2 respectively."
msgstr ""

#: Game.Levels.CoproductWorld.L06_Associativity
msgid "Next we will study the relationship between products and coproducts."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f : A → C`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "If §0 and §1 are both injective functions, then §2 is also injective."
msgstr ""

#. §0: `constructor`
#. §1: `constructor`
#. §2: `fun s ↦ t`
#. §3: `S → T`
#. §4: `\\mapsto`
#. §5: `↦`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "To practice using the syntax for elements of conjunctions, try to solve this level with fewer uses of the §0 tactic. In fact, the §1 tactic can be avoided entirely by using expressions like §2 to prove implications like §3, writing §4 to type §5."
msgstr ""

#. §0: `∀ x : A, P x`
#. §1: `intro x`
#. §2: `P x`
#: Game.Levels.QuantifierWorld.L01_UniversalTruth
msgid "To prove a statement of the form §0 start with §1. Your goal is then to prove the proposition §2."
msgstr ""

#. §0: `«{f}» : A → Empty`
#. §1: `«{a}» : A`
#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "We have assumptions §0 and §1? What can you construct using this?"
msgstr ""

#. §0: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "The composite of the function §0 with itself equals the identity function"
msgstr ""

#. §0: `A × B`
#. §1: `B × A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "Product types are symmetric: an element of type §0 has a corresponding element of type §1 with components swapped."
msgstr ""

#. §0: `A`
#. §1: `x y : A`
#. §2: `x = y`
#. §3: `p q : x = y`
#. §4: `x`
#. §5: `y`
#. §6: `p = q`
#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "Given any type §0 and any elements §1, the *equality type* defines a type §2.\n"
"\n"
"This type is also a proposition, meaning that it has at most one element.\n"
"\n"
"Put more precisely, if §3 are two proofs that §4 equals §5, then definitionally we have that §6."
msgstr ""

#. §0: `A`
#. §1: `Empty → A`
#. §2: `A → Empty`
#. §3: `A → B → C`
#. §4: `B → A → C`
#: Game.Levels.EquivalenceWorld.L03_SwappingInputs
msgid "Function types are *not* symmetric: when §0 is non-empty, the types §1 and §2 are not equivalent.\n"
"\n"
"However in the case of functions with multiple variables, the input variables can be exchanged.\n"
"\n"
"In this level, you will show that the types §3 and §4 are equivalent."
msgstr ""

#. §0: `P → Q`
#. §1: `</>`
#. §2: `editor mode`
#. §3: `>_`
#. §4: `typewriter mode`
#. §5: `typewriter mode`
#. §6: `retry`
#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "There are two ways to prove that §0 under the assumption given below. Can you find them both?\n"
"\n"
"To delete a proof (or proof attempt) and start over, you might find it helpful to click on the button labelled §1 in the upper right hand corner to enter §2. Then delete all the lines of your first proof (or proof attempt). Clicking on §3 takes you back to §4.\n"
"\n"
"You can also delete a proof attempt in line by line in §5 using the §6 button to the right of that line."
msgstr ""

#: Game.Levels.QuantifierWorld
msgid "Quantifier World"
msgstr ""

#. §0: `exact fun x ↦ x`
#. §1: `\\mapsto`
#. §2: `↦`
#. §3: `fun x ↦ x : A → A`
#. §4: `x`
#. §5: `x`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "You can solve this level in one line by just giving the entire formula for the function as\n"
"§0, using §1 to type §2. Here §3 is Lean syntax for the identity function. This tells Lean that the answer is the function defined on an input element §4 to have an output value §5."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L13_FunctionExtensionality
msgid "Function Extensionality"
msgstr ""

#. §0: `indunction n with k hk`
#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "To use the principle of mathematical induction, type §0."
msgstr ""

#. §0: `P`
#. §1: `Classical.em P : P ∨ ¬ P `
#. §2: `P`
#. §3: `¬ P`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "For any proposition §0, §1 proves that §2 or §3 is true."
msgstr ""

#: Game.Levels.DisjunctionWorld.L07_Distributivity
msgid "This proves the that conjunction distributes over disjunction. A more involved form of distributivity appears in the next level."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "What can you conclude from the hypothesis §0?"
msgstr ""

#. §0: `rcases`
#. §1: `cases`
#. §2: `h : P ∨ Q`
#. §3: `rcases h with p | q`
#. §4: `cases h`
#. §5: `p : P`
#. §6: `q : Q`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "§0 is a tactic that will perform §1 recursively, according to a pattern. One use is to provide explicit names for variables in each subgoal. For example, given a hypothesis §2, §3 can be used in place of §4 to give hypotheses §5 in the first case and §6."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `Function.comp : (B → C) → (A → B) → (A → C)`
#. §4: `C`
#. §5: `Function.comp : (B → Empty) → (A → B) → (A → Empty)`
#. §6: `(A → B) → (B → Empty) → (A → Empty)`
#: Game.Levels.EmptyWorld.L04_Composition
msgid "In this level, we will revisit the composition function in the presence of the empty type.\n"
"\n"
"Recall that for any types §0, §1, and §2, composition defines a function:\n"
"\n"
"§3.\n"
"\n"
"In particular, if §4 is the empty type, composition defines a function:\n"
"\n"
"§5.\n"
"\n"
"Your task in this level is to define the closely related variant of the composition function which has type:\n"
"\n"
"§6\n"
"\n"
"This construction will be analogous to something we will encounter in Negation World."
msgstr ""

#. §0: `g : B → A`
#. §1: `g (f «{x}») = «{x}»`
#. §2: `«{x}» : A`
#. §3: `apply inj`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "If §0 is the name of the inverse function you defined using the axiom of choice, you are now meant to show that §1 for an arbitrary element §2. Here you can apply the injectivity hypothesis by typing §3."
msgstr ""

#: Game.Levels.DisjunctionWorld.L09_BossLevel
msgid "We've now reached the Boss Level in the Disjunction World.\n"
"\n"
"This level illustrates that proofs by cases can be somewhat delicate.\n"
"\n"
"Have fun!"
msgstr ""

#. §0: `A → (B → C)`
#. §1: `A → B → C`
#. §2: `(A → B) → C`
#. §3: `f : A → B`
#. §4: `C`
#. §5: `a : A`
#. §6: `(A → B) → B`
#. §7: `a : A`
#. §8: `f : A → B`
#. §9: `f a : B`
#: Game.Levels.FunctionWorld.L09_Evaluation
msgid "While an element of type §0, more commonly written as §1, is a function of two variables, an element of type §2 is instead a function that takes a function §3 as input and returns an element of type §4.\n"
"\n"
"For example, if we are given §5, then it is possible to define a function of type §6 which is called *evaluation* at §7. Given §8, we return §9.\n"
"\n"
"Your task in this level is to define the evaluation function."
msgstr ""

#. §0: `constructor`
#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "The goal is a product of function types, so to define an element you need to define two different functions. Each will take some work, so start with the §0 tactic to split one goal into two goals."
msgstr ""

#. §0: `Empty ⊕ (Empty → Empty)`
#. §1: `(Empty → Empty) × (Empty → Empty)`
#: Game.Levels.EmptyWorld.L07_BossLevel
msgid "There are functions in both directions between the types §0 and §1."
msgstr ""

#. §0: `have : (g ∘ f) «{a}» = ? := rfl`
#. §1: `?`
#. §2: `rw [← ?]`
#. §3: `\\l`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "You can either prove a lemma §0 by replacing the §1 with the definition of the composition function. Or you can try §2 for an appropriate proof of equality using §3 to type the left arrow."
msgstr ""

#. §0: `g : X → A`
#. §1: `h : X → A`
#. §2: `X`
#. §3: `A × B`
#: Game.Levels.ProductWorld.L09_UniversalProperty
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "A pair of functions §0 and §1 may be combined into a single function from §2 to the product type §3."
msgstr ""

#: Game.Levels.BooleanWorld.L09_BossLevel
msgid "If this was too easy, you might find it interesting to learn that the general problem of identifying whether a formula in conjunctive normal form is satisfiable is NP complete! Move on to Quantifier World to meet the universal and existential quantifiers."
msgstr ""

#. §0: `«{h}»`
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Try applying the hypothesis §0."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `x : A`
#. §3: `B`
#. §4: `A → B`
#. §5: `intro x`
#. §6: `x : A`
#. §7: `B`
#. §8: `A → B`
#. §9: `A`
#. §10: `B`
#. §11: `intro`
#. §12: `A`
#. §13: `id : A → A`
#. §14: `a : A`
#. §15: `Show more help!`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The *introduction rule* for function types explains how functions may be constructed.\n"
"\n"
"To define a function from a type §0 to a type §1 one has the following obligation: for an arbitrary element §2 of the first type &mdash; a potential *input* to the function &mdash; one must specify an element of type §3 &mdash; the corresponding *output*.\n"
"\n"
"When the goal is a function type §4, start by typing §5 to add an arbitrary element §6 to the context and update the goal to a term of type §7.\n"
"\n"
"In other words, one specifies a function of type §8 by giving a formula that converts an arbitrary input element of type §9 into its corresponding output element of type §10.\n"
"\n"
"Using the §11 tactic &mdash; which is now in the tactic library &mdash; plus the tactics introduced in Type World, you should be able to define your first function.\n"
"\n"
"The identity function is a simple but important example of a function that may be defined for any type §12. The identity function, denoted §13, is defined to carry any element §14 to itself.\n"
"\n"
"The goal in this level is to define this function.\n"
"\n"
"If you need help, click the button §15 for reminders/hints."
msgstr ""

#. §0: `f : A × B → C`
#. §1: `a : A`
#. §2: `b : B`
#. §3: `C`
#. §4: `f ⟨a,b⟩`
#. §5: `g : A → B → C`
#. §6: `g`
#. §7: `a : A`
#. §8: `b : B`
#. §9: `C`
#. §10: `g a b : C`
#. §11: `A × B → C`
#. §12: `A → B → C`
#. §13: `A`
#. §14: `B`
#. §15: `C`
#. §16: `f : A × B → C`
#. §17: `⟨a, b⟩ : A × B`
#. §18: `C`
#. §19: `g : A → B → C`
#. §20: `a : A`
#. §21: `g a : B → C`
#. §22: `b : B`
#. §23: `C`
#. §24: `A × B → C`
#. §25: `A → B → C`
#: Game.Levels.ProductWorld.L06_Currying
msgid "Consider a function §0 mapping out of a product type.\n"
"\n"
"This function takes an ordered pair of elements &mdash; defined from §1 and §2 &mdash; and returns an element of type §3 denoted by §4. Does this sound familiar?\n"
"\n"
"Recall that terms of type §5 are functions of two variables.\n"
"\n"
"The function §6 takes a list of two elements §7 and §8 and returns an element of type §9 denoted by §10.\n"
"\n"
"In summary, the types §11 and §12 both provide a notion of function of two variables, with inputs from the types §13 and §14 and output in the type §15.\n"
"\n"
"The difference is that §16 is thought of as a function that takes a pair §17 to an element of type §18, while §19 is thought of as a function that takes §20 to a function §21 (which then takes §22 to an element of type §23).\n"
"\n"
"The process of converting a function of type §24 to one of type §25 is called *currying*. Your task in this level is to define the currying function."
msgstr ""

#. §0: `P ∧ Q`
#. §1: `Q ∧ P`
#: Game.Levels.ConjunctionWorld.L04_LogicalEquivalence
#: Game.Levels.ConjunctionWorld.L08_CurryingImplication
#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "§0 is true if and only if §1 is true."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → A`
#. §2: `(∀ a : A, g (f a) = a) ∧ (∀ b : B, f (g b) = b)`
#. §3: `g : B → A`
#: Game.Levels.AdvancedFunctionWorld.L10_InverseInvertibility
msgid "Suppose §0 is an invertible function.\n"
"\n"
"This means that there exists a function §1 so that §2.\n"
"\n"
"In this level, we will see that the inverse function §3 is itself invertible."
msgstr ""

#. §0: `1 + 5 = 2 * 3`
#. §1: `succ (succ (succ (succ (succ (succ 0))))`
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "More complicated arithmetic equations involving numerals also hold by definition: for example §0\n"
"\n"
"This is because these elements on both the left-hand and right-hand sides reduce to a common *normal form*, an explicit numeral of the form §1."
msgstr ""

#. §0: `A`
#. §1: `Empty.elim : Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type §0, there is a function §1 expressing the elimination rule of the empty type."
msgstr ""

#: Game.Levels.EmptyWorld.L02_ToEmpty
msgid "To Empty"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P ∨ Q) ∨ R`
#. §4: `P ∨ (Q ∨ R)`
#. §5: `P ∨ Q ∨ R`
#. §6: `P ∨ (Q ∨ R)`
#. §7: `h₁ : (P ∨ Q) ∨ R`
#. §8: `cases h₁`
#. §9: `P ∨ Q`
#. §10: `R`
#. §11: `h₂ : P ∨ Q ∨ R`
#. §12: `cases h₂`
#. §13: `P`
#. §14: `Q ∨ R`
#. §15: `rcases`
#. §16: `h₁ : (P ∨ Q) ∨ R`
#. §17: `rcases h₁ with (p | q) | r`
#. §18: `h₂ : P ∨ Q ∨ R`
#. §19: `rcases h₂ with p | q | r`
#. §20: `\\7`
#. §21: `₇`
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Similarly, for propositions §0, §1, and §2, §3 holds if and only if §4 holds.\n"
"\n"
"Similarly to the conventions used for products, conjunctions, and coproducts, Lean uses §5 as an abbreviation for §6.\n"
"\n"
"Given a hypothesis §7, §8 will split the hypothesis into two cases: one assuming that §9 is true and the other assuming §10 is true.\n"
"\n"
"Similarly given a hypothesis §11, §12 the hypothesis into two cases: one assuming that §13 is true and the other assuming §14 is true.\n"
"\n"
"Note the §15 tactic allows more general patterns of disjunctions. Given §16 try §17. Similarly, given §18, try §19.\n"
"\n"
"Aside: Typing §20 using any single digit number produces a subscript with that number, like §21. You can use this if you'd like to use numerical subscripts in your variable names."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Define the uncurrying function, convering a function of two variables into a function out of a product type."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "Invertible Implies Bijective"
msgstr ""

#. §0: `use ??`
#. §1: `??`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Type §0 with a well-chosen element in place of the §1."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.ConjunctionWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Associativity"
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "Pairing"
msgstr ""

#. §0: `False`
#. §1: `p : P`
#. §2: `P`
#. §3: `False`
#. §4: `P`
#. §5: `P → False`
#. §6: `P`
#. §7: `¬ P`
#. §8: `¬ P`
#. §9: `P`
#. §10: `p : P`
#. §11: `False`
#. §12: `False`
#. §13: `P`
#: Game.Levels.NegationWorld
msgid "In this world, we will study the proposition §0 and the logical operation of *negation*.\n"
"\n"
"Recall that an element §1 of a proposition §2 may be thought of as a proof that the proposition is true. We do not have any proofs of the proposition §3, so it does not contain any elements.\n"
"\n"
"For any proposition §4, we define its *negation* to be the proposition §5, pronounced &ldquo;§6 implies false&rdquo;. This is commonly abbreviated with the shorthand §7, pronounced &ldquo;not P&rdquo;.\n"
"\n"
"A *proof of negation* means a proof of a proposition of the form §8 for some proposition §9.\n"
"\n"
"Using the introduction rule for implications, such a proof starts by assuming §10 and then deriving an element of §11.\n"
"\n"
"Since §12 has no elements, we think of this process as deriving a contradiction.\n"
"\n"
"There is a related technique called *proof by contradiction* for proving that §13 is true that will be discussed in Classical World, as one of the proof strategies that is available when reasoning non-constructively.\n"
"\n"
"By contrast, a proof of negation is constructive, as it is analogous to the construction of a function between types, as we saw in Empty World."
msgstr ""

#. §0: `h`
#. §1: `a`
#. §2: `exact h a`
#. §3: `apply h`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "To apply the proof §0 at the specific element §1, type §2. Alternatively, you can start with §3."
msgstr ""

#. §0: `not : Bool → Bool`
#. §1: `false`
#. §2: `true`
#. §3: `true`
#. §4: `false`
#. §5: `b : Bool`
#. §6: `b = not (not b)`
#. §7: `not b`
#. §8: `b`
#. §9: `false`
#. §10: `true`
#. §11: `! b`
#. §12: `not b`
#: Game.Levels.BooleanWorld.L02_DoubleNegation
msgid "In the last level, we defined the negation function\n"
"§0 which sends the element §1 to §2 and §3 to §4.\n"
"\n"
"The negation has the property that for any boolean §5, §6.\n"
"\n"
"Interestingly the proof is not by reflexivity! This is because we only defined §7 to have a particular value when §8 is one of the elements §9 or §10.\n"
"\n"
"See if this is enough of a hint to solve this level.\n"
"\n"
"Note Lean has an alternate notation §11 for §12."
msgstr ""

#. §0: `A ⊕ B → B ⊕ A`
#. §1: `cases`
#. §2: `rcases`
#. §3: `A ⊕ B`
#. §4: `left`
#. §5: `right`
#. §6: `B ⊕ A`
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "The coproduct type, like the product type, is *symmetric*, and in particular has a canonical map of type §0. Your task in this level is to define it.\n"
"\n"
"Use the elimination rule for coproduct types and the associated tactics §1 or §2 to map out of the type §3.\n"
"\n"
"Then use the introduction rules for coproduct types and the associated tactics §4 and §5 to map into the type §6."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `C`
#. §3: `(A → B) → C`
#. §4: `A → (B → C)`
#. §5: `(A → B) → C`
#. §6: `A`
#. §7: `B`
#. §8: `C`
#. §9: `A → (B → C)`
#. §10: `A → B → C`
#. §11: `A → (B → C)`
#. §12: `f : A → B → C`
#. §13: `A`
#. §14: `B`
#. §15: `C`
#. §16: `f`
#. §17: `A`
#. §18: `B → C`
#. §19: `f : A → B → C`
#. §20: `a : A`
#. §21: `f a : B → C`
#. §22: `B`
#. §23: `C`
#. §24: `b : B`
#. §25: `f a`
#. §26: `f a b : C`
#. §27: `exact`
#. §28: `apply`
#. §29: `intro`
#. §30: `intro`
#. §31: `exact`
#. §32: `apply`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Function types can be iterated.\n"
"\n"
"In particular, given types §0, §1, and §2, we may form the function types §3 and §4. These types are not the same!\n"
"\n"
"Elements of the type §5 are functions that take a function from §6 to §7 as input and return an element of type §8 as output. Functions of this form exist but they are relatively obscure.\n"
"\n"
"By contrast, elements of the type §9 are *multivariable functions*, which take more than one input before returning an output. As these are relatively common, the simplified notation §10 is used as an abbreviation for the type §11.\n"
"\n"
"A multivariable function §12 takes a first input from type §13 and a second input from type §14 before returning an output of type §15.\n"
"\n"
"The element §16 may also be thought of as a function that takes an element of type §17 and returns a of type §18.\n"
"\n"
"Given §19 and §20, then §21 is a function from §22 to §23.\n"
"\n"
"Then given §24 we can apply the function §25 to get an element §26.\n"
"\n"
"In this level, you are given a multivariable function together with an element from its first input type. You are asked to define a function of the appropriate function type.\n"
"\n"
"This level can be solved by starting with §27, starting with §28, or starting with §29. If you start with §30, then you can continue with §31 or with §32. If this is your first time solving this level, try to find a different solution."
msgstr ""

#: Game.Levels.ProductWorld.L01_Pairing
msgid "If this is your first time solving this level, go back and solve it another way."
msgstr ""

#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "Multiple Quantifiers"
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "Defining Addition"
msgstr ""

#. §0: `intro g f`
#. §1: `intro g f a`
#: Game.Levels.FunctionWorld.L08_CompositionRevisited
msgid "To define a function with multiple variables you can apply the intro tactic twice, for instance by typing §0 or even §1."
msgstr ""

#. §0: `Sum.inl`
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "If your answer does not use the function §0, you might have fun trying to solve this level again using it in an appropriate place."
msgstr ""

#. §0: `have lemP : P ∨ ¬ P := em P`
#. §1: `P ∨ ¬ P`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "To use the law of excluded middle in your proof, type §0 to add an assumption that §1 is true."
msgstr ""

#. §0: `«{Q}» ∨ «{P}»`
#: Game.Levels.DisjunctionWorld.L03_UsingOr
msgid "Note now that Lean provides two goals, both of which are to prove that §0 is true, under two different hypothesies. Your first task is to prove the theorem in the first case."
msgstr ""

#: Game.Levels.ConjunctionWorld.L09_UniversalProperty
#: Game.Levels.DisjunctionWorld.L05_UniversalProperty
msgid "Universal Property"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "Injectivity"
msgstr ""

#. §0: `«{eq}»`
#. §1: `have neq : ¬ (true = false) := Bool.noConfusion`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "To get the contradiction, you should now add a proof of the negation of §0. You can do this with §1."
msgstr ""

#. §0: `P`
#. §1: `A`
#. §2: `P : A → Prop`
#. §3: `A`
#. §4: `P`
#. §5: `x : A`
#. §6: `P x : Prop`
#. §7: `Prime : ℕ → Prop`
#. §8: `n : ℕ`
#. §9: `n`
#. §10: `n`
#. §11: `n`
#. §12: `A`
#. §13: `= : A → A → Prop`
#. §14: `x y : A`
#. §15: `x = y`
#. §16: `x`
#. §17: `y`
#. §18: `P : A → Prop`
#. §19: `A`
#. §20: `∀`
#. §21: `∀ x : A, P x`
#. §22: `P a`
#. §23: `a : A`
#. §24: `∃`
#. §25: `∃ x : A, P x`
#. §26: `a : A`
#. §27: `P a`
#. §28: `∀`
#. §29: `∃`
#: Game.Levels.QuantifierWorld
msgid "The statements of many mathematical propositions require the use of *variables* drawn from previously-defined types.\n"
"\n"
"A *predicate* §0 on a type §1 is a function §2 from §3 to the type of propositions.\n"
"\n"
"We also refer to a predicate §4 as a *family of propositions* or an *indexed family of propositions* because for each element §5, we have a proposition §6.\n"
"\n"
"For example, §7 is a predicate that sends §8 to the statement &ldquo;§9 is prime&rdquo;. For certain values of §10 this is a true predicate while for other values of §11 this is a false predicate.\n"
"\n"
"Predicates may also depend on multiple variables. For example the equality type on §12 defines a function §13 sending §14 to the proposition §15. For certain values of §16 and §17 this is a true proposition, while for other values it may be a false proposition.\n"
"\n"
"There are two general ways to turn an arbitrary predicate §18 into a proposition which no longer depends on the value of a variable of type §19.\n"
"\n"
"The first method uses the *universal quantifier* §20:\n"
"§21 is the proposition that asserts that §22 is true for every §23\n"
"\n"
"The second method uses the *existential quantifier* §24:\n"
"§25 is the proposition that asserts that there is some §26 so that §27 is true.\n"
"\n"
"In this world, we will learn how to prove propositions and use hypotheses involving the *universal quantifier* §28 and *existential quantifier* §29."
msgstr ""

#: Game.Levels.TypeWorld.L01_Elements
msgid "Elements"
msgstr ""

#. §0: `f : A → B`
#. §1: `x y : A`
#. §2: `p : x = y`
#. §3: `f`
#. §4: `f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Suppose §0 is a function.\n"
"\n"
"Let §1 be elements and suppose §2.\n"
"\n"
"Then part of what it means for the function §3 to be *well-defined* is that §4.\n"
"\n"
"Can you prove this?"
msgstr ""

#. §0: `f : A → B`
#. §1: `∀ y : B, ∃ x : A, f x = y`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
msgid "A function §0 is *surjective* if §1."
msgstr ""

#. §0: `A × B → B × A`
#. §1: `A × B`
#. §2: `B × A`
#. §3: `p : A × B`
#. §4: `p.1 : A`
#. §5: `p.2 : B`
#. §6: `B × A`
#: Game.Levels.ProductWorld.L04_Symmetry
msgid "The product type comes with function of type §0 which swaps the elements of an ordered pair.\n"
"\n"
"This function can be defined by using the elimination rule for product types to map out of §1 followed by the introduction rule for product types to map into §2.\n"
"\n"
"The swap function can be defined by introducing a variable §3, projecting to its components §4 and §5, then reassembling these to give an element of type §6.\n"
"\n"
"Can you define this function?"
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `Prod.fst : A × B → A`
#. §3: `p : A × B`
#. §4: `p.1 : A`
#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "For any types §0 and §1, §2 is the function that sends §3 to its first coordinate §4."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q → R`
#. §3: `R`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "If §0 is true, §1 is true, and §2 is true, then §3 is true."
msgstr ""

#. §0: `«{P}» ∨ («{Q}» ∨ «{R}»)`
#: Game.Levels.DisjunctionWorld.L06_Associativity
#: Game.Levels.DisjunctionWorld.L06_Associativity
msgid "Here the goal is parenthesized as §0. Using your hypothesis, are you trying to prove the left-hand proposition or the right-hand one?"
msgstr ""

#. §0: `False`
#. §1: `have := «{np}» «{p}»`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If you like, you can add a proof of §0 to your assumption list by §1."
msgstr ""

#. §0: `f : A → B`
#. §1: `g : B → C`
#. §2: `g ∘ f`
#. §3: `g`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "For functions §0 and §1 if §2 is surjective, then so is §3."
msgstr ""

#. §0: `a : A`
#. §1: `f : A → B → C`
#. §2: `B → C`
#. §3: `f`
#. §4: `a`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "Given an element §0 and a function of two variables §1, define a function from §2 by evaluating the first variable of §3 at the element §4."
msgstr ""

#. §0: `«{hyp}»`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "What proof technique is available when you have a hypothesis like §0?"
msgstr ""

#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "By Contradiction"
msgstr ""

#. §0: `¬ Q → ¬ P`
#. §1: `P → Q`
#: Game.Levels.ClassicalWorld.L02_Contrapositive
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "In classical logic, §0 implies §1."
msgstr ""

#. §0: `p : A × B`
#. §1: `intro p`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Now Lean wants you to check that the second function followed by the first function yields the identity function at every element §0. Start with §1."
msgstr ""

#. §0: `assumption`
#. §1: `A`
#. §2: `A`
#: Game.Levels.TypeWorld.L01_Elements
msgid "Type §0 to tell Lean to use the assumed element of §1 to define an element of §2."
msgstr ""

#. §0: `exact fun f ↦ ⟨f ∘ Sum.inl, f ∘ Sum.inr⟩`
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
msgid "This level can be solved in one line with §0. Can you make sense of this construction?"
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "A function into a product type has a pair of component functions."
msgstr ""

#. §0: `a : A`
#. §1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "In summary, a basic axiom of equality is *reflexivity*:\n"
"for any §0, §1 is always true."
msgstr ""

#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "If this is your first time solving this level, delete your proof, and try to find another solution."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "We will now study properties that hold of some functions, but not all functions."
msgstr ""

#. §0: `P`
#. §1: `P → Q`
#. §2: `Q`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
msgid "If §0 is true and §1 is true, then §2 is true."
msgstr ""

#: Game.Levels.ImplicationWorld.L08_Transitivity
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Transitivity"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "Composing Injectivity"
msgstr ""

#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
msgid "Product With Empty"
msgstr ""

#. §0: `rfl`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Recall arithmetical equations involving numerals can be proven with §0."
msgstr ""

#. §0: `exact`
#: Game.Levels.DisjunctionWorld.L04_Symmetry
#: Game.Levels.DisjunctionWorld.L04_Symmetry
msgid "The goal is an implication you've already proven. You can use §0 together with the name of that result, to solve this goal in one line. Alternatively, you can just prove it again."
msgstr ""

#. §0: `apply f`
#. §1: `f`
#: Game.Levels.FunctionWorld.L03_UsingFunctionsBackwards
msgid "Start with §0 to apply the function §1 to transform your goal."
msgstr ""

#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "The overall objective here is to prove a conjunction. Which tactic can help break this up into simpler statements?"
msgstr ""

#. §0: `exact «{p}»`
#. §1: `«{p}»`
#. §2: `«{P}»`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
#: Game.Levels.ImplicationWorld.L03_ApplyingImplication
msgid "Type §0 to tell Lean that §1 is a proof of §2."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A × B`
#. §3: `A × B → B × A`
#. §4: `B × A → A × B`
#. §5: `A × B`
#. §6: `B × A`
#. §7: `constructor`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
msgid "Recall that for any types §0 and §1, we may form their *product type* §2.\n"
"\n"
"We proved that there are canonical functions §3 and §4.\n"
"\n"
"In this level, we will see that these functions define an equivalence between the type §5 and the type §6. This gives a more complete account of the symmetry of the product.\n"
"\n"
"To define this equivalence, we need four pieces of data. Start by typing §7 to tell Lean to ask you to supply each piece of data one at a time."
msgstr ""

#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "The goal is to prove an implication. What tactic can be used to get started?"
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
#: Game.Levels.AdvancedFunctionWorld.L11_InvertibleImpliesBijective
msgid "An invertible function is bijective."
msgstr ""

#. §0: `Or`
#. §1: `P`
#. §2: `P ∨ Q`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Look at the theorems about §0 if you have forgotten how to tell Lean about the relationship between §1 and §2."
msgstr ""

#. §0: `intro`
#. §1: `P → Q`
#. §2: `intro p`
#. §3: `p : P`
#. §4: `Q`
#. §5: `P → Q → R`
#. §6: `intro p q`
#. §7: `p : P`
#. §8: `q : Q`
#. §9: `R`
#: Game.Levels.FunctionWorld.L01_IdentityFunction
msgid "The §0 tactic, short for *introduction*, is used to introduce one or more hypotheses when the goal is a function type or an implication. It can be used by itself or followed by names for those hypotheses. For example, when the goal is §1, type §2 to add an assumption §3 and update the goal to §4. When the goal is §5, type §6 to add assumptions §7 and §8 and update the goal to §9."
msgstr ""

#. §0: `Nat.add_zero : ∀ n : ℕ, n + 0 = n`
#. §1: `Nat.add_succ : ∀ m n : ℕ, m + succ n = succ (m + n)`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "The theorems §0 and §1 are now in your library for later use."
msgstr ""

#: Game.Levels.EmptyWorld.L03_ThroughEmpty
msgid "Through Empty"
msgstr ""

#. §0: `x y : A`
#. §1: `p q : x = y`
#. §2: `p = q`
#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "The equality type is a proposition: for §0 if §1 then §2"
msgstr ""

#. §0: `«{hc}»`
#. §1: `cases «{hc}»`
#. §2: `rcases «{hc}» with ⟨a, ha⟩`
#. §3: `let ⟨a, ha⟩ = «{hc}»`
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "To break down the hypothesis §0 try §1 or §2 or §3."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `¬ P`
#. §3: `P → False`
#. §4: `¬ P`
#. §5: `P`
#. §6: `False`
#: Game.Levels.NegationWorld.L02_Negation
msgid "Given a proposition §0, the *negation* of §1 &mdash; abbreviated §2 &mdash; is defined to be the proposition §3.\n"
"\n"
"If we have a proof of §4 and also a proof of §5 then we get something very strange: a proof of §6!\n"
"\n"
"This can be expressed in various different ways, as we shall see over the next few levels.\n"
"\n"
"In this level, we encode this statement in the way that allows for the simplest proof.\n"
"\n"
"In subsequent levels, we shall express this tautology in several logically equivalent forms."
msgstr ""

#. §0: `12 + 23 = 5 * (4 + 3)`
#. §1: `rfl`
#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Arithmetic equations involving explicit numerals such as §0 hold by §1."
msgstr ""

#. §0: `«{f}»`
#: Game.Levels.ProductWorld.L06_Currying
msgid "What sort of inputs does the function §0 require?"
msgstr ""

#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "As an extra challenge, can you solve this level by appealing to the law of excluded middle only once? Alternatively, move on to the Boss Level of Classical World."
msgstr ""

#. §0: `b`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "Now you are asked to prove a special case of the indexed family of propositions, where the indexing element §0 is specialized to the element you provided."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L07_CancelingInjectivity
msgid "Canceling Injectivity"
msgstr ""

#. §0: `«{np}»`
#: Game.Levels.NegationWorld.L09_NegatingConjunction
#: Game.Levels.NegationWorld.L09_NegatingConjunction
msgid "How can we apply the hypothesis §0?"
msgstr ""

#. §0: `«{np}» : P → False`
#: Game.Levels.NegationWorld.L02_Negation
#: Game.Levels.NegationWorld.L03_DoubleNegation
msgid "We have an assumption §0. What can be done with a proof of implication?"
msgstr ""

#. §0: `¬ (P → Q)`
#. §1: `P → Q`
#. §2: `P → Q`
#. §3: `P`
#. §4: `Q`
#. §5: `P`
#. §6: `Q`
#. §7: `P ∧ ¬ Q`
#. §8: `¬ (P → Q)`
#. §9: `P`
#. §10: `Q`
#. §11: `P → Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "In this level, we will study the proposition §0.\n"
"\n"
"How would we disprove the implication §1?\n"
"\n"
"What does it mean for §2 to be false?\n"
"\n"
"The implication asserts that if §3 is true then §4 must be true as well.\n"
"\n"
"So if we show that §5 is true but §6 is false, this would disprove the implication.\n"
"\n"
"In this level, we will prove that §7 implies §8. That is, if §9 is true and §10 is false, then §11 is not true."
msgstr ""

#. §0: `P`
#. §1: `False.elim : False → P`
#. §2: `False`
#. §3: `P`
#: Game.Levels.NegationWorld.L01_ExFalso
msgid "For any proposition §0, §1 proves that §2 implies §3."
msgstr ""

#. §0: `rfl`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "The tactic §0 tries to solve a goal whose type is an equality where the left hand side and right hand side are equal by definition."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L01_TotalFunctions
msgid "Total Functions"
msgstr ""

#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Define the canonical function projecting from a product type to its second argument."
msgstr ""

#. §0: `f : A → B`
#. §1: `x y : A`
#. §2: `f x = f y`
#: Game.Levels.EqualityWorld.L06_ApplyingFunctions
msgid "Functions are well-defined: if §0 and §1 are equal, then §2."
msgstr ""

#. §0: `not : Bool → Bool`
#. §1: `false`
#. §2: `true`
#. §3: `true`
#. §4: `false`
#. §5: `b = not (not b)`
#. §6: `b : Bool`
#. §7: `id = not ∘ not`
#. §8: `Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L14_DoubleNegation
msgid "Recall the function §0 that is defined to send the boolean §1 to §2 and to send the boolean §3 to §4.\n"
"\n"
"In Boolean World, we proved that §5 for any boolean §6.\n"
"\n"
"In this level, we will apply that result to prove that §7 as functions §8."
msgstr ""

#. §0: `have pq : P ∨ Q := «{h}».1`
#. §1: `«{h}»`
#. §2: `rcases «{h}» with ⟨p | q, r | s⟩`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "Try §0 to start to break apart the hypothesis §1. Alternatively, §2 will break out both the components and the cases associated to this hypothesis."
msgstr ""

#. §0: `«{np}»`
#: Game.Levels.NegationWorld.L05_Absurd
#: Game.Levels.NegationWorld.L06_ModusTollens
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "What is the logical structure of the type of §0?"
msgstr ""

#. §0: `constructor`
#: Game.Levels.DependentWorld.L04_Pairs
msgid "Your goal is to define a pair of functions, so start with the tactic §0."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Induction"
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `¬ P`
#: Game.Levels.ClassicalWorld.L06_BossLevel
msgid "In classical logic, for any proposition §0, §1 is true or §2 is true."
msgstr ""

#: Game.Levels.EquivalenceWorld
msgid "Equivalence World"
msgstr ""

#. §0: `P : A → Prop`
#. §1: `∃ x : A, P x`
#. §2: `a : A`
#. §3: `P a`
#. §4: `∃ x : A, P x`
#. §5: `⟨a, p_a⟩`
#. §6: `a : A`
#. §7: `p_a : P a`
#. §8: `P a`
#: Game.Levels.QuantifierWorld.L04_IntroducingExistence
msgid "For a family of propositions §0, §1 is the proposition that asserts that there is some element §2 so that §3 is true. An element of §4 may be thought of as a *dependent pair* §5 where the first component specifies an element §6 while the second component specifies a proof §7 of the corresponding proposition §8."
msgstr ""

#. §0: `A`
#. §1: `A → A → Prop`
#. §2: `x y : A`
#. §3: `x = y`
#. §4: `∀ x`
#. §5: `∃ x`
#. §6: `∀ y`
#. §7: `∃ y`
#. §8: `x`
#. §9: `y`
#. §10: `∀ x, ∀ y, x = y ↔ ∀ y, ∀ x, x = y`
#. §11: `∃ x, ∃ y, x = y ↔ ∃ x, ∃ y, x = y`
#. §12: `x = y ↔ y = x`
#. §13: `∀ x, ∃ y, x = y ↔ ∀ y, ∃ x, x = y`
#. §14: `∃ x, ∀ y, x = y ↔ ∃ y, ∀ x, x = y`
#. §15: `∀ x : A, ∀ y : A, x = y`
#. §16: `∀ x : A, ∃ y : A, x = y`
#. §17: `∃ x : A, ∀ y : A, x = y`
#. §18: `∃ x : A, ∃ y : A, x = y`
#. §19: `∃ x : A, ∃ y : A, x = y`
#. §20: `A`
#. §21: `a : A`
#. §22: `∀ x : A, ∀ y : A, x = y`
#. §23: `A`
#. §24: `A`
#. §25: `A`
#. §26: `x y : A`
#. §27: `∃ x : A, ∀ y : A, x = y`
#. §28: `A`
#. §29: `A`
#. §30: `A`
#. §31: `A`
#. §32: `x : A`
#. §33: `y : A`
#. §34: `x`
#. §35: `∀ x : A, ∃ y : A, x = y`
#. §36: `A`
#: Game.Levels.QuantifierWorld.L05_MultipleQuantifiers
msgid "Any type §0 has a family of propositions §1 given by the equality types.\n"
"\n"
"For §2, we have the proposition §3.\n"
"\n"
"Using the universal and existential quantifiers we can form eight different propositions:\n"
"\n"
"* We can choose either §4 or §5.\n"
"* We can choose either §6 or §7.\n"
"* We can put the quantifier involving §8 before or after the quantifier involving §9.\n"
"\n"
"When we have two existential quantifiers or two universal quantifiers, the order doesn't matter, so we have logical equivalences\n"
"\n"
"* §10\n"
"* §11\n"
"\n"
"In this case, since §12, we have further logical equivalences\n"
"\n"
"* §13\n"
"* §14\n"
"\n"
"The four statements\n"
"* §15\n"
"* §16\n"
"* §17\n"
"* §18\n"
"have very different meanings.\n"
"\n"
"The statement §19 asserts that the type §20 is *inhabited* meaning has an element §21.\n"
"Whenever such an element exists, this statement is true, but for the empty type, this statement is false.\n"
"\n"
"The statement §22 asserts that the type §23 is a *proposition*. When §24 is empty this is true (as there is nothing to prove). When §25 is a true proposition, it is also true, because any two proofs §26 are equal.\n"
"\n"
"The statement §27 asserts that the type §28 is a true proposition, or equivalently, that the type §29 is *contractible*. When §30 is empty, this statement is false, but when §31 is a true proposition, it has some proof §32 and any other proof §33 is equal to §34.\n"
"\n"
"The final statement §35 is just true for any type §36. Your objective in this level is to prove this."
msgstr ""

#. §0: `cases «{x}»`
#. §1: `rcases «{x}» with a | b`
#. §2: `«{x}» : A ⊕ B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
#: Game.Levels.CoproductWorld.L05_Symmetry
msgid "Use either §0 or §1 to consider the possible cases for the variable §2."
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `p`
#. §3: `P`
#. §4: `h`
#. §5: `P → Q`
#. §6: `Q`
#. §7: `h`
#. §8: `p`
#: Game.Levels.ImplicationWorld.L02_ModusPonens
msgid "Now we are in the setting of two proposition variables §0 and §1 with two hypotheses. The first assumption provides a proof §2 that the proposition §3 is true. The second provides a proof §4 that the implication §5 is true.\n"
"\n"
"It follows from both of these facts that §6 is also true and we can construct a proof by applying the hypothesis §7 to the proof §8.\n"
"\n"
"This line of reasoning has the Latin name *modus ponens*."
msgstr ""

#. §0: `intro p`
#: Game.Levels.BooleanWorld.L08_NotEqual
msgid "Start with §0."
msgstr ""

#: Game.Levels.ImplicationWorld.L05_ProvingImplication
msgid "Proving Implication"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P`
#. §3: `Q`
#. §4: `P → Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "For any propositions §0 and §1, if §2 is true and §3 is false, then §4 is not true."
msgstr ""

#. §0: `m`
#. §1: `n`
#. §2: `m + n = n + m`
#: Game.Levels.NaturalNumbersWorld.L09_CommutingAddition
msgid "Using the theorems we have proven so far, we can now prove a serious theorem about the natural numbers, namely the commutativity of addition.\n"
"\n"
"That is, we will show that for all natural numbers §0 and §1, §2.\n"
"\n"
"This can be proven by induction on either variable, though you may find one variable easier than the other.\n"
"\n"
"Good luck!"
msgstr ""

#. §0: `cases «{x}»`
#. §1: `cases «{y}»`
#. §2: `cases «{x}» <;> cases «{y}»`
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "This result can be proven in cases. Try §0 followed by §1. You can pass to both cases at once by typing §2"
msgstr ""

#. §0: `A → B`
#. §1: `A`
#. §2: `B`
#. §3: `f : A → B`
#. §4: `A`
#. §5: `B`
#. §6: `A → B`
#. §7: `A → B`
#. §8: `A → B`
#. §9: `A → B`
#: Game.Levels.FunctionWorld
msgid "More complicated types can be constructed from previously-defined types by iteratively applying *type forming operations*.\n"
"\n"
"The first and arguably most important of these is the type §0 of functions from §1 to §2. An element §3 defines a *function* from §4 to §5.\n"
"\n"
"In this level, we will explain how to define and use functions. Specifically, we will learn rules that describe:\n"
"\n"
"* How to construct elements of type §6.\n"
"* How to use elements of type §7 to construct elements of other types.\n"
"\n"
"The rule for defining elements of type §8 is called the *introduction rule* for function types. It provides a strategy that can be used when the goal is a function type.\n"
"\n"
"The rule for using elements of type §9 is called the *elimination rule* for function types. It provides a strategy that can be used when the context involves an element of a function type."
msgstr ""

#. §0: `h : ∀ x : A, P x`
#. §1: `a : A`
#: Game.Levels.QuantifierWorld.L03_UniversalElimination
msgid "This explains the *elimination rule* for universally quantified statements. Like the elimination for function types, it corresponds to evaluating the proof §0 at a specific element §1."
msgstr ""

#: Game.Levels.ProductWorld.L07_Uncurrying
msgid "Uncurrying"
msgstr ""

#. §0: `not`
#: Game.Levels.BooleanWorld.L01_Negation
msgid "Lean has a built in name §0 for this function. It is now in your library."
msgstr ""

#: Game.Levels.ImplicationWorld.L07_ProvingAssumedImplication
msgid "Proving Assumed Implication"
msgstr ""

#. §0: `exact`
#. §1: `«{f}»`
#. §2: `apply`
#: Game.Levels.FunctionWorld.L06_MultivariableFunctions
msgid "You can use the tactic §0 by supplying §1 with two arguments, in the correct order, with spaces in between (but no parentheses). Alternatively you can use the tactic §2."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
msgid "Canceling Surjectivity"
msgstr ""

#. §0: `intro`
#. §1: `Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L03_CancelingSurjectivity
#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "To prove a universally quantified statement, start with §0 to introduce an arbitrary element of type §1. "
msgstr ""

#. §0: `x y : Bool`
#. §1: `or x y = or y x`
#. §2: `x || y`
#. §3: `or x y`
#: Game.Levels.BooleanWorld.L06_DisjunctionSymmetry
msgid "For any booleans §0, §1, capturing the symmetry of disjunction.\n"
"\n"
"Note Lean has an alternate notation §2 for §3."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `b : A`
#. §4: `A ⊕ B`
#. §5: `Sum.inr : B → A ⊕ B`
#. §6: `A ⊕ B`
#. §7: `apply Sum.inr`
#. §8: `B`
#. §9: `right`
#. §10: `A ⊕ B`
#. §11: `right`
#. §12: `B`
#. §13: `A ⊕ B`
#. §14: `Sum.inr : B → A ⊕ B`
#. §15: `right`
#. §16: `B`
#. §17: `Sum.inl, Sum.inr : A → A ⊕ A`
#. §18: `A`
#: Game.Levels.CoproductWorld.L02_RightInclusion
msgid "For types §0 and §1, the coproduct type §2 has two kinds of elements. The second kind can be thought of as copies of elements §3 included into the coproduct §4 *on the right*.\n"
"\n"
"Lean has a built in function called §5, which can now be found in your library.\n"
"\n"
"If the goal is to produce an element of §6, typing §7 will convert this to a goal of producing an element of §8.\n"
"\n"
"The tactic §9 has the same effect. When the goal is a coproduct type §10, using the tactic §11 tells Lean that you plan to provide an element of type §12, which should then be converted to an element of type §13 by applying the function §14. Thus, typing §15 will update the goal to type §16.\n"
"\n"
"Note that §17 are *different functions* (as long as the type §18 has at least one element) in a way we will be able to make more precise later."
msgstr ""

#. §0: `+ : ℕ → ℕ → ℕ`
#. §1: `ℕ`
#. §2: `m`
#. §3: `m + : ℕ → ℕ`
#. §4: `m + 0`
#. §5: `m + succ k`
#. §6: `k`
#. §7: `m + 0 = m`
#. §8: `rfl : m + 0 = m`
#. §9: `m + succ k`
#. §10: `m`
#. §11: `k`
#. §12: `m + : ℕ → ℕ`
#. §13: `m + succ k`
#. §14: `m + k`
#. §15: `m + succ k = succ (m + k)`
#. §16: `rfl : m + succ k = succ (m + k)`
#. §17: `k.succ`
#. §18: `succ k`
#: Game.Levels.NaturalNumbersWorld.L06_DefiningAddition
msgid "Addition is a binary function on natural numbers, meaning it has type §0.\n"
"\n"
"In Lean, the addition function is defined *by recursion* &mdash; i.e., by the elimination rule for §1 or by the constructive form of induction &mdash; on its second variable.\n"
"\n"
"This means that for an arbitrary natural number §2 &mdash; the first variable &mdash; we define a function §3 by cases, that is by specifying values for\n"
"\n"
"* §4 and\n"
"* §5 for an arbitrary natural number §6.\n"
"\n"
"For the first equation, we define §7. Since this is part of the definition of what it means to add zero on the right, we have §8.\n"
"\n"
"For the second equation, we must find a formula for §9 using §10, §11, the successor function, and previously defined values of the function §12.\n"
"\n"
"In particular, by the time we are looking to calculate §13 we have already defined §14. So we can use this to give the definition §15. Since this is part of the definition of what it means to add zero on the right, we have §16.\n"
"\n"
"In this level you are asked to verify the defining equations for the addition function, which is now in your library. Note Lean likes to write §17 for §18."
msgstr ""

#: Game.Levels.CoproductWorld
msgid "Coproduct World"
msgstr ""

#: Game.Levels.ConjunctionWorld.L10_BossLevel
msgid "Next move on to Coproduct World to learn about another type forming operation, which is in some sense &ldquo;dual&rdquo; to product types."
msgstr ""

#. §0: `X → A × B`
#. §1: `(X → A) × (X → B)`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The *universal property* of the product is the correspondence between functions §0 into a product and pairs of functions §1.\n"
"\n"
"We are now ready for the Boss Level of Product World."
msgstr ""

#. §0: `exact «{p}».1`
#: Game.Levels.ProductWorld.L02_FirstProjection
#: Game.Levels.ProductWorld.L03_SecondProjection
msgid "Now type §0 to return the first projection."
msgstr ""

#. §0: `intro`
#: Game.Levels.ProductWorld.L09_UniversalProperty
msgid "The goal is a still function type, so continue with §0."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Have another look at Level 5 of Disjunction World, discussing the universal property of disjunction. How are these statements related?"
msgstr ""

#. §0: `h : ∃ a : A, P a`
#. §1: `P : A → Prop`
#. §2: `h.choose : A`
#. §3: `h.choose_spec`
#. §4: `P (h.choose)`
#: Game.Levels.AdvancedFunctionWorld.L12_BijectiveImpliesInvertible
msgid "Given a proof §0 for some §1, the axiom of choice selects an element\n"
"§2. The theorem §3 then proves the proposition §4."
msgstr ""

#. §0: `P`
#. §1: `P`
#. §2: `P`
#. §3: `P`
#. §4: `P ∨ ¬ P`
#. §5: `Classical.em P  : P ∨ ¬ P`
#. §6: `P`
#. §7: `em P : P ∨ ¬ P`
#. §8: `byContradiction : ¬ ¬ P → P`
#. §9: `P`
#. §10: `em`
#. §11: `em`
#. §12: `P`
#. §13: `P`
#. §14: `Q`
#: Game.Levels.ClassicalWorld.L03_ExcludedMiddle
msgid "The *law of excluded middle* asserts that for any proposition §0, either §1 is true or §2 is false.\n"
"\n"
"In other words, for any proposition §3, §4 is always true.\n"
"\n"
"Lean has a built-in name §5 for *the law of excluded middle* at the proposition §6. In Classical World, classical reasoning techniques are open, so you can refer to this proof by typing §7.\n"
"\n"
"Note that in contrast to §8, the proposition §9 is an *explicit argument* of the function §10. So if you type just §11, Lean will ask which proposition you have in mind.\n"
"\n"
"This is because when you are applying proof by contradiction, it is usually clear from context which proposition §12 is involved, whereas when you are appealing to the law of excluded middle, this is often not so clear.\n"
"\n"
"See if you can use the law of excluded middle to prove that for any propositions §13 and §14 one\n"
"of the following four conjunctions holds."
msgstr ""

#: Game.Levels.BooleanWorld.L07_DeMorgan
msgid "DeMorgan"
msgstr ""

#. §0: `pred : ℕ → ℕ`
#. §1: `pred 0 = 0`
#. §2: `∀ n : ℕ, pred (succ n) = n`
#. §3: `pred ∘ succ = id`
#. §4: `ℕ`
#. §5: `ℕ`
#: Game.Levels.NaturalNumbersWorld.L05_PredecessorOfSuccessor
msgid "In the previous level you defined the function §0 by recursion and proved that it satisfies the properties:\n"
"\n"
"* §1 and\n"
"* §2.\n"
"\n"
"In this level you are asked to check a closely related property: namely that\n"
"§3 as functions from §4 to §5.\n"
"\n"
"Can you recall how to establish an equality between functions? Revisit the Function Extensionality level of Advanced Function World if you need a reminder."
msgstr ""

#. §0: `ext`
#: Game.Levels.EquivalenceWorld.L06_MoreComponentFunctions
msgid "This is not a definitional equality, so requires the use of function extensionality. Use the tactic §0 to reduce this to proving the componentwise equality of functions."
msgstr ""

#. §0: `(P ∧ Q) ∧ R`
#. §1: `P ∧ (Q ∧ R)`
#: Game.Levels.ConjunctionWorld.L05_Associativity
msgid "Conjunction is associative: §0 is true if and only if §1 is true."
msgstr ""

#. §0: `∧`
#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Here the §0 is the outermost logical connective. How do you prove conjunctions?"
msgstr ""

#. §0: `x = y`
#. §1: `y = z`
#. §2: `x = z`
#: Game.Levels.EqualityWorld.L05_Transitivity
msgid "Equality is transitive: if §0 and §1 then §2."
msgstr ""

#. §0: `«{f}» «{x}»`
#. §1: `exact «{f}» «{x}»`
#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.ProductWorld.L08_ComponentFunctions
msgid "What is the type of the term §0? If you're not sure, you can type §1 and read the error message to find out."
msgstr ""

#. §0: `Prop`
#: Game.Levels.TypeWorld.L05_TypeOfPropositions
msgid "The type §0 is the type of propositions."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L07_AddingZero
msgid "Adding Zero"
msgstr ""

#. §0: `P`
#. §1: `exact «{p}»`
#: Game.Levels.ConjunctionWorld.L01_IntroducingAnd
#: Game.Levels.ConjunctionWorld.L02_UsingAnd
msgid "Now the goal is just to prove §0. Type §1 to supply this proof."
msgstr ""

#. §0: `S → T`
#. §1: `T`
#. §2: `S`
#. §3: `S`
#. §4: `P`
#. §5: `Q`
#. §6: `P`
#. §7: `Q → P`
#. §8: `Q`
#: Game.Levels.ImplicationWorld.L06_ProvingImpliedAssumption
msgid "To prove an implication §0 one needs to give a construction of a proof of §1 from a proof of §2. As we will see in the following example, it is not necessary to actually *use* the assumption that §3 is true after introducing it.\n"
"\n"
"In this level we will consider two propositions §4 and §5 and assume that the proposition §6 is true.\n"
"\n"
"It follows that §7 is true, no matter whether §8 is true or false. Can you prove this?"
msgstr ""

#: Game.Levels.BooleanWorld.L03_Conjunction
msgid "Conjunction"
msgstr ""

#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "In the next level, we will establish the first of several equivalences involving function types."
msgstr ""

#. §0: `apply`
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
#: Game.Levels.AdvancedFunctionWorld.L06_ComposingInjectivity
msgid "You have two similar hypothesis. Only one of them applies. Which one is it? Try using the tactic §0"
msgstr ""

#. §0: `have ⟨p, nq⟩ := «{pnq}»`
#. §1: `p`
#. §2: `P`
#. §3: `nq`
#. §4: `¬ Q`
#: Game.Levels.NegationWorld.L07_NegatingImplication
msgid "You can use §0 to apply the elimination rule for conjunctions to obtain a proof §1 of §2 and a proof §3 of §4."
msgstr ""

#: Game.Levels.AdvancedFunctionWorld.L04_ComposingSurjectivity
msgid "In the next level, we will introduce another property that holds for some, but not all, functions."
msgstr ""

#. §0: `g : B → C`
#. §1: `f : A → B`
#. §2: `g ∘ f : A → C`
#. §3: `x : A`
#. §4: `g (f x)`
#: Game.Levels.FunctionWorld.L04_ComposingFunctions
msgid "Given functions §0 and §1, define the composite function §2 that sends §3 to §4."
msgstr ""

#: Game.Levels.ProductWorld.L05_Associativity
#: Game.Levels.CoproductWorld.L06_Associativity
#: Game.Levels.CoproductWorld.L07_Distributivity
#: Game.Levels.CoproductWorld.L07_Distributivity
msgid "Now the goal is a function type. What tactic is used to define functions?"
msgstr ""

#. §0: `succ : ℕ → ℕ`
#. §1: `n`
#. §2: `n + 1`
#: Game.Levels.NaturalNumbersWorld.L01_Numerals
msgid "An introduction rule for the type of natural numbers defines the *successor function* §0, which sends each natural number §1 to §2. Note,\n"
"however, that formally speaking, addition is defined in terms of the successor and not the other way around."
msgstr ""

#: Game.Levels.TypeWorld.L04_UnitType
msgid "Unit Type"
msgstr ""

#. §0: `h : S → T`
#. §1: `apply h`
#. §2: `T`
#. §3: `S`
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
#: Game.Levels.ImplicationWorld.L04_ComposingImplication
msgid "In the presence of a hypothesis §0, the tactic §1 reduces the problem of proving §2 to the problem of proving §3. Can this be used here?"
msgstr ""

#: Game.Levels.ProductWorld.L02_FirstProjection
msgid "Define the canonical function projecting from a product type to its first argument."
msgstr ""

#. §0: `S → X`
#. §1: `T → W`
#. §2: `R → Y`
#. §3: `W → Q`
#. §4: `U → S`
#. §5: `Y → T`
#. §6: `X → V`
#. §7: `Q → U`
#. §8: `V → Z`
#. §9: `P → R`
#. §10: `P`
#. §11: `Z`
#: Game.Levels.ImplicationWorld.L10_BossLevel
msgid "If §0, §1, §2, §3, §4, §5, §6, §7, §8 and §9 are true then §10 implies §11."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "Every natural number is even or odd."
msgstr ""

#. §0: `P`
#. §1: `exfalso`
#. §2: `False.elim : False → P`
#. §3: `False`
#: Game.Levels.NegationWorld.L05_Absurd
msgid "If the goal is to prove a proposition §0, then the tactic §1 applies the implication §2 to reduce to the goal of proving §3."
msgstr ""

#: Game.Levels.NaturalNumbersWorld.L02_NormalForms
msgid "Can you solve this level in one line?"
msgstr ""

#. §0: `f : A ⊕ B → C`
#. §1: `A → C`
#. §2: `B → C`
#. §3: `g : A → C`
#. §4: `h : B → C`
#. §5: `A ⊕ B → C`
#. §6: `x : A ⊕ B`
#. §7: `x`
#. §8: `Sum.inl a`
#. §9: `a : A`
#. §10: `x`
#. §11: `Sum.inr b`
#. §12: `b : B`
#. §13: `g`
#. §14: `g a : C`
#. §15: `h`
#. §16: `h b : C`
#. §17: `x : A ⊕ B`
#. §18: `cases x`
#. §19: `x`
#. §20: `Sum.inl a`
#. §21: `a : A`
#. §22: `x`
#. §23: `Sum.inr b`
#. §24: `b : B`
#. §25: `cases`
#. §26: `x : A ⊕ B`
#. §27: `rcases x with a | b`
#. §28: `cases x`
#. §29: `a : A`
#. §30: `b : B`
#. §31: `a`
#. §32: `b`
#. §33: `cases x`
#. §34: `rcases x with a | b`
#. §35: `a : A`
#. §36: `b : B`
#: Game.Levels.CoproductWorld.L04_UniversalProperty
msgid "A function §0 mapping out of a coproduct type may be *broken apart* into component functions of types §1 and §2.\n"
"\n"
"Conversely, given an arbitrary pair of functions §3 and §4, one can build a function of type §5.\n"
"\n"
"This function is defined by introducing a variable element §6 and then splitting into two cases: the case where §7 is of the form §8 for some §9 and the case where §10 is of the form §11 for some §12.\n"
"\n"
"In the first case, the function §13 can be used to define an element §14, while in the second case the function §15 can be used to define an element §16.\n"
"\n"
"Given an element §17, type §18 to ask Lean to consider both cases arising from the introduction rules for coproduct types: the first being that §19 is of the form §20 for some §21 and the second being that §22 is of the form §23 for some §24.\n"
"\n"
"There is another tactic, similar to §25, which allows you to give explicit names for the elements appearing in each case.\n"
"\n"
"Given an element §26, then §27 can be used in place of §28 to provide an element §29 in the first case and an element §30 in the second. (Here you can choose any variable names for §31 and §32.)\n"
"\n"
"Either §33 or §34 can be used to split into the two cases mentioned above.\n"
"\n"
"Both cases will have the same goal type but will have a different context of objects, one of which contains the element §35 and the other of which contains the element §36."
msgstr ""

#. §0: `B : A → Type`
#. §1: `(x : A) × B x`
#. §2: `B x`
#. §3: `x`
#. §4: `A`
#. §5: `p : (x : A) × B x`
#. §6: `p.1 : A`
#. §7: `p.fst : A`
#. §8: `p.2 : B p.1`
#. §9: `p.snd : B p.snd`
#. §10: `(x : A) × B x`
#. §11: `A`
#. §12: `(x : A) × B x`
#. §13: `p : (x : A) × B x`
#. §14: `p : (x : A) × B x`
#. §15: `rfl : p = ⟨p.1, p.2⟩`
#: Game.Levels.DependentWorld.L04_Pairs
msgid "Consider a family of types §0.\n"
"\n"
"The *dependent pair type* §1 collects together all of the elements of the types §2 as §3 ranges over all elements of the indexing type §4.\n"
"\n"
"More precisely, each element §5 defines a pair of elements. Its first component defines an element §6 in the indexing type, which Lean also denotes by §7.\n"
"\n"
"Its second component defines an element §8 in the fiber over the first component, which Lean also denotes by §9.\n"
"\n"
"Your task in this level is to define both projection functions from the dependent pair type.\n"
"\n"
"The first of these defines an ordinary function from the type §10 to the type §11.\n"
"\n"
"The second of these defines a dependent function mapping out of type type §12. The reason the second project is a *dependent* function is that its output type depends on the input element §13.\n"
"\n"
"Note that for §14, we have §15."
msgstr ""

#. §0: `a : A`
#. §1: `b : B`
#. §2: `⟨a ,b⟩ : A × B`
#. §3: `⟨a, b⟩.fst : A`
#. §4: `⟨a , b⟩.snd : B`
#. §5: `a`
#. §6: `b`
#. §7: `⟨a, b⟩.fst = a`
#. §8: `⟨a, b⟩.snd = b`
#. §9: `rfl`
#: Game.Levels.EqualityWorld.L03_ProjectedPairs
msgid "Now consider elements §0 and §1.\n"
"\n"
"There is a corresponding pair §2 that we can project back to define terms\n"
"§3 and §4. How do these relate to the original terms §5 and §6?\n"
"\n"
"Another *computation rule* for product types tells us §7 and §8 by definition, meaning that §9 can provide proofs."
msgstr ""

#. §0: `A`
#. §1: `B`
#. §2: `A ⊕ B`
#. §3: `A ⊕ B → B ⊕ A`
#. §4: `B ⊕ A → A ⊕ B`
#. §5: `A ⊕ B`
#. §6: `B ⊕ A`
#. §7: `constructor`
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Recall that for any types §0 and §1, we may form their *coproduct type* §2.\n"
"\n"
"We proved that there are canonical functions §3 and §4.\n"
"\n"
"In this level, we will see that these functions define an equivalence between the type §5 and the type §6. This gives a more complete account of the symmetry of the coproduct.\n"
"\n"
"To define this equivalence, we need four pieces of data. Start by typing §7 to tell Lean to ask you to supply each piece of data one at a time."
msgstr ""

#: Game.Levels.ProductWorld.L08_ComponentFunctions
#: Game.Levels.CoproductWorld.L03_ComponentFunctions
#: Game.Levels.EquivalenceWorld.L05_ComponentFunctions
msgid "Component Functions"
msgstr ""

#. §0: `A`
#. §1: `Empty`
#. §2: `A × Empty`
#: Game.Levels.EmptyWorld.L05_ProductWithEmpty
#: Game.Levels.EmptyWorld.L06_CoproductWithEmpty
msgid "For any type §0, there are functions in both directions between the types §1 and §2."
msgstr ""

#. §0: `not : Bool → Bool`
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L02_Surjectivity
#: Game.Levels.AdvancedFunctionWorld.L05_Injectivity
msgid "The function §0 is surjective."
msgstr ""

#. §0: `Function.curry`
#. §1: `Function.uncurry`
#. §2: `⟨fun f x y ↦ f ⟨x, y⟩, fun f p ↦ f p.1 p.2, fun f ↦ rfl, fun f ↦ rfl⟩`
#: Game.Levels.DependentWorld.L05_Currying
msgid "While our §0 and §1 cannot be used here, this level can still be solved in one line with §2, which also defines the corresponding equivalence of ordinary function types in Equivalence World."
msgstr ""

#. §0: `A`
#. §1: `Empty → A`
#: Game.Levels.EmptyWorld.L01_FromEmpty
msgid "For any type §0, there is a function §1 encoding the elimination rule of the empty type."
msgstr ""

#: Game.Levels.EqualityWorld.L09_EqualityProposition
msgid "We are now ready for the Boss Level of Equality World."
msgstr ""

#. §0: `V`
#. §1: `F`
#: Game.Levels.FunctionWorld.L10_BossLevel
msgid "We have now reached the Boss Level of Function World, which is considerably more challenging than the Boss Level of Type World. Have fun with this.\n"
"\n"
"We consider an arbitrary pair of types, which we call §0 and §1 &mdash; for *vector space* and *field* respectively &mdash; because the function to be defined below has a connection to linear algebra that is not explained here.\n"
"\n"
"Can you define it?"
msgstr ""

#. §0: `∀ x : A, P x`
#. §1: `a : A`
#. §2: `P a`
#. §3: `∃ x : A, ¬ (P x)`
#. §4: `∃ x : A, ¬ (P x)`
#. §5: `¬ (∀ x : A, P x)`
#: Game.Levels.QuantifierWorld.L08_NegatingUniversality
msgid "How would you disprove a statement of the form\n"
"\n"
"§0?\n"
"\n"
"To do this, it would suffice to find a single §1 so that §2 is not true.\n"
"\n"
"That is, it would suffice to prove\n"
"\n"
"§3.\n"
"\n"
"In this level we will prove §4 implies\n"
"§5."
msgstr ""

#: Game.Levels.NegationWorld.L08_NegatingDisjunction
msgid "Negating Disjunction"
msgstr ""

#. §0: `A × B → B × A`
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L01_ProductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
#: Game.Levels.EquivalenceWorld.L02_CoproductSymmetry
msgid "Now Lean wants you to define a function §0. You can either define this again or find this function in your library."
msgstr ""

#: Game.Levels.CoproductWorld.L08_BossLevel
msgid "Boss level"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `R`
#. §3: `(P → Q) → R`
#. §4: `P → (Q → R)`
#. §5: `R`
#. §6: `P → Q`
#. §7: `Q → R`
#. §8: `P`
#. §9: `R`
#. §10: `P`
#. §11: `Q`
#. §12: `P → (Q → R)`
#. §13: `P → Q → R`
#. §14: `P → (Q → R)`
#. §15: `P → Q → R → S → T`
#. §16: `P → (Q → (R → (S → T)))`
#: Game.Levels.ImplicationWorld.L08_Transitivity
msgid "For propositions §0, §1, and §2, the propositions §3 and §4 are not the same.\n"
"\n"
"The first asserts that §5 is true assuming §6. The second asserts that §7 is true assuming §8, or equivalently, that §9 is true assuming §10 and also assuming §11.\n"
"\n"
"Mathematical statements of this second form §12 are much more common. Thus the shorthand §13 implicitly refers to §14, not to the other parenthesization.\n"
"\n"
"More generally, §15 refers to §16.\n"
"\n"
"Explicit parentheses must be used to express statements with any other parenthesizations.\n"
"\n"
"Your objective in this level is to prove the transitivity of implication."
msgstr ""

#. §0: `¬ (P ∧ Q)`
#. §1: `¬ P ∧ ¬ Q`
#: Game.Levels.ClassicalWorld.L04_NegatingConjunction
msgid "Combined with what we know already, we have established a logical equivalence between  §0 and §1 in classical logic."
msgstr ""

#. §0: `(P ∨ Q) ∧ (R ∨ S)`
#. §1: `(P ∧ R) ∨ (P ∧ S) ∨ (Q ∧ R) ∨ (Q ∧ S)`
#: Game.Levels.DisjunctionWorld.L08_MoreDistributivity
msgid "§0 holds if and only if §1 holds."
msgstr ""

#. §0: `a : A`
#. §1: `a = a`
#: Game.Levels.EqualityWorld.L01_Reflexivity
msgid "For any element §0, §1 is true by reflexivity."
msgstr ""

#: Game
#: Game
msgid "Reintroduction to Proofs"
msgstr ""

#. §0: `Computer-Verified Proof: a Hands-On Introduction to Interactive Theorem Proving`
#: Game
msgid "This was created using the GameSkeleton Github Repo from the Lean Games Server hosted by ADAM: Anticipating the Digital Age of Mathematics at Heinrich Heine University Düsseldorf. It was originally designed for a first year seminar course taught at Johns Hopkins University in Fall 2025 with the title §0."
msgstr ""

#. §0: `∀ n : ℕ, P n`
#. §1: `P : ℕ → Prop`
#. §2: `∀ P : ℕ → Prop, P 0 → (∀ k : ℕ, P k → P (succ k)) → (∀ n : ℕ, P n)`
#. §3: `P`
#. §4: `P 0`
#. §5: `P k`
#. §6: `P (succ k)`
#. §7: `k`
#. §8: `∀ n : ℕ, P n`
#. §9: `∀ n : ℕ, P n`
#. §10: `P 0`
#. §11: `k : ℕ`
#. §12: `P k`
#. §13: `P (succ k)`
#. §14: `P 0`
#. §15: `P 0 → P 1`
#. §16: `P 1`
#. §17: `P 1 → P 2`
#. §18: `P 2`
#. §19: `P 2 → P 3`
#. §20: `P 3`
#: Game.Levels.NaturalNumbersWorld.L03_Induction
msgid "The *principal of mathematical induction* &mdash; also known as the elimination rule for the type of natural numbers &mdash; is a strategy for proving statements of the form\n"
"\n"
"§0\n"
"\n"
"where §1 is a predicate on the natural numbers &mdash; also known as a family of propositions.\n"
"\n"
"The formal statement of this principle is given by the axiom:\n"
"\n"
"§2\n"
"\n"
"In plain language it says\n"
"\n"
"&ldquo;for any predicate §3 on the natural numbers, if §4 is true, and if §5 implies §6 for all natural numbers §7, then §8 is true.&rdquo;\n"
"\n"
"That is, we can prove §9 after verifying two things:\n"
"\n"
"* the *base case*: proving that §10 is true\n"
"* the *inductive step*: proving that for any §11, §12 implies §13.\n"
"\n"
"By combining these hypothesis, from the fact that §14 is true and §15 is true, we can conclude that §16 is true. Then from the fact that §17 is true, we can conclude that §18 is true. Then from the fact that §19 is true, we can conclude that §20 is true. And so on.\n"
"\n"
"In this level, we will use induction to prove that every natural number is even or odd."
msgstr ""

#. §0: `P`
#. §1: `¬ ¬ P`
#. §2: `P`
#: Game.Levels.ClassicalWorld.L01_ByContradiction
msgid "In classical logic, for any proposition §0, §1 implies §2."
msgstr ""

#: Game.Levels.EmptyWorld
msgid "Empty World"
msgstr ""

#. §0: `P`
#. §1: `Q`
#. §2: `P ∧ ¬ Q → ¬ (P → Q)`
#: Game.Levels.ClassicalWorld.L05_NegatingImplication
msgid "In Negation World, we proved that for any propositions §0 and §1:\n"
"\n"
"§2.\n"
"\n"
"Our aim in this level is to prove the converse implication using classical reasoning.\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.DependentWorld.L01_Types
msgid "Define any dependent family of types indexed by the type of booleans."
msgstr ""

#. §0: `let`
#: Game.Levels.ProductWorld.L10_BossLevel
msgid "The objective of this Boss Level is to define a function that takes five variables as inputs and has three\n"
"variables as outputs by combining the data of four simpler functions.\n"
"\n"
"This function is defined as a composite &mdash; in a much more complicated sense than we have seen thusfar &mdash; of the given functions.\n"
"\n"
"Can you do it?\n"
"\n"
"The §0 tactic, which is now in your library, may be helpful for making partial progress."
msgstr ""

#: Game.Levels.ImplicationWorld.L09_ModusPonensAgain
msgid "Now we are ready for the Boss Level!"
msgstr ""

#: Game.Levels.NegationWorld.L06_ModusTollens
msgid "Modus Tollens"
msgstr ""
